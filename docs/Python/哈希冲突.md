# **哈希冲突**
Python中的字典底层依靠**哈希表**实现，在CPython中主要使用**伪随机探测**（pseudo-random probing）的**开放寻址法**来解决冲突。

**哈希表**是一种**key-value类型的数据结构**，通过**哈希函数**将键映射到数组的特定位置来存储对应的值。**哈希函数**的作用就是建立键与数组索引之间的映射关系。

Python字典要求保持一定的稀疏性以减少哈希冲突，**负载因子通常控制在2/3左右**。当增加元素导致容量不足时，会触发**扩容机制**，重新分配更大的内存空间并重新哈希所有元素，这可能导致键的排列顺序发生变化。因此在遍历字典时不能同时进行添加和删除操作。

由于字典需要预留空白空间来降低冲突概率，所以在内存中的开销相对较大，这是典型的**以空间换时间**的设计思想。

由于数据的多样性是无限的，而哈希表的存储空间是有限的，不同的键经过哈希函数计算后可能得到相同的索引位置，这种现象被称为**哈希冲突**（Hash Collision）。

### **哈希冲突的解决方法**

#### **1. 开放寻址法**（Open Addressing）

从发生冲突的位置开始，按照某种探测规则在哈希表中寻找下一个空闲位置，将发生冲突的元素存入该位置。

常见的探测方法包括：
- **线性探测法**（Linear Probing）：按固定步长依次查找下一个位置
- **平方探测法**（Quadratic Probing）：按平方数步长查找下一个位置
- **双散列函数探测法**（Double Hashing）：使用第二个哈希函数计算步长

开放寻址法的缺点在于不能真正删除元素，只能做特殊标记表示删除状态，否则会导致后续查找失败。只有在需要插入新元素时才能覆盖已标记删除的位置。

例如：现有元素1,2,3,4依次存储，若要删除3，不能直接清除其位置，而应标记为已删除。当需要插入5时，才可以覆盖原来3的位置，形成1,2,5,4的存储状态。

**Python示例**：
```python
class OpenAddressingHashTable:
    def __init__(self, size):
        """初始化哈希表"""
        self.size = size
        # 使用None表示空位，用特殊标记表示已删除
        self.table = [None] * size
        # 创建一个特殊对象用于标记删除的元素
        self.deleted = object()

    def hash_func(self, key):
        """哈希函数：将键映射到数组索引"""
        return hash(key) % self.size

    def insert(self, key, value):
        """插入键值对"""
        index = self.hash_func(key)
        # 线性探测：如果位置被占用且不是已删除状态，则继续查找下一个位置
        while self.table[index] is not None and self.table[index] != self.deleted:
            index = (index + 1) % self.size  # 循环到下一个位置
        # 找到空位或已删除位置，插入新元素
        self.table[index] = (key, value)

    def search(self, key):
        """查找指定键的值"""
        index = self.hash_func(key)
        # 查找时跳过已删除的元素
        while self.table[index] is not None:
            # 如果不是已删除标记且键匹配，则返回对应的值
            if self.table[index] != self.deleted and self.table[index][0] == key:
                return self.table[index][1]
            index = (index + 1) % self.size  # 继续探测下一个位置
        return None  # 未找到

    def delete(self, key):
        """删除指定键的元素（标记删除）"""
        index = self.hash_func(key)
        while self.table[index] is not None:
            # 如果不是已删除标记且键匹配，则标记为已删除
            if self.table[index] != self.deleted and self.table[index][0] == key:
                self.table[index] = self.deleted
                return True
            index = (index + 1) % self.size
        return False  # 未找到要删除的元素
```

#### **2. 拉链法**（Chaining）

将具有相同哈希值的元素组织成**链表结构**，并将链表的头指针存储在哈希表对应位置。增删改查操作主要在同义词链表中进行。

这种方法的优点是**可以真正删除元素**，且不会产生聚集现象，但需要额外的空间存储指针。

**Python示例**：
```python
class ChainingHashTable:
    def __init__(self, size):
        """初始化哈希表"""
        self.size = size
        # 每个槽位存储一个链表（这里用列表模拟链表）
        self.table = [[] for _ in range(size)]

    def hash_func(self, key):
        """哈希函数：将键映射到数组索引"""
        return hash(key) % self.size

    def insert(self, key, value):
        """插入键值对"""
        index = self.hash_func(key)
        bucket = self.table[index]  # 获取对应槽位的链表
        # 检查键是否已存在，存在则更新值
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # 更新已存在的键值对
                return
        # 键不存在，添加新的键值对到链表末尾
        bucket.append((key, value))

    def search(self, key):
        """查找指定键的值"""
        index = self.hash_func(key)
        bucket = self.table[index]  # 获取对应槽位的链表
        # 遍历链表查找键
        for k, v in bucket:
            if k == key:
                return v  # 找到则返回值
        return None  # 未找到

    def delete(self, key):
        """删除指定键的元素"""
        index = self.hash_func(key)
        bucket = self.table[index]  # 获取对应槽位的链表
        # 遍历链表查找要删除的键
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]  # 从链表中删除键值对
                return True
        return False  # 未找到要删除的元素
```

#### **3. 再哈希法**（Rehashing）

使用**多个不同的哈希函数**，当发生冲突时依次调用下一个哈希函数进行计算。这种方法会显著增加计算开销，但在某些场景下能有效分散元素。

**Python示例**：
```python
class RehashingHashTable:
    def __init__(self, size):
        """初始化哈希表"""
        self.size = size
        self.table = [None] * size
        # 定义多个哈希函数
        self.hash_functions = [
            lambda key, size: hash(key) % size,           # 第一个哈希函数
            lambda key, size: (hash(key) * 31) % size,    # 第二个哈希函数
            lambda key, size: (hash(key) * 37) % size     # 第三个哈希函数
        ]

    def insert(self, key, value):
        """插入键值对"""
        # 尝试每个哈希函数
        for hash_func in self.hash_functions:
            index = hash_func(key, self.size)
            # 如果当前位置为空，则插入元素
            if self.table[index] is None:
                self.table[index] = (key, value)
                return True
        # 所有哈希函数都冲突，无法插入
        raise Exception("无法插入，所有哈希函数都冲突")

    def search(self, key):
        """查找指定键的值"""
        # 尝试每个哈希函数
        for hash_func in self.hash_functions:
            index = hash_func(key, self.size)
            # 如果当前位置不为空且键匹配，则返回值
            if self.table[index] is not None and self.table[index][0] == key:
                return self.table[index][1]
        return None  # 所有哈希函数都未找到匹配元素
```

#### **4. 建立公共溢出区**

将哈希表分为**基本表**和**溢出表**两部分，当发生冲突时将元素存储到溢出区中。查找时需要同时在基本表和溢出表中进行搜索。

**Python示例**：
```python
class OverflowAreaHashTable:
    def __init__(self, main_size):
        """初始化哈希表"""
        self.main_size = main_size
        # 主表：用于存储直接哈希的元素
        self.main_table = [None] * main_size
        # 溢出区：用于存储发生冲突的元素（用列表存储）
        self.overflow_area = []

    def hash_func(self, key):
        """哈希函数：将键映射到主表索引"""
        return hash(key) % self.main_size

    def insert(self, key, value):
        """插入键值对"""
        index = self.hash_func(key)
        # 如果主表位置为空，直接插入
        if self.main_table[index] is None:
            self.main_table[index] = (key, value)
        else:
            # 否则插入到溢出区
            self.overflow_area.append((key, value))

    def search(self, key):
        """查找指定键的值"""
        index = self.hash_func(key)
        # 先在主表查找
        if self.main_table[index] is not None and self.main_table[index][0] == key:
            return self.main_table[index][1]
        
        # 再在溢出区查找
        for k, v in self.overflow_area:
            if k == key:
                return v
        return None  # 未找到

    def delete(self, key):
        """删除指定键的元素"""
        index = self.hash_func(key)
        # 在主表删除
        if self.main_table[index] is not None and self.main_table[index][0] == key:
            self.main_table[index] = None
            return True
        
        # 在溢出区删除
        for i, (k, v) in enumerate(self.overflow_area):
            if k == key:
                del self.overflow_area[i]
                return True
        return False  # 未找到要删除的元素
```

### **Python字典中的哈希冲突处理**

在CPython实现中，Python字典采用了一种优化的开放寻址法——**伪随机探测**。这种方法相比线性探测能够更好地避免元素聚集，提高查找效率。

**Python字典的关键特性**：
1. 从**Python 3.7开始**，字典保持插入顺序
2. **负载因子控制在约2/3**，超过此值会触发扩容
3. 扩容时容量通常增长为接近原容量**2倍的质数**
4. 删除操作使用**延迟删除策略**，标记删除但不立即释放空间

---