# 一些需要注意的地方

## 1.sqlalchemy中的filter(),filter_by()有什么区别

```python
db.session.query.filter(Wish.launched == False)
db.session.query.filter_by(uid=uid, launched=False)
# 一个是关键字参数, 一个是条件表达式
```

***

## 2. 继承第三方库的某个类

```python
class Query(BaseQuery):
    def filter_by(self, **kwargs):
      # kwargs是字典
        if 'status' not in kwargs.keys():
            kwargs['status'] = 1
            # 重写完成后,继承基类
        return super(Query,self).filter_by(**kwargs)

# 在SQLAlchemy中留了继承基类的接口  
db = SQLAlchemy(query_class=Query)
```

***

## 3.链式调用触发sql严格模式(sql_mode)

```python
   @classmethod
    def recent(cls):
        # 链式调用
        recent_gift = Gift.query.filter_by(launched=False).group_by(
            Gift.isbn).order_by(Gift.create_time).limit(
            current_app.config['RECENT_BOOK_COUNT']).distinct()
        return recent_gift
```

需要一下方法解锁严格模式.

```mysql
SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));	
```

## 4.原始数据-->视图数据,需要通过视图模型(viewmodel)



## 5.session.query查询

```python
   @classmethod
    def get_wish_count(cls, isbn_list):
        # 根据传入的一组isbn,到Wish表中检索出某个的礼物,并计算出某个礼物的心愿数量
        # db.session
        # mysql in查询
        db.session.query(func.count(Wish.id), Wish.isbn).filter(
                                        Wish.launched == False,
                                        Wish.isbn.in_(isbn_list),
                                        Wish.status == 1).group_by(Wish.isbn).all()
```

这种写法非常Python,要看多学多写.

db.session.query(根据检索条件返回的数据)

## 6.避免循环导入

当我们import一个文件时，python会首先去查找这个文件之前是否被import过，如果这个文件之前有被import过，就不会重新再import一次。所以如果A模块 代码里import了B模块，并且B模块里又import了A模块，python的执行顺序会变成这样：开始执行模块A当A执行到import B的地方，则停止执行A模块后面的代码，转而开始执行B模块的代码当B模块从头执行到import A的地方时，python此时并不会回过头去接着执行A剩余的代码，而且将A模块在中断前已经初始化的属性全加载到B模块中

1.在函数内部使用import,俗称 延迟导入.会影响性能.

```python
def func():
  from time import sleep
```

2.将引起循环导入的变量放到导入模块import代码前.

```python
src.user = None
from core import src
```

## 7.捕获KeyboardInterrupt异常

运行命令行程序期间,如果用户想终止程序,一般都会才用ctrl-c来终止程序运行,程序会抛出KeyboardInterrupt异常.

可以通过这一机制来实现我们想要的功能.

```python
import time
print('按下回车开始')
try:
    input('')
    starttime = time.time()
    print('开始')
    while True:
        print('计时',round(time.time()-starttime))
        time.sleep(1)
except KeyboardInterrupt:
    print('结束')
    print('总计耗时间:',round(time.time()-starttime))
```

通过抛出异常来终止while循环,从而实现计时器功能.

