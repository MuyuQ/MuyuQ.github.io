{"meta":{"title":"Mcode","subtitle":null,"description":"简单，快乐","author":"Muyu","url":"http://mcode.tech","root":"/"},"pages":[{"title":"archive","date":"2020-10-07T11:20:38.000Z","updated":"2020-10-07T11:20:38.981Z","comments":true,"path":"archive/index.html","permalink":"http://mcode.tech/archive/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-10-07T11:25:04.000Z","updated":"2020-10-07T11:26:19.197Z","comments":true,"path":"categories/index.html","permalink":"http://mcode.tech/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-10-07T11:19:26.000Z","updated":"2020-10-07T12:08:03.933Z","comments":true,"path":"about/index.html","permalink":"http://mcode.tech/about/index.html","excerpt":"","text":"一个简单记录的地方"},{"title":"movies","date":"2020-10-07T11:55:55.000Z","updated":"2020-10-07T11:56:49.805Z","comments":true,"path":"movies/index.html","permalink":"http://mcode.tech/movies/index.html","excerpt":"","text":""},{"title":"link","date":"2020-10-07T11:21:47.000Z","updated":"2020-10-07T11:21:47.388Z","comments":true,"path":"link/index.html","permalink":"http://mcode.tech/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-07T11:21:40.000Z","updated":"2020-10-07T11:24:31.847Z","comments":true,"path":"tags/index.html","permalink":"http://mcode.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask中的请求钩子","slug":"请求钩子","date":"2020-11-05T04:16:04.020Z","updated":"2020-11-05T04:18:44.886Z","comments":true,"path":"2020/11/05/请求钩子/","link":"","permalink":"http://mcode.tech/2020/11/05/%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90/","excerpt":"","text":"所谓请求钩子,就是在客户端与服务器交互的过程中统一处理准备工作或者扫尾工作. APP层的请求钩子常见的请求钩子 before_first_request：在处理第一个请求前运行。 before_request：在每次请求前运行。 after_request：如果没有未处理的异常抛出，在每次请求后运行。 teardown_request：在每次请求后运行，即使有未处理的异常抛出。 12345678910111213141516171819202122232425262728293031323334353637383940from flask import Flask, url_for, redirectapp = Flask(__name__)@app.route(&#x27;/index&#x27;)def index(): a = 1 / 0 return &#x27;run index&#x27;@app.route(&#x27;/hello&#x27;)def hello(): return &#x27;hello&#x27;@app.before_first_requestdef b_f_r(): print(&#x27;before_first_request&#x27;)@app.before_requestdef b_r(): print(&#x27;before_request&#x27;)@app.route(&#x27;/handel_request&#x27;)def handel_request(): print(&#x27;处理请求&#x27;) print(&#x27;重定向到/h路径,测试404界面&#x27;) return redirect(&#x27;/h&#x27;)@app.after_requestdef a_r(response): print(&#x27;after_request&#x27;) return response@app.teardown_requestdef t_r(response): print(&#x27;teardown_request&#x27;) print(&#x27;======请求结束======&#x27;) return responseif __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;localhost&#x27;, port=5006) 输出如下 12345678910111213before_first_requestbefore_request处理请求重定向到/h路径,测试404界面after_requestteardown_request======请求结束======127.0.0.1 - - [05/Nov/2020 10:20:05] &quot;GET /handel_request HTTP/1.1&quot; 302 -127.0.0.1 - - [05/Nov/2020 10:20:05] &quot;GET /h HTTP/1.1&quot; 404 -before_requestafter_requestteardown_request======请求结束====== 值得注意的是after_request在Flask0.7版本以下会因为bug导致遇到未处理的异常时不会运行. 网上很多文章指出这个问题但没有标注版本. 这个bug在0.7版本中已经修复.isseu 下面是文档介绍: after_request(args*, *kwargs*) Register a function to be run after each request. Your function must take one parameter, a response_class object and return a new response object or the same (see process_response()). As of Flask 0.7 this function might not be executed at the end of the request in case an unhandled exception occurred. Note:可能是as of Flask 0.7 这里让大家理解出错. as of 既有截止的意思,也有从…时开始的意思. 通过在handel_request函数中加入4/0错误,发现after_request依旧正常执行,可以确认as of在这里是截止的意思. 既然after_request和teardown_request都是在请求结束后扫尾,那他们有什么不同呢? 根据文档可知: after_request必须传入一个response对象,必须返回一个response对象. atfer_request一般用来统一修改响应的内容，比如修改响应头. teardown_request需要传入一个参数记录异常,如果需要可以将这个异常返回. teardown_request一般用来施放程序占用的资源,比如释放数据库连接. 蓝图层的请求钩子和app层类似,蓝图层的常用钩子如下: before_app_request, after_app_request, teardown_app_request. Such a function is executed after each request, even if outside of the blueprint.","categories":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/tags/Flask/"}]},{"title":"数据库-定义关系","slug":"一对多","date":"2020-10-31T07:27:08.205Z","updated":"2020-10-31T07:27:08.205Z","comments":true,"path":"2020/10/31/一对多/","link":"","permalink":"http://mcode.tech/2020/10/31/%E4%B8%80%E5%AF%B9%E5%A4%9A/","excerpt":"","text":"一对多在”一”类中添加一个关系属性作为集合属性.当调用这个属性时返回所有相关的对象. 比如城市和国家模型. 1234567class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20),unique=True) class Nation(db.Model): id = db.Column(db.Integer, primary_key=True) Nation_name = db.Column(db.String(20),unique=True) 需要实现一个国家对应多个城市. 建立一对多关系第一步: 在”多”的一侧创建外键. 1class City(db.Model): nation_id = db.Column(db.Integer, db.ForeignKey(‘nation.id’)) #需要注意的是nation.id,表名是小写(因为SQLAlchemy生成的表默认为类名称的小写形式) 1234567第二步:在&quot;一&quot;的一侧定义关系属性.(集合关系属性,列表)&#96;&#96;&#96;pythonclass Nation(db.Model): cities = db.relationship(‘City’) 1234567891011121314当关系属性nation.cities被调用时,SQLAlchemy会找到&#96;city表&#96;的外键字段(nation_id).然后查询&#96;city表&#96;中nation_id为当前主键值(nation.id)的记录,返回包含这些记录的列表.**需要注意的是**,使用关系函数定义的集合关系属性不是数据库字段,而是一个查询函数. 所以返回值并不一定,而是根据函数返回值变化.关系函数有很多参数,在另外一篇文章里做总结吧.#### 建立关系1.直接通过外键字段赋值.&#96;&#96;&#96;pythoncity.nation_id &#x3D; 1db.session.commit() 2.通过关系属性添加 12nation.cities.append(Beijing)#Beijing为City对象 3.直接将一个对象列表赋值给关系属性 12nation.cities=[Beijing,Shenzheng]#Beijing和Shenzheng均为对象 建立双向关系虽然Nation.cities可以显示出cities列表,city却无法直接调用nation的记录.(虽然可以通过外键间接查询) 为了解决这个问题,引入了双向关系.","categories":[{"name":"SQL","slug":"SQL","permalink":"http://mcode.tech/categories/SQL/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/tags/Flask/"},{"name":"SQL","slug":"SQL","permalink":"http://mcode.tech/tags/SQL/"}]},{"title":"Flask中端点,蓝图,url相关","slug":"endpoint,蓝图","date":"2020-10-30T13:46:31.012Z","updated":"2020-10-30T14:13:17.192Z","comments":true,"path":"2020/10/30/endpoint,蓝图/","link":"","permalink":"http://mcode.tech/2020/10/30/endpoint,%E8%93%9D%E5%9B%BE/","excerpt":"","text":"端点(endpoint)端点(Endpoint)是URL规则(rule)和视图函数(view_func)的中间媒介. 123graph LRURL --&gt; EndpointEndpoint --&gt; view_func 比如 123456789@app.route(&#x27;/index&#x27;)def index(): return &#x27;hello,world&#x27;#等效于def index(): return &#x27;hello,world&#x27;app.add_url_rule(&#x27;/index&#x27;,&#x27;index&#x27;,index)#add_url_rule(rule,endpoint,view_func) 默认情况下,endpoint是view_cunc的名字. 也可以显式的更改端点名字. 12@app.route(&#x27;/&#x27;,endpoint=&#x27;index2&#x27;)def index(): 端点,view_functions,url_map在每个应用程序对象(app)中有两个属性和端点相关. 在view_functions中存储着`endpoint–view_func 键值对. 在url_map中存储着url和端点的映射关系. 以上两者均通过add_url_rule添加. 12345678910111213141516from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;index&#x27;@app.route(&#x27;/hello&#x27;)def hello(): return &#x27;hello&#x27;if __name__ == &#x27;__main__&#x27;: print(app.view_functions) print(&#x27;------------&#x27;) print(app.url_map) app.run(host=&#x27;localhost&#x27;,port=5004) 输出: 123456&#123;&#x27;static&#x27;: &lt;bound method _PackageBoundObject.send_static_file of &lt;Flask &#x27;test&#x27;&gt;&gt;, &#x27;index&#x27;: &lt;function index at 0x104db2310&gt;, &#x27;hello&#x27;: &lt;function hello at 0x105ae4160&gt;&#125;------------Map([&lt;Rule &#x27;/hello&#x27; (HEAD, GET, OPTIONS) -&gt; hello&gt;, &lt;Rule &#x27;/&#x27; (HEAD, GET, OPTIONS) -&gt; index&gt;, &lt;Rule &#x27;/static/&lt;filename&gt;&#x27; (HEAD, GET, OPTIONS) -&gt; static&gt;]) 所以当一个请求进入时,程序会先通过Rule找到endpoint.(url_map) ​ 然后根据endpoint找到view_func.(view_functions) 蓝图和端点当使用蓝图时,端点会变成&#39;蓝图名.视图函数名&#39;. 蓝图可以将一系列相关操作做成集合,实现模块化. 一般情况下,建议在蓝图对象后添加_bp后缀,方便识别. 蓝图搭配端点,才能解释为什么一定要引入端点,而不是直接映射url规则到视图函数. 蓝图搭配端点,可以实现蓝图的视图函数命名空间(namespace). 比如在蓝图author,蓝图post下都注册了一个index视图函数.当模板使用url_for(‘index’)获取URL时会产生冲突. 而url_for(&#39;author_bp.index&#39;)和url_for(&#39;post_bp.index&#39;)能有效避免冲突,解决视图函数的重名问题, 蓝图和url_prefix通过上面小节可以避免因为视图函数很聪明导致endpoint重名,从而出现冲突. 但是如果url也一样该怎么办呢? 比如author_bp和post_bp均注册了相同的url 12345678@author_bp.route(&#x27;/&#x27;)def index(): return &#x27;index&#x27;#在post_bp包里也存在相同的路由@post_bp.route(&#x27;/&#x27;)def index(): return &#x27;post&#x27; 如上所示,会出现url相同导致的冲突. 为了避免这种情况,需要在注册蓝图时填入url_prefix=’string’参数, 123app = Flask(__name__)app.register_blueprint(author_bp, url_prefix=&#x27;author&#x27;)app.register_blueprint(post_bp, url_prefix=&#x27;post&#x27;) 两者的url变成了 12/author//post/ 总结: 请求进入–&gt;url_map(Rule和endpoint的映射)–&gt;view_functions(endpoint和view_func的键值对)–&gt;视图函数. “蓝图.视图函数“的方式解决了视图函数重名问题,扩展了视图函数命名空间. 注册蓝图时填入url_prefix参数,解决了蓝图之间的url冲突问题. 推荐在命名蓝图时加入_bp后缀,方便识别.","categories":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/tags/Flask/"}]},{"title":"yield,yield from,async,asyncio之间的关系","slug":"协程是什么猫","date":"2020-10-20T17:26:13.489Z","updated":"2020-10-20T17:26:13.489Z","comments":true,"path":"2020/10/21/协程是什么猫/","link":"","permalink":"http://mcode.tech/2020/10/21/%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E7%8C%AB/","excerpt":"","text":"协程是什么猫?协程(coroutinr),微线程.一个线程执行. 进程是分配和管理资源的最小单位. 线程是分配和管理CPU的最小单位,和其他同属一个进程的线程共享所拥有的全部资源. 和多线程相比,协程的优势在于: 1.极高的执行效率.因为子程序切换由程序自身控制,不是线程切换.没有切换线程带来的开销. 线程数越多,协程性能优势比多线程更明显. 2.不需要多线程的锁机制,不存在同时写变量冲突,共享资源不加锁,判断状态就好了. 协程可以通过多进程+协程的方法你用多核CPU. yield可以实现协程当一个函数中存在yield时,这个函数就是一个生成器. yield的两个特点: 1.返回一个值,保存现场. 2.将调用者的参数传入生成器. 这使得yield实现的生成器具有中断等待的功能,从而实现协程. yield实现协程的例子123456789101112131415161718192021def consumer(): r = &#x27;&#x27; while True: n = yield r #初始化后,中断在yield r. 在15行使用send方法传入1后,yield=r=1=n. if not n: return print(&#x27;[消费者] 正在消费:&#123;0&#125;&#x27;.format(n))# n=1 r = &#x27;200 人民币&#x27; #r=&#x27;200人民币&#x27;,然后因为while循环,执行到第四行后,通过yield将r传出def produce(c): c.send(None) #启动消费者(生成器),进行初始化 n = 0 while n &lt; 5: n = n + 1 print(&#x27;[生产者] 正在生产:&#123;0&#125;&#x27;.format(n)) r = c.send(n) #调用send方法,将1传入consumer,同时接收传出的r=&#x27;200人民币&#x27; print(&#x27;[生产者] 消费者返回:&#123;0&#125;&#x27;.format(r)) print(&#x27;-------------------------------------------------&#x27;) c.close() c = consumer()#构造一个生成器produce(c) 协程的状态查看GEN_CREATED:等待执行, 还没有进入协程. GEN_RUNNING:解释器执行 GEN_SUSPENDED:阻塞状态,在yield处暂停 GEN_CLOSED:执行结束 可以通过inspect.getgeneratorstate()函数来确定. yield实现协程的不足每次只能向直接调用者返回一个值.导致无法分离到一个单独的函数中.复用性差. yield from Python3.3版本的PEP 380中添加了yield from语法，允许一个generator生成器将其部分操作委派给另一个生成器。其产生的主要动力在于使生成器能够很容易分为多个拥有send和throw方法的子生成器，像一个大函数可以分为多个子函数一样简单。Python的生成器是协程coroutine的一种形式，但它的局限性在于只能向它的直接调用者yield值。这意味着那些包含yield的代码不能想其他代码那样被分离出来放到一个单独的函数中。这也正是yield from要解决的。 虽然yield from主要设计用来向子生成器委派操作任务，但yield from可以向任意的迭代器委派操作； yield只能返回一个元素,而yield from 可以返回一个生成器. 在PEP 380 使用了一些yield from使用的专门术语： 委派生成器：包含 yield from 表达式的生成器函数； 子生成器：从 yield from 表达式中 部分获取的生成器； 调用方：调用委派生成器的客户端代码；即上面的main生成器函数 委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把结果直接发回给调用方。子生成器返回之后，解释器会抛出StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复 12yield from list #等效于 for item in list: yield item yield from所实现的数据传输通道","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"可迭代对象,迭代器,生成器","slug":"容器Container","date":"2020-10-20T06:12:36.136Z","updated":"2020-10-20T06:52:36.172Z","comments":true,"path":"2020/10/20/容器Container/","link":"","permalink":"http://mcode.tech/2020/10/20/%E5%AE%B9%E5%99%A8Container/","excerpt":"","text":"理一理可迭代对象,迭代器,生成器之间的联系. 容器Container1.容器是一个存储多个元素的数据结构. 2.容器中的元素可以通过迭代获取. 3.所有容器中的元素被存放在内存中. 4.常见的容器比如 list,tuple,dict,set,str.也都是可迭代对象(Iterable) 12345from collections import Iterablea = [&#x27;test&#x27;,&#x27;test2&#x27;]for i in a: #通过for循环迭代获取 print(i)isinstance(a,Iterable) #True 可迭代对象Iterable可以通过被迭代获取的对象. 内部定义了可返回迭代器的_iter_()方法. 比如: 123x = [1, 2, 3]for elem in x: print(elem) x列表是一个可迭代对象,在for循环中调用iter()方法变成迭代器,遍历x实际上是调用elem=next(x). 迭代器Iterator迭代器是一个带状态的对象,该状态用于记录当前迭代所在位置,以方便下次迭代的时候获取正确的元素. Iterator实现了__iter__和__next__方法. 迭代器不会一次性把所有的元素都加载到内存,而是在需要的时候才会生成返回结果. 1.可迭代对象!=迭代器. 2.迭代器带状态. 3.迭代器不会直接加载到内存. 生成器generator生成器是一种特殊的迭代器. 生成器可以传入数据进行计算,并根据变量内容计算结果后返回. 使用send方法传入数据. 生成器函数generator func含有yield关键字的函数就是生成器函数. 1234567891011121314151617def d(): print(&#x27;第一次调用&#x27;) sum = 0 value = yield sum #第一次c.send(None)只执行到 yield sum. 再次进入时执行 value = yield sum,将yield 赋值给sum,然后在赋值给value sum = value + sum print(&#x27;sum的值为:%d&#x27; %sum) print(&#x27;value%d&#x27; %value) #输出value1 value = yield sum # c.send(1)只执行到yield sum, 再次进入时执行 value = 2 print(&#x27;value%d&#x27; %value) #输出value2 yield sum c=d() #没有被调用,不会实例化.a = c.send(None) #执行2-4行, 返回sum,并赋值给a.print(&#x27;生成器传出的值为%d&#x27;%a)a = c.send(1) #传入数值1,通过yield传递给sum,value = sum ,继续执行4-8行a = c.send(2) #传入数值2,继续执行8-9行 可以看到,yield将sum的值传递给了调用方,将send()方法递进来的1传递给了value. 保存了迭代器的状态. 生成器表达式generator expression生成器表达式是列表生成式的生成器版本.返回一个生成器对象. 12345from collections import Iteratora = (x*x for x in range(10))print(isinstance(a,Iterator)) #Truefor x in a: print(x) 生成器的优势延迟加载:在处理长序列问题时,更加节省存储空间. 比如打印一个斐波那契数列,原始方法如下: 123456789def fab(max): n, a, b =0,0,1 L = [] while n&lt;max: L.append(b) a,b=b,a+b n+=1 return Lprint(fab(20)) 所有元素都存放在列表L里,空间开销较大. 使用生成器的方法如下: 12345678def fab(max): n, a, b =0,0,1 while n &lt; max: yield b # 每次在这里中断, 把b的值传递给i, 同时保存中断时的状态. a, b = b , a+b n+=1for i in fab(20): print(i) 这种方法不需要额外的列表空间开销. send()方法是交互的123456789def my_generator(n): for i in range(n): yield ig=my_generator(5)print(next(g)) #0print(next(g)) #1print(g.send(100))#2print(next(g)) #3print(next(g)) #4 可以看到第7行的g.send()方法输出了本来next()方法应该输出2. 1.send()的主要作用是当需要手动更改生成器里面的某一个值并且使用它，则发送进去一个数据保存到yield语句的返回值，以提供后续使用. 2.send()的返回值就是那个本来应该被迭代出来的那个值。这样既可以保证能够传入新的值，原来的值也不会弄丢. 总结 对象 特点 功能 iterable 实现了__iter__()方法 返回一个iterator iterator 实现了__iter__()和__next__()方法.数据需要时才会存储到内存中 逐个传出数据 generator yield替换了__next__()方法,可以中断,保存了状态的迭代器 逐个传入/传出数据 container 元素都存储在内存中元素可以通过迭代获取","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python 直接赋值、浅拷贝和深度拷贝解析","slug":"更多实例","date":"2020-10-19T13:35:25.070Z","updated":"2020-10-19T14:00:17.203Z","comments":true,"path":"2020/10/19/更多实例/","link":"","permalink":"http://mcode.tech/2020/10/19/%E6%9B%B4%E5%A4%9A%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"三种拷贝 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 1. b = a: 赋值引用，a 和 b 都指向同一个对象。 2. b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。 3. b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。 更多实例以下实例是使用 copy 模块的 copy.copy（ 浅拷贝 ）和（copy.deepcopy ）: 1234567891011121314151617#!/usr/bin/python# -*-coding:utf-8 -*- import copya = [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;]] #原始对象 b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象aa[4].append(&#x27;c&#x27;) #修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象 print( &#x27;a = &#x27;, a )print( &#x27;b = &#x27;, b )print( &#x27;c = &#x27;, c )print( &#x27;d = &#x27;, d ) 输出结果为 1234(&#x27;a = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5])(&#x27;b = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5])(&#x27;c = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]])(&#x27;d = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;]]) 查漏补缺为什么Python默认的拷贝方式是浅拷贝？ 时间角度：浅拷贝花费时间更少； 空间角度：浅拷贝花费内存更少； 效率角度：浅拷贝只拷贝顶层数据，一般情况下比深拷贝效率高。 本文知识点总结： 不可变对象在赋值时会开辟新空间； 可变对象在赋值时，修改一个的值，另一个也会发生改变； 深、浅拷贝对不可变对象拷贝时，不开辟新空间，相当于赋值操作； 浅拷贝在拷贝时，只拷贝第一层中的引用，如果元素是可变对象，并且被修改，那么拷贝的对象也会发生变化； 深拷贝在拷贝时会逐层进行拷贝，直到所有的引用都是不可变对象为止； Python中有多种方式实现浅拷贝，copy模块的copy函数、对象的copy函数、工厂方法、切片等； 大多数情况下，编写程序时都是使用浅拷贝，除非有特定的需求； 浅拷贝的优点：拷贝速度快，占用空间少，拷贝效率高。 转自: Python 直接赋值、浅拷贝和深度拷贝解析 Python 程序员如何防止数据被修改？","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"字典,默认值字典,有序字典","slug":"字典的常规用法","date":"2020-10-19T12:05:28.111Z","updated":"2020-10-19T12:35:22.764Z","comments":true,"path":"2020/10/19/字典的常规用法/","link":"","permalink":"http://mcode.tech/2020/10/19/%E5%AD%97%E5%85%B8%E7%9A%84%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95/","excerpt":"dict的常规用法,defaultdict和OrderDict的特点","text":"dict的常规用法,defaultdict和OrderDict的特点 字典的常规用法Python中字典的基础就是哈希表. 123456789101112131415161718192021222324252627282930313233# 字典的基本操作# 1.访问dic['key']dic.get('key')# 2.删除dic.pop['key']# 3.增加dic['key']= value# 4.遍历相关# 4.1 遍历keyfor key in dic.keys()# 4.2 遍历valuefor value in dic.values()# 4.3 遍历项for item in dic.items()# 4.4 遍历key和valuefor key, value in dic.items()# in判断'key' in dic'value' in dic.values()# 更新dic.update('key')# 浅拷贝, dic2 = dic.copy()# 设置默认值dic.setdefault(key,default=None)# setdefault方法虽然可以设置默认值,但一次只能设置一个key的默认value,# 更好的解决方案是defaultdictstrings = ('puppy', 'kitten', 'puppy', 'puppy', 'weasel', 'puppy', 'kitten', 'puppy')counts = &#123;&#125;for kw in strings: counts[kw] = counts.setdefault(kw, 0) + 1 字典合并 123456789a = &#123;'a':3, 'b':4&#125;b = &#123;'c':5&#125;# 用dict+关键字参数. 关键字参数是一个dictdict(a, **b)# 通过update字典实现.不过会导致覆盖问题a.update(b)# for in 循环for k, v in b.items(): a[k] = v 字典创建 123dict(one=1, two=2, three=3)dict(zip([list1],[list2]))dict(&#123;'one':1, 'three':3&#125;,two=2) 默认值字典因为某个key不在dict里,则会报错KeyError. defaultdict的作用在于,当字典里的key不存在但被查找时,不是返回KeyError,而是返回一个默认值. 12345678910111213141516from collections import defaultdicta = defaultdict(int)b = defaultdict(str)c = defaultdict(dict)d = defaultdict(set)print(a[0])print(b[1])print(c[2])print(d[3])==&gt;0&#123;&#125;set() 根据结果表明作用于所有位置的默认值. 1.使用list参数,将K-V对序列转换为列表字典. 123456from collections import defaultdicta = defaultdict(list)s = [('a',1), ('a',3), ('v',3)]for k, v in s: a[k].append(v)print(a) 输出 1defaultdict(&lt;class 'list'&gt;, &#123;'a': [1, 3], 'v': [3]&#125;) 2.使用int参数,用作计数器 123456from collections import defaultdicta = defaultdict(int)s = 'apple'for k in s: a[k]+=1print(a) 输出 1defaultdict(&lt;class 'int'&gt;, &#123;'a': 1, 'p': 2, 'l': 1, 'e': 1&#125;) 3.使用set参数,用作集合字典 12345678from collections import defaultdicts = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]d = defaultdict(set)for k, v in s: d[k].add(v)print('\\n',d)a=sorted(d.items())print('\\n',a) 输出 123defaultdict(&lt;class 'set'&gt;, &#123;'red': &#123;1, 3&#125;, 'blue': &#123;2, 4&#125;&#125;) [('blue', &#123;2, 4&#125;), ('red', &#123;1, 3&#125;)] 4.使用不带任何参数的可调用参数,到时返回该参数的返回结果作为默认值. 123456789from collections import defaultdictdef default_func(): return '默认值'df = defaultdict(default_func)print(df['32'])==&gt;默认值 这样就可以使用lambda函数来定义简单的函数 123456789from collections import defaultdictdf = defaultdict(lambda : 0)ds = defaultdict(lambda : 'apple')print(df['32'])print(ds['2'])==&gt;0apple 有序字典dict和defaultdict都是无序的,而orderdict是有序的. 在orderdict内部维护着一个根据键插入顺序排列的双向链表,每当有新元素插入时,会被放到链表的尾部. orderdict的大小是普通dict的两倍,所以需要权衡order和额外的内存消耗. 1234567891011from collections import OrderedDictd = OrderedDict()# move_to_endd.move_to_end('key')d.move_to_end('key', last = False)# 删除key_valued.popitem(last = True)# 排序-按照key排序sorted(d.items(), key=lambda i:i[0])# 排序-按照value排序sorted(d.items(), key=lambda i:i[1]) dict,defaultdict,OrderDict比较 dict defaultdict OrderDict 作用 d._copy_ √ 用于支持copy.copy d.default_factory √ 在__missing__函数中被调用的函数,泳衣给未找到的元素初始化 d._missing_ √ 当__getitem__找不到对应键的时候,该方法会被调用 d.move_to_end(k,last=True) √ 把键为k的元素移动到最后或最前 d._reversed_() √ 返回倒序的键的迭代器 d.popitem() √ √ √ dict和defaultdcit是随机移除,而OrderDict是移除最先插入的元素 理解 Python 语言中的 defaultdict-团子的小窝 三种字典的比较-biu嘟","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"哈希和字典","slug":"哈希冲突","date":"2020-10-19T07:01:30.458Z","updated":"2020-10-19T07:01:30.458Z","comments":true,"path":"2020/10/19/哈希冲突/","link":"","permalink":"http://mcode.tech/2020/10/19/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/","excerpt":"","text":"Python中的字典底层依靠哈希表实现,使用开放寻址法解决冲突. 哈希表是key-value类型的数据结构,一个键值需要按照一定规则存放.哈希函数就是这个规则. Python种要求1/3的数组是空的.增加元素可能会导致扩容,引发新的哈希冲突,导致新的哈希表种的键的次序发生变化,所以在字典遍历时不能添加和删除元素. 因为字典要求总有空白元素的数组,所以字典在内存中的开销很大,实际是以空间换时间. 哈希冲突因为数据是无限的,而提前准备的映射空间是有限的,所以总存在不同的数据经过哈希函数计算后的值相同,这就是哈希冲突. 哈希冲突的解决方法1.开放寻址法从发生冲突的那个单元开始,按照一定个规则,从哈希表中找到一个空闲的单元,把发生冲突的元素存入到该单元中. 比如:线性探查法,平方探查法,双散列函数探查法. 缺点在于 不能真正的删除元素,只能做特殊标记为删除.不然会导致索引出错.只有到下一个元素需要插入时进行覆盖. 比如 1,2,3,4 . 需要删除3,但是直接删除3会导致后续的索引错误. 只能在写入5时覆盖掉3. 1,2,5,4. 2.拉链法将相同哈希值的元素构成一个同义词链表,并将单链表的头指针存放在哈希表中. 增删改查主要是在同义词利链表中进行. 3.再哈希法使用多个不同的哈希函数,冲突时调用下一个哈希函数进行计算.会大量增加计算开销. 4.建立公共溢出区将哈希表分为公共表和溢出表,当溢出发生时将溢出数据放到溢出区. 242 Vaild Anagram-字母异位词1.直接对字符串快排,对比结果 12def isAnagram(slef, s, t): return sorted(s)==sorted(t) 2.使用hashmap. 1234567def isAnagram(self, s, t): dict1, dict2 = &#123;&#125;, &#123;&#125; for i in s: dict1[i]=dict1.get(i,0)+1 for i in t: dict2[i]=dict2.get(i,0)+1 return dict1 == dict1","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://mcode.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://mcode.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"char和varchar区别","slug":"DB/title char和varchar区别","date":"2020-10-14T09:24:40.925Z","updated":"2020-10-14T09:24:40.926Z","comments":true,"path":"2020/10/14/DB/title char和varchar区别/","link":"","permalink":"http://mcode.tech/2020/10/14/DB/title%20char%E5%92%8Cvarchar%E5%8C%BA%E5%88%AB/","excerpt":"","text":"char固定长度, varchar可变长度 如果实际存入数据长度小于指定长度,char会填充空格到指定长度,varhcar会缩短到实际长度. 如果实际存入数据长度大于指定长度,两者低版本会截取,高版本会报错 char效率比varchar高,但是相对而言费存储空间. 因为varchar会多一个字节记录长度.每次修改完数据后都会重新计算一次,导致效率变慢. char在内存和硬盘上都会按照最大的指定长度分配空间,而varchar在硬盘上会按照实际长度分配空间,在内存上按照指定长度分配空间.这导致两个问题 5.1 如果将varchar指定长度非常大,会导致内存占用很高,反而不利. 5.2 如果定义varchar(30),更改前字符长度为10,系统分配了10个存储单位.但更改后字符长度变为20,还在最大长度范围内,但是原存储位置无法满足其存储需求.系统需要进行额外的操作,比如拆分和分页. MyISAM表推荐使用char,缺点是占用磁盘 InnoDB表,推荐使用varchar. 如果存储的信息很短,那么推荐使用char, 因为varchar还有额外的开销. 如果是长度固定的数据,比如说uid,char更适合. 如果是频繁改动的column,推荐使用char,因为varchar每次都有额外的长度计算工作.","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/tags/MySQL/"}]},{"title":"Python中一些小知识点","slug":"Python/一些需要注意的地方","date":"2020-09-21T06:15:36.138Z","updated":"2020-10-08T09:56:38.453Z","comments":true,"path":"2020/09/21/Python/一些需要注意的地方/","link":"","permalink":"http://mcode.tech/2020/09/21/Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"一些需要注意的地方1.sqlalchemy中的filter(),filter_by()有什么区别123db.session.query.filter(Wish.launched == False)db.session.query.filter_by(uid=uid, launched=False)# 一个是关键字参数, 一个是条件表达式 2. 继承第三方库的某个类12345678910class Query(BaseQuery): def filter_by(self, **kwargs): # kwargs是字典 if 'status' not in kwargs.keys(): kwargs['status'] = 1 # 重写完成后,继承基类 return super(Query,self).filter_by(**kwargs)# 在SQLAlchemy中留了继承基类的接口 db = SQLAlchemy(query_class=Query) 3.链式调用触发sql严格模式(sql_mode)1234567@classmethod def recent(cls): # 链式调用 recent_gift = Gift.query.filter_by(launched=False).group_by( Gift.isbn).order_by(Gift.create_time).limit( current_app.config['RECENT_BOOK_COUNT']).distinct() return recent_gift 需要一下方法解锁严格模式. 1SET GLOBAL sql_mode&#x3D;(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;)); 4.原始数据–&gt;视图数据,需要通过视图模型(viewmodel)5.session.query查询123456789@classmethod def get_wish_count(cls, isbn_list): # 根据传入的一组isbn,到Wish表中检索出某个的礼物,并计算出某个礼物的心愿数量 # db.session # mysql in查询 db.session.query(func.count(Wish.id), Wish.isbn).filter( Wish.launched == False, Wish.isbn.in_(isbn_list), Wish.status == 1).group_by(Wish.isbn).all() 这种写法非常Python,要看多学多写. db.session.query(根据检索条件返回的数据) 6.避免循环导入当我们import一个文件时，python会首先去查找这个文件之前是否被import过，如果这个文件之前有被import过，就不会重新再import一次。所以如果A模块 代码里import了B模块，并且B模块里又import了A模块，python的执行顺序会变成这样：开始执行模块A当A执行到import B的地方，则停止执行A模块后面的代码，转而开始执行B模块的代码当B模块从头执行到import A的地方时，python此时并不会回过头去接着执行A剩余的代码，而且将A模块在中断前已经初始化的属性全加载到B模块中 1.在函数内部使用import,俗称 延迟导入.会影响性能. 12def func(): from time import sleep 2.将引起循环导入的变量放到导入模块import代码前. 12src.user = Nonefrom core import src 7.捕获KeyboardInterrupt异常运行命令行程序期间,如果用户想终止程序,一般都会才用ctrl-c来终止程序运行,程序会抛出KeyboardInterrupt异常. 可以通过这一机制来实现我们想要的功能. 123456789101112import timeprint('按下回车开始')try: input('') starttime = time.time() print('开始') while True: print('计时',round(time.time()-starttime)) time.sleep(1)except KeyboardInterrupt: print('结束') print('总计耗时间:',round(time.time()-starttime)) 通过抛出异常来终止while循环,从而实现计时器功能.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Flaks配置文件相关","slug":"Flaks配置文件相关","date":"2020-07-28T05:24:56.000Z","updated":"2020-07-28T05:34:43.499Z","comments":true,"path":"2020/07/28/Flaks配置文件相关/","link":"","permalink":"http://mcode.tech/2020/07/28/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/","excerpt":"","text":"Flask的配置文件实际上是字典的一个子类,且能够像字典一样被修改. 一般使用config.py文件进行配置管理. 12app = Flask(__name__)app.config.from_object('app.sercure') 当需要使用多个配置文件时,可以进行多次导入. 123app = Flask(__name__)app.config.from_object('app.sercure')app.config.from_object('app.setting') 也可以使用py文件保存配置 1app.config.from_pyfile('config.py') 有一种有趣的模式,可以为配置使用类和继承: 12345678910111213class Config(object): DEBUG = False TESTING = False DATABASE_URI = 'sqlite://:memory:'class ProductionConfig(Config): DATABASE_URI = 'mysql://user@localhost/foo'class DevelopmentConfig(Config): DEBUG = Trueclass TestingConfig(Config): TESTING = True 在调用时使用 1app.config.from_object('configmodule.ProductionConfig')","categories":[],"tags":[]},{"title":"MySQL语法基础","slug":"mysql语法基础","date":"2018-03-16T09:14:14.000Z","updated":"2020-10-07T12:04:24.117Z","comments":true,"path":"2018/03/16/mysql语法基础/","link":"","permalink":"http://mcode.tech/2018/03/16/mysql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"MySQL基础语法知识","text":"MySQL基础语法知识 mysql 的知识点 显示表结构 1desc + 表名; 或者 explain + 表名 语法基础创建数据库123CREATE DATABASE &#96;mydatabase&#96;;USE &#96;mydatabase&#96;;反引号并不是必须的, 但这是一种规范,防止在创建数据库或表的时候用到了 MySQL 的关键字. MySQL 关键字,最好全部用大写, 这是一种规范,最好遵守. mysql 权限分离, 对于一个数据库,最好建立一个只读账户,防止失误. mysql 中的注释 1--注释 建表语句1234CREATE TABLE &#96;student&#96;(&#96;id&#96; INT NOT NULL AUTO_INCREMENT &#96;name&#96; VARCHAR(200) NOT NULL); 常见类型 int char varchar datetime char 长度固定,存储速度快 Varchar 长度可变,节省空间 建表方案1234567CREATE TABLE &#96;students&#96;( &#96;id&#96; INT NOT NULL AUTO_INCREMENT, &#96;name&#96; VARCHAR(20) NOT NULL, &#96;nackname&#96; VARCHAR(20) NOT NULL, &#96;sex&#96; SMALLINT NOT NUll; &#96;in_time&#96; DATETIME NULL,); 1.必须设置一个主键 2.必须用, 而不是; 3.没有最后一行的, 4.需要设置默认的编码方式以支持中文. 正确版 1234567CREATE TABLE &#96;students&#96;( &#96;id&#96; INT NOT NULL AUTO_INCREMENT PRIMARY KEY, &#96;name&#96; VARCHAR(20) NOT NULL, &#96;nackname&#96; VARCHAR(20) NOT NULL, &#96;sex&#96; SMALLINT NOT NUll, &#96;in_time&#96; DATETIME NULL)DEFAULT CHARSET &#39;UTF8&#39;; 插入语句1INSERT INTO &#96;students&#96; VALUE(1,&#39;张三&#39;,&#39;三哥&#39;,&#39;男&#39;,now()); 序号自增长插入 指定需要插入的字段名 1INSERT INTO &#96;students&#96;(&#96;name&#96;,&#96;nickname&#96;,&#96;sex&#96;,&#96;in_time&#96;) VALUE(&#39;张三2&#39;,&#39;三哥2&#39;,&#39;男&#39;,now()); 如果有可以允许为空项,则可以放空. 1INSERT INTO &#96;students&#96;(&#96;name&#96;,&#96;nickname&#96;,&#96;sex&#96;) VALUE(&#39;张三3&#39;,&#39;三哥3&#39;,&#39;男&#39;); 插入多条 1234INSERT INTO &#96;students&#96;(&#96;name&#96;,&#96;nickname&#96;,&#96;sex&#96;) VALUES(&#39;张三4&#39;,&#39;三哥4&#39;,&#39;男&#39;),(&#39;张三5&#39;,&#39;三哥3&#39;,&#39;男&#39;),(&#39;张三6&#39;,&#39;三哥3&#39;,&#39;男&#39;); 插一条,用 VALUE, 插多条用 VALUES. 查询语句1SELECT &#96;name&#96;,&#96;nickname&#96; FROM &#96;students&#96; WHERE &#96;sex&#96;&#x3D;&#39;男&#39; ORDER BY &#96;id&#96; DESC LIMIT 1,2; 排序中有正序和倒序, 默认为正序ASC,倒序需要添加参数 DESC, 分页运用 LIMIT 0,2; 修改1UPDATE &#96;students&#96; SET &#96;nickname&#96;&#x3D;&#39;没有昵称&#39; WHERE &#96;sex&#96;&#x3D;&#39;女&#39; 删除1DELETE FROM &#96;students&#96; where &#96;sex&#96;&#x3D;&#39;男&#39;; 如果没有注明 where, 则会清空该表.","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/categories/MySQL/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://mcode.tech/tags/DB/"}]},{"title":"Nginx 进阶模块","slug":"Nginx 进阶","date":"2018-03-13T04:12:59.000Z","updated":"2018-03-13T04:13:29.000Z","comments":true,"path":"2018/03/13/Nginx 进阶/","link":"","permalink":"http://mcode.tech/2018/03/13/Nginx%20%E8%BF%9B%E9%98%B6/","excerpt":"简介","text":"简介 ##静态资源配置 配置语法- sendfile 123Syntax: sendfile on | off;Default: sendfile off;Context: server,location,if in location 配置语法- tcp-nopush 1234Syntax: tcp_nopush on | offDefault: tcp_push off;Context: http,server,location#在 sendfile 开启的情况下, 提高网络包的传递效率 不着急推送,而是将多个 tcp 打包进行集中发送,以提升效率.适合大文件 配置语法- tcp-nodelay 1234Syntax: tcp_nodelay on | offDefault: tcp_nodelay on;Context: http,server,location#在 keepalive 连接下,提高网络包的传递实时性 配置语法-压缩 1234#压缩等级设置Syntax: gzip_comp_level level;Default: gzip_comp_level 1;Context: http,server,location 扩展 Nginx 压缩模块 http_gzip_static_module-预读 gzip 功能. http_gunzip_module-应用支持 gunzip 的压缩功能. (很少用到) gzip 对文本的压缩很好,对图片的压缩一般. 12 浏览器缓存HTTP 协议定义的缓存机制(如 Expires,Cache-control等) 校验过期机制 校验是否过期 Expires(http1.0),Cache-Control(http1.1) (max-age定义一个周期) 如果 max-age 显示已经过期,则会检查后面两个校验 协议中 Etag头信息校验 Etag(保存一个字符串,来识别缓存,类似”别名”) Last-Modified 头信息校验 Last-Modified(保存一个时间,精确到秒,如果两个时间不一致,则服务器会传递一份新的) Max-age&lt;=0时,就要求每次请求都会要求服务器检查是否过期.即使服务器端设置了 max-age, 但是浏览器为了实时更新,会将 request里 max-age 设置为0. 静态资源配置场景设置 配置语法-expires location / { expires 24h; } 跨域访问为什么浏览器禁止跨域访问? 不安全,容易出现 CSRF 攻击. nginx 怎么做? 123Syntax: add_header name value [always];Default: - Context: http,server,location,if in location 如果服务器允许跨域访问,则浏览器不会禁止. 通过检查Access-Control-Allow-Origin 头来确定是否允许. 1234location ~ .*\\.(htm|html)$ &#123; add_header Access-Control-Allow-Origin http://www.qq.com; add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;&#125; 如果将 域名替换成*,则会对 CSRF 攻击完全开放. ##防盗链 简单防盗链实现. 防盗链设置思路. 首要方式:区别哪些请求是非正常的用户请求 基于 http_refer 防盗链配置模块 12345678# valid_referers表示允许哪些referer信息访问 #none表示允许没有带referer的信息过来 #blocked表示#ip 只允许这个ip的referer过来访问.valid_referers none blocked ip ;if($invalid_referer)&#123; return 403;&#125; ‘referer’是告诉服务器这个请求是从哪个页面链接过来的. 如果直接访问页面,则在 access.log 里面为 “-“. 进阶解决方案: 后期补充 代理服务正向代理 客户端—代理—|— 服务端 反向代理 客户端—|—代理—服务端 区别在于代理的对象不一样. 正向代理代理的对象是客户端. 反向代理代理的对象是服务端. 配置语法12345Syntax: proxy_pass URL;Default: -Context: location,if in location,limit_except#http://ip:80/url/ 服务器 A (10.211.55.15) 服务器 B(10.211.55.16) 服务器A, 12345location / &#123; if($http_x_forwarded_for !~*\"^10\\.211\\.55\\.16\")&#123; return 403; &#125;&#125; 这样设置后,所有不是来自服务器 B 的访问,都会被返回403. 服务器 B, 123location /&#123; proxy_pass $http_host$request_uri;&#125; 注意 uri 和 url 是不同的. uri 统一资源标志符, url 统一资源定位符. 一个用于解析,一个用于直接传递路径. 其他语法配置 proxy_buffering缓冲区 proxy_redirect跳转重定向 proxy_set_header 头信息 ,扩展 proxy_hide_header,proxy_set_body proxy_connect_timeout 超时 ,扩展 proxy_read_timeout,proxy_send_timeout proxy 常用配置1234567891011121314151617location / &#123;proxy_pass http://127.0.0.1:8080;proxy_redirect default;proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffer_size 32k;proxy_buffering on;proxy_buffers 4 128k;proxy_busy_buffers_size 256k;proxy_max_temp_file_size 256k;&#125; 如果有多个 proxy 方案,则可以使用 123location / &#123; include proxy_params;&#125; 然后把配置放在文件里.","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://mcode.tech/categories/Nginx/"}],"tags":[{"name":"server","slug":"server","permalink":"http://mcode.tech/tags/server/"}]},{"title":"Nginx基础&常用模块","slug":"Python/Nginx基础&常用模块","date":"2018-03-12T16:25:22.000Z","updated":"2018-03-12T16:25:47.000Z","comments":true,"path":"2018/03/13/Python/Nginx基础&常用模块/","link":"","permalink":"http://mcode.tech/2018/03/13/Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/","excerpt":"简介","text":"简介 1234567nginx -v #查看 nginx 编译参数nginx -V#检查 nginx 配置文件语法是否正确nginx -t -c /etc/nginx/nginx.conf #重新载入配置文件nginx -s reload Nginx 的中间件架构Nginx 是一个开源且高性能可靠的 HTTP 中间件,代理服务. ##为什么选择 Nginx? 原因1,IO 多路复用 epoll. IO 复用就是将多个 IO 流使用一个 socket 来传递. 原因2,轻量级 原因3,CPU 亲和(affinity) CPU 亲和是一种把 CPU 核心和 Nginx 工作进程绑定方式,把每个 worker 进程固定在一个 CPU 上执行,减少切换 CPU 的 cache miss, 获得更好的性能. 原因4,sendfile Nginx 目录讲解 路径 类型 作用 /etc/logrotate.d/nginx 配置文件 Nginx 日志轮转,用于 logrotate 服务的日志切割 / etc/nginx 目录,配置文件 Nginx 主配置文件 / etc/nginx/nginx.conf 主要配置文件 /etc/nginx/nginx/conf.d /etc/nginx/conf.d/default.conf 默认配置文件 /etc/nginx/fastcgi_params 配置文件 fastcgi 配置 /etc/nginx/uwsgi_params param(参数) /etc/nginx/scgi_params /etc/nginx/koi-utf 配置文件 编码转换映射转化文件 /etc/nginx/koi-win /etc/nginx/win-utf /etc/nginx/mime.types 配置文件 设置 http 协议的 Content-Type 与扩展名对应关系 /usr/lib/systemd/system/nginx-debug.service 配置文件 centos7中,用于配置出系统守护进程管理器管理方式 /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug 看/ etc/nginx/conf.d 看/ etc/nginx/nginx.conf HTTP请求request-包括请求行,请求头部,请求数据 response-包括状态行,消息报头,响应正文 Curl -CommandLine Uniform Resource Locator curl是利用URL语法在命令行方式下工作的开源文件传输工具. 通过编辑配置文件,可以更改 error.log和 access.log 的记录, 具体哪些参数可以添加,可以参考 Nginx.org 上面的文档. ###Nginx 变量 1.http请求变量 2.Nginx 内置变量 3.自定义变量 Nginx 模块讲解1nginx -t -c /etc/nginx/nginx.conf _stub_status_moule模块,显示 Nginx 当前处理链接的状态,用于监控 Nginx 当前连接的信息 需要在/etc/nginx/conf.d/default.conf添加 123location /mystatus &#123; stub_status;&#125; --with-http_random_index_modulegx_http_sub_modulesub_filter,sub_filter_last_modified,sub_filter_once,sub_filter_types替换 HTTP 页面 limit_conn_module连接频率限制limit_req_module请求频率限制HTTP协议的连接与请求 HTTP 协议版本 连接关系 HTTP1.0 TCP 不能复用 HTTP1.1 顺序性 TCP 复用 HTTP2.0 多路复用 TCP 复用 HTTP 请求建立在一次 TCP 连接基础上 一次 TCP 连接至少产生一次 HTTP 请求 1234ab -n 50 -c 20 http:&#x2F;&#x2F;www.qq.com-n 表示请求数为50 , -c 20是同时并发请求数ab 是 Apache 自带的压力测试工具,是一个很实用的测试工具. ###Nginx 访问控制 http_access_module基于 ip 的访问控制. 如果要写 12345location / &#123; allow all; deny 10.211.55.2;&#125;##需要注意 allow all的位置, 如果 allow all 在前面,则后面所有的 deny 都会无效. access_module的局限性:因为存在7lay LSB和 CDN 等,所以 remote_addr 不一定是需要进行限制的 ip 地址. 无法保证 remote_addr 的准确性 进阶方法 方案1.采用别的 HTTP 头信息控制访问, http_x_forwarded_for 1http_x_forwarded_for = Client IP, Proxy(1)IP,Proxy(2)IP... 但是 x_forwarded_for 只是一个协议,并没有强制要求对方遵守,故是可以被篡改的,安全性并不高. 方案2.结合 geo 模块 方案3.通过 HTTP 自定义变量传递 http_auth_basic_module基于用户的信任登录1234location &#x2F; &#123; auth_basic &#39;this is a test&#39;; auth_basic_user_file &#x2F;path;&#125; 可以使用 htpasswd来进行加密. 该工具集成在 httpd-tools 里面. 局限性 1.用户信息依赖文件方式 2.操作机械,效率低下 解决方案: 1.Nginx 结合 LUA 实现高效验证 2.Nginx 和 LDAP 大同,利用 Nginx-auth-ldap 模块.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"列表推导式","slug":"Python/列表推导式","date":"2018-03-09T04:57:13.000Z","updated":"2018-03-09T04:57:52.000Z","comments":true,"path":"2018/03/09/Python/列表推导式/","link":"","permalink":"http://mcode.tech/2018/03/09/Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/","excerpt":"Python 推导式","text":"Python 推导式 在数学中有一个集合推导式 用 map 函数123a = [1,2,3,4,5,6,7,8]r = list(map(lambda x : x*x*x,a))print(r) ##用列表推导式 123a = [1,2,3,4,5,6,7,8]b = [i**3 for i in a]print(b) 可以看到,列表推导式更为简洁. 如果有条件判断的话1​ 如果只选择大于等于5的部分​```a = [1,2,3,4,5,6,7,8]b = [i**3 for i in a if i &gt;=5]print(b) 123456789101112131415161718如果用 map 函数的话,还需要结合 filter 来过滤.__tips:__ _set ,字典和元组也可以_&#96;&#96;&#96;pythonstudents &#x3D; &#123; &#39;m&#39;:18, &#39;y&#39;:20, &#39;t&#39;:15&#125;b &#x3D; [key for key,value in students.items()]print(b)b &#x3D; &#123;value:key for key,value in students.items()&#125;print(b)","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python 进阶-数据结构与算法进阶训练 ","slug":"Python/Python进阶-数据结构与算法进阶训练","date":"2018-03-08T19:53:27.000Z","updated":"2020-10-07T12:43:22.812Z","comments":true,"path":"2018/03/09/Python/Python进阶-数据结构与算法进阶训练/","link":"","permalink":"http://mcode.tech/2018/03/09/Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/","excerpt":"训练数据筛选,排序,查找,统计,记录等方面的处理能力.","text":"训练数据筛选,排序,查找,统计,记录等方面的处理能力. 2.1如何在列表,字典,集合中根据条件筛选数据123456789101112131415161718192021from random import randinta = [1,2,3,4,5,-6,6,7,8,-2,-4]#用过滤器b = list(filter(lambda x:x&gt;0,a))print(b)#用列表推导式c = [i for i in a if i&gt;0 ]print(c)#字典推导式d = &#123;x:randint(60,100) for x in range(1,5)&#125;print(d)e = &#123; k:v for k,v in d.items() if v&gt;90&#125;print(e)#集合推导式f = set(a)g = (x for x in f if a%3==0)print(g) 用函数,或者用推导式来根据条件进行筛选. 推导式耗费的时间更少. 2.2如何为元组中的每个元素命名,提高程序可读性 实际案例,在学生信息系统中数据为固定格式:(名字,年龄,性别,邮箱…) 为了减少存储开销,对每个学生信息用元组表示: (‘Jim’,16,’male’,’dwad@qq.com’) 在访问时,就不可避免的需要使用 student[2]这种索引来访问,降低了程序的可读性. 方案1 定义类似于其他语言的枚举类型,即定义一系列数值常量. 123NAME = 1AGE = 2student[NAME] 方案2 使用标准库中 collections.nametuple 来给 tuple 内个位置命名 1234567from collections import namedtupleStudent = namedtuple('Student',['name','age','sex','email'])s = Student('Jim',16,'male','dwad@qe.com')print(s)print(s.name,s.email)#s是 tuple 的子类print(isinstance(s,tuple)) 开销仅仅比 tuple 大了一点,但可以精确定位元组内元素位置. 2.3如何统计序列中元素的出现频度 1.某随机序列[12,5,6,4,6,5,5,7….]中,找到出现次数最高的3个元素,它们出现次数是多少? 2.对某英文文章的单词,进行词频统计,找到出现次数最高的10个单词,它们出现次数是多少? 使用 collections.Counter . 将序列传入 Counter 的构造器,得到 Counter 对象是元素频度的字典. Counter.most_common(n)方法可以得到频度最高的 n 个元素的列表. 1234567from collections import Counterfrom random import randintdata = [randint(1,20) for x in range(1,20)]print(data)c = Counter(data)print(c)print(c.most_common(3)) 2.4如何根据字典中值得大小,对字典中的项排序 某班成绩以字典形式存储: {‘Li’:79,’Da’:31….} 根据成绩高低,计算学生排名. 使用内置函数 sorted. 1.利用 zip 将字典数据转化成元组 123456from random import randintd = &#123;x:randint(60,100) for x in 'zuadw'&#125;print(d)print(d.keys())print(d.values())print(sorted(zip(d.values(),d.keys()))) 在 Python2中还有 dict.itervalues 方法,但是在 Python3中已经删除了. zip 的作用是将两个序列,通过一定顺序组合成一个元组. 之后就可以使用 sorted()函数来对其进行排序. 2.传递 sorted 函数的 key 参数 12print(d.items())print(sorted(d.items(),key=lambda x: x[1])) 这里利用了3个知识点. 利用 d.items 的结构, 利用 sorted 的 key 参数来进行排序,利用匿名函数的特性. 2.5如何快速找到多个字典中的公共键(key)? 每轮球员进球统计: 第一轮:{‘苏亚雷斯’:1,’梅西’:2,’本泽马’:1,’C 罗’:3…} 第二轮:{‘苏亚雷斯’:2,’C 罗’:1,’格里兹曼’:2,’贝尔’:1….} …. 统计前 N 轮,每场比赛都有进球的球员. 解决方法: 利用集合(set)的交集操作 Step1:使用字典的 viewkeys()方法,得到一个字典 keys 的集合. Step2:使用 map 函数,得到所有字典的 keys 的集合. Step3:使用 reduce 函数,取得所有字典的 keys 的集合的交集. 123456789from random import randint,samplefrom functools import reduces1 = &#123;x:randint(1,4) for x in sample('abcdefg',randint(3,6))&#125;s2 = &#123;x:randint(1,4) for x in sample('abcdefg',randint(3,6))&#125;s3 = &#123;x:randint(1,4) for x in sample('abcdefg',randint(3,6))&#125;print(s1)print(s2)print(s3)print(reduce(lambda a,b:a&amp;b, map(dict.keys,[s1,s2,s3]))) 2.6如何让字典保持有序 选手完成题目后,吧该选手解题用时记录到字典中,以便赛后按选手名查询成绩, {‘Li’:(2,3)….} 比赛结束以后,需按排名顺序依次打印选手成绩,如何实现? 使用 collections.OrderdDict,即有序字典. 12345678from collections import OrderedDictd = OrderedDict()d['jim']=(1,35)d['leo']=(2,34)d['dw']=(2,53)for k in d: print(k)print(d) 不过直接使用 d={}来创建,发现顺序也是保持一致的. 这点需要进一步探究. 2.7如何实现用户的历史记录功能(最多 n 条)? 制作一个简单的猜数字小游戏,添加历史记录功能,显示用户最近猜过的数字,如何实现? 解决方案: 使用容量为 n 的队列存储历史记录. 使用标准库 collection 中的 deque, 它是一个双向队列.(先进先出) 程序退出前,可以使用 pickle 将队列对象存入文件,再次运行程序时将其导入. 12345678910111213141516from random import randintN = randint(0,100)def guess(k): if k == N: print('yes') return True if k &lt; N: print('less') else: print('more') return Falsewhile True: line = input('input a num:') if guess(int(line)): break 上面的代码实现了小游戏的功能,需要再进一步添加历史记录功能. 12345678910111213141516171819202122232425from random import randintfrom collections import dequehistory = deque([],5)N = randint(0,100)def guess(k): if k == N: print('yes') return True if k &lt; N: print('less') else: print('more') return Falsewhile True: line = input('input a num:') print(type(line)) if line.isdigit(): k = int(line) history.append(k) print(history) if guess(k): break elif line == 'h': print(list(history)) 需要注意的是, 1.str.isdigit()用来判断字符串是否为数字. 2.isinstance方法可以用来判断是否是统一类型. 3.raw_input 和 input,在 python3中已经统一成 input 了. 4.注意版本不同时 input 的返回类型不同.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"装饰器","slug":"Python/装饰器","date":"2018-03-08T15:18:49.000Z","updated":"2018-03-08T15:20:38.000Z","comments":true,"path":"2018/03/08/Python/装饰器/","link":"","permalink":"http://mcode.tech/2018/03/08/Python/%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"对装饰器的理解","text":"对装饰器的理解 装饰器实现的例子12345678910import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper@decoratordef f1(): print('This is a func') 使用装饰器的原因 对修改是封闭的,对扩展是开放的. 装饰器将核心业务代码和其他”装饰性”的代码进行分离,这样不仅提高了代码复用,而且也方便了代码管理. @就像是一个装饰一样,为函数增加了新的功能. 带有一个参数的装饰器12345678910import timedef decorator(func): def wrapper(func_name): print(time.time()) func() return wrapper@decoratordef f1(func_name): print('This is a func'+func_name) 不同数量参数的装饰器装饰器应具有通用性,所以不应被参数数量所限制,所以这里可以使用可变参数 *args. 12345678910111213141516import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decoratordef f1(func_name): print('This is a func'_func_name)@decoratordef f2(func_name1,func_name2): print('This is a func'+func_name1) print('This is a func'+func_name2)f1('func')f2('func1','func2') 加入了关键字参数时1234567891011121314151617181920212223import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decoratordef f1(func_name): print('This is a func'_func_name)@decoratordef f2(func_name1,func_name2): print('This is a func'+func_name1) print('This is a func'+func_name2)def f2(func_name1,func_name2,**kw): print('This is a func'+func_name1) print('This is a func'+func_name2) print(kw) f1('func')f2('func1','func2')f2('func1','func2',a = 1, b = 2,c = '123') 技巧总结通过* args(可变参数),**kw(关键字参数)来提升装饰器的通用性.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"None,布尔,空","slug":"Python/None,布尔,空","date":"2018-03-07T12:43:51.000Z","updated":"2018-03-07T12:55:35.000Z","comments":true,"path":"2018/03/07/Python/None,布尔,空/","link":"","permalink":"http://mcode.tech/2018/03/07/Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/","excerpt":"None,布尔,空的对应关系,还有对象和布尔的对应关系","text":"None,布尔,空的对应关系,还有对象和布尔的对应关系 None 的定义空就是空, 不等于空字符串,不等于空列表,不等于0,不等于 False 1234567891011121314151617a = 0b = ''c = []print(a==None)print(b==None)print(c==None)print(a is None)print(type(None))=&gt;FalseFalseFalseFalse&lt;class 'NoneType'&gt; __None 本身是一个对象,是一个类型__ 12345678910111213141516def fun(): return Nonea = fun()if not a: print('S')else: print('F')if a is None: print('S')else: print('F') =&gt;SS 12345678910111213141516def fun(): return Nonea =[]if not a: print('S')else: print('F')if a is None: print('S')else: print('F') =&gt;SF 体会上面两个例子. 可以看到 None 是一种类型,也是一个对象. not None=True,None是一个对象. a is None ,None是一个类型 用 None 作控制字符12345if a: passif not a: pass​ 这样,在 a = None,a = ‘’,a = [],a = False 时都可以起到控制作用​``` 123456789101112# None和布尔类型的区别&#96;&#96;&#96;pythonprint(type(None))print(type(False))print(type(True))&#x3D;&gt;&lt;class &#39;NoneType&#39;&gt;&lt;class &#39;bool&#39;&gt;&lt;class &#39;bool&#39;&gt; None表示不存在, False 和 True 表示真假 在 if控制中12if Noneif False 虽然得到的结果是相同的,但并不代表他们的意义是相同的. True 和 False 对应关系123''[]None 对应 Fasle 对象和布尔的关系但是对于自定义对象则可能会出现其他情况 123456789101112class Test(): passtest = Test()print(bool(None))print(bool([]))print(bool(test))=&gt;FalseFalseTrue 12345678910111213class Test(): def __len__(self): return 0test = Test()print(bool(None))print(bool([]))print(bool(test))=&gt;FalseFalseFalse 几乎所有对象中,对象存在对应着True, 但是对于自定义对象来说,则不一定. 这和自定义对象中两个内置函数相关. __len__和__bool__ __len__返回0: 123456789101112131415class Test(): #def __bool__(self): # print('bool called') # return False def __len__(self): print('len called') return 0print(len(Test()))print(bool(Test()))=&gt;len called0len calledFalse __len__返回非0: 123456789101112131415class Test(): #def __bool__(self): # print('bool called') # return False def __len__(self): print('len called') return 3print(len(Test()))print(bool(Test()))=&gt;len called3len calledTrue 所以,对于对象来说, bool(对象)是通过对__ len__ 函数的&quot;返回值&quot;进行判断来确定 True 和 False 的. 当存在__bool__函数时,则由__bool__函数接管: 123456789101112131415class Test(): def __bool__(self): print('bool called') return True def __len__(self): print('len called') return 0print(len(Test()))print(bool(Test()))=&gt;len called0bool calledTrue 当存在__bool__函数时, bool(Test())并没有调用__len__,而是直接调用了__bool__.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python爬虫问题, SSL 验证出错","slug":"Python/python爬虫问题, SSL验证问题","date":"2018-03-07T07:50:31.000Z","updated":"2018-03-07T07:53:58.000Z","comments":true,"path":"2018/03/07/Python/python爬虫问题, SSL验证问题/","link":"","permalink":"http://mcode.tech/2018/03/07/Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/","excerpt":"在使用 Python爬虫时,会遇到 urlopen 出错","text":"在使用 Python爬虫时,会遇到 urlopen 出错 #python爬虫问题, SSL验证问题 问题调试时报错 1urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed 原因Python 升级到2.7.9以后映入到一个新特性,当使用 urllib.urlopen 打开一个 https 链接时,会验证一次 SSL 证书. 当目标网站使用的而是一个自签名的证书时,就会抛出一个 1URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed 解决方案1.使用 ssl 创建未经验证的上下文,在 urlopen 中传入上下文参数 12345import sslimport urllib2context = ssl._create_unverified_context()print urllib2.urlopen(\"https://www.panda.tv/cate/lol\", context=context).read() 2.全局取消证书验证 123456import sslimport urllib2 ssl._create_default_https_context = ssl._create_unverified_context print urllib2.urlopen(\"https://www.panda.tv/cate/lol\").read() 因为爬虫并不担心安全性,故直接使用第二种方案.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"youtube-dl 下载","slug":"Mac/title: youtube下载","date":"2017-06-16T05:39:25.000Z","updated":"2017-06-19T02:25:50.000Z","comments":true,"path":"2017/06/16/Mac/title: youtube下载/","link":"","permalink":"http://mcode.tech/2017/06/16/Mac/title:%20youtube%E4%B8%8B%E8%BD%BD/","excerpt":"youtube 上有很多不错的视频,奈何超清画质不能下载,所以琢磨了琢磨 youtube-dl, 用来下载 youtube 的视频. 据说也可以下载优酷,土豆之类的.","text":"youtube 上有很多不错的视频,奈何超清画质不能下载,所以琢磨了琢磨 youtube-dl, 用来下载 youtube 的视频. 据说也可以下载优酷,土豆之类的. 使用 youtube-dl 进行下载, youtube-dl 自动调用 FFmpeg 进行音频和视频的合并. 在 zsh 内部写了别名, 所以直接在终端中使用 youtube +要下载视频的 URL, 就能下载到 影片文件夹. 默认下载分辨率最高的资源.","categories":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"}]},{"title":"琥珀的猫粮选定","slug":"杂/title: 琥珀的猫粮选定","date":"2017-06-13T05:32:25.000Z","updated":"2017-06-13T09:38:34.000Z","comments":true,"path":"2017/06/13/杂/title: 琥珀的猫粮选定/","link":"","permalink":"http://mcode.tech/2017/06/13/%E6%9D%82/title:%20%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/","excerpt":"小琥珀长大了,之前给他买的应急粮已经吃的差不多了,所以也该做做猫粮方面的而研究.","text":"小琥珀长大了,之前给他买的应急粮已经吃的差不多了,所以也该做做猫粮方面的而研究. 给琥珀选择食粮,找了很多资料. 首先得了解猫咪的身体需要: 1234567猫的营养要求非常特殊,不能只看原料成分选猫粮!猫自身不能合成的氨基酸:牛磺酸,精氨酸.猫自身不能合成:维生素 A, 维生素 B3,维生素 B6,维生素 D.还有 花生四烯酸. 其次,要对猫粮原材料了解: 选猫粮的时候,要注意成分,肉粉没有肉好,另外注意防腐剂, 买的时候注意看前三种原材料. 前三种都是肉,已经具有好粮的潜质了. 国内常见的品牌有: 下面的营养表并不稳定,因为各大宠物粮制造公司不停地调整配方. 渴望,传说中的”高富帅”猫粮, 没的说,有钱上.营养:粗蛋白(最小值) 35％，粗脂肪(最小值) 20％，粗纤维（最大）3％ GO!,加拿大的品牌,最近价格炒起来了, 性价比还是不错,各方面均为上品,还是蛮推荐的.营养:粗蛋白(最小值) 46％，粗脂肪(最小值) 18％，粗纤维(最大）1.5％ NOW 是传说中的”土豆饼干”,土豆味比较大,但吃起来并没有土豆味,配方很好,对猫猫的毛发和肠胃都很有帮助.营养:粗蛋白(最小值) 31％，脂肪(最小值) 18％，纤维（最大）3.5％ 雪山幼猫粮,价格适合,口味不错,搭配平衡,总的来说是很好的中阶猫粮,而且有官方旗舰店,并不担心断粮和假粮,品质有保障.==暂定为琥珀的猫粮了==.营养:粗蛋白（最小值）34％，粗脂肪（最小值）17％，粗纤维（最大）3％ 素力高,推荐金装素力高,性价比不错,营养表和原材料表也很好看.营养: 粗蛋白（最小值）40％，粗脂肪（最小值）18％，粗纤维（最大）3％ 安娜玛特,比较推荐的是他的红莓款,多种维生素的添加配上不错的营养表,但最近价格被炒起来了,性价比不高.营养:粗蛋白（最小值）33％，粗脂肪（最小值）15％，粗纤维（最大）3％ 美士,据说口碑很好很好,但尝过的人都认为口味一般,中庸便宜是他的特点.营养: 粗蛋白（最小值）36％，粗脂肪（最小值）19％，粗纤维（最大）4％ 牛油果,美国的品牌,还没接触过,据说增肥效果显著.营养: 粗蛋白（最小值）32％，粗脂肪（最小值）20％，粗纤维（最大）3％ EVO ,是玛氏的高阶品牌,有钱上,值得拥有.营养表和成分表都是很暴力的.营养:粗蛋白(最小值) 50%, 粗脂肪(最小值) 22%, 粗纤维(最大值) 2.5% 皇家猫粮油太大,另外有”诱食剂风波,”是玛氏的中阶品牌,不过在医院和猫舍的口碑还不错.如果预算不足,这个是很好的选择. 伟嘉是玛氏的低阶品牌,也可以说是垃圾粮,不推荐食用. 初步确定幼猫期吃专业幼猫粮,比如 雪山还有 Go! 长大了,可以考虑雪山,金装素力高和 Go!","categories":[{"name":"生活","slug":"生活","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/"},{"name":"猫","slug":"生活/猫","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/%E7%8C%AB/"}],"tags":[{"name":"猫","slug":"猫","permalink":"http://mcode.tech/tags/%E7%8C%AB/"}]},{"title":"GitHub也是有离线版的","slug":"杂/title: GitHub也是有离线版的","date":"2017-06-09T09:14:27.000Z","updated":"2017-06-13T09:46:01.000Z","comments":true,"path":"2017/06/09/杂/title: GitHub也是有离线版的/","link":"","permalink":"http://mcode.tech/2017/06/09/%E6%9D%82/title:%20GitHub%E4%B9%9F%E6%98%AF%E6%9C%89%E7%A6%BB%E7%BA%BF%E7%89%88%E7%9A%84/","excerpt":"","text":"因为伟大的 GFW 墙掉了 AWS, 所以GitHub的 Windows 版总是安装失败,所以去找了找是否有离线版安装包. 12在线版安装:https:&#x2F;&#x2F;github-windows.s3.amazonaws.com&#x2F;GitHubSetup.exe离线版安装:https:&#x2F;&#x2F;github-windows.s3.amazonaws.com&#x2F;standalone&#x2F;GitHubDesktop.exe 因为在安装过程中要保持联网,所以安装离线版安装包也有可能会失败,多试几次即可.","categories":[{"name":"App","slug":"App","permalink":"http://mcode.tech/categories/App/"}],"tags":[{"name":"App","slug":"App","permalink":"http://mcode.tech/tags/App/"}]},{"title":"Python 的生成器","slug":"Python/title: 生成器","date":"2017-05-24T07:42:53.000Z","updated":"2017-05-24T09:15:33.000Z","comments":true,"path":"2017/05/24/Python/title: 生成器/","link":"","permalink":"http://mcode.tech/2017/05/24/Python/title:%20%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"生成器可以动态的生成后续的元素, 是一种基于某种算法推算出来的, 因为在需要时才生成,故使用生成器可以节省大量的空间. 在 Python 中,这种一边循环一边计算的机制,称为生成器: generator.","text":"生成器可以动态的生成后续的元素, 是一种基于某种算法推算出来的, 因为在需要时才生成,故使用生成器可以节省大量的空间. 在 Python 中,这种一边循环一边计算的机制,称为生成器: generator. 创建 generator[]改()只要将一个列表生成式的[]改成(),就创建了一个 generator: 123456&gt;&gt;&gt;L=[x*x for x in range(10)]&gt;&gt;&gt;L[0,1,4,9,16,25,36,49,64,81]&gt;&gt;&gt;g=(x*x for x in range(10))&gt;&gt;&gt;g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; L 是 一个 list, g 是 一个 generator. 通过 next()函数,可以获得 generator 的下一个返回值. 即,按照设定的算法生成了后续序列 一般来说,是使用 for 循环来迭代 generator. 123&gt;&gt;&gt;g=(x*x for x in range(10))&gt;&gt;&gt;for n in g: print(n) yield有些函数也可以通过算法实现自增, 但是这种函数只是有了’自我生成算法‘,还缺少一个非常重要的标志’yield‘. yield 取代 return, 为函数返回值. 如果一个函数定义包含关键字 yield, 那么这个函数就不再是一个普通的函数,而是一个 generator. yield 与 return 的区别当一个生成器函数调用 yield, 生成器函数的’状态‘会被冻结,所有的变量的值会被保留下来,下一行要执行的代码的位置也会被记录,知道再次调用 next().一旦 next() 再次被调用,生成器函数会从它上次离开的地方开始. 总结 generator 是用来产生一系列的值的. yield 向 generator 函数返回结果 yield 唯一做的另一件事就是保存一个 generator 的状态 generator 是特殊类型的迭代器 可以通过 next()来获取 generator 的下一个值 可以通过隐私调用 next()来忽略某些值. 例子杨辉三角问题 每个数等于它上方两数之和。 每行数字左右对称，由1开始逐渐变大 下面是我的代码: 1234567891011121314151617181920212223def triangles(): if n==0: L2=[1] yield L2 if n==1: L2=[1,1] yield L2 while n&gt;1: L=L2.copy() i = 0 while i &lt; n-1: L2[i+1]=L[i]+L[i+1] i=i+1 L2.append(1) yield L2 n = 0for t in triangles(): print(t) n = n + 1 if n == 10: break 在代码中,还有一个值得注意的地方. L=L2是软复制,仅仅是指针指向. 如果不希望两个 list 之间的变动相互干扰,就需要使用 L.copy()方法来实现硬复制. 另外,我的代码表现出很浓的 C 风格. 以下是看到的其他同学的实践方法,值得学习: 123456def triangles(): L = [1] while True: yield L L.append(0) L = [L[i - 1] + L[i] for i in range(len(L))] 还有另一种写法: 12345678def triangles(): ret = [1] while True: yield ret for i in range(1, len(ret)): ret[i] = pre[i] + pre[i - 1] ret.append(1) pre = ret[:] ​","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"汉诺塔很有趣","slug":"C/title: 汉诺塔很有趣","date":"2017-05-24T01:30:26.000Z","updated":"2017-05-24T09:34:21.000Z","comments":true,"path":"2017/05/24/C/title: 汉诺塔很有趣/","link":"","permalink":"http://mcode.tech/2017/05/24/C/title:%20%E6%B1%89%E8%AF%BA%E5%A1%94%E5%BE%88%E6%9C%89%E8%B6%A3/","excerpt":"汉诺塔的规则很有趣,","text":"汉诺塔的规则很有趣, 汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘. 不过先把 B站上的一个视频搬上来吧. 简单来说, 只关注最底下的最大的盘子,一次递归.","categories":[{"name":"算法","slug":"算法","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"算法/Python","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/Python/"}],"tags":[{"name":"算法探索","slug":"算法探索","permalink":"http://mcode.tech/tags/%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/"}]},{"title":"Python函数的一些问题","slug":"Python/title: Python函数的一些问题","date":"2017-05-22T09:36:41.000Z","updated":"2017-05-23T09:10:51.000Z","comments":true,"path":"2017/05/22/Python/title: Python函数的一些问题/","link":"","permalink":"http://mcode.tech/2017/05/22/Python/title:%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"默认函数,可变函数等一些关于函数定义方面的问题.","text":"默认函数,可变函数等一些关于函数定义方面的问题. 默认参数默认参数定义1234567891011121314151617#先定义个函数def power(x): return x*x&gt;&gt;&gt;power(5)25#扩展这个函数def power(x,n): s = 1 while n &gt; 0: n = n - 1 s = s * n return s&gt;&gt;&gt;power(5,3)125 但是这时候再调用第一个函数,则会报错. 即,调用函数 power()缺少了一个位置参数 n. 这时候就需要使用默认参数了 1234567891011def power(x,n=2): s = 1 while n &gt; 0: n = n - 1 s = s * n return s#如果需要使用 n不等于2的情况,则需要明确传入 n 值.#必选参数在前,默认参数在后,否则可能会报错.#当函数有多个函数时,把变化比较大的参数放在前面,变化比较小的放后面.#变化小的参数可以作为默认参数,这样可以降低调用的难度以及优化代码 多个默认参数,有时按照顺序提供默认参数,有时可以不按顺序提供默认参数 1234#顺序enroll('Bo','M',7)#不按照顺序enroll('Ad','M',city='Tianjin') 默认参数坑12345678def add_end(L=[]): L.append('END') renturn L &gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 函数定义的是在某个列后加入一个 ‘END’, 但是函数好像每次都记住了上次添加了’ END’后的 list. 原因如下: Python函数在定义的时候,默认函数L的值就被确定了,因为 默认函数 L 也是一个变量,它指向对象[],每次调用该函数时,如果改变了 L 的内容,则下次调用时,默认参数的内容就发生了变化,不再是默认的定义. 故,需要特别注意!! 默认参数必须指向不变对象!! 12可变对象:list,dict,ser不变对象: str,None,tuple 可变参数可变参数是指传入的参数个数是可变的. list法123456789#可以通过传入一个 list 作为函数的参数,从而实现参数个数可变.def calc(numble): sum = 0 for n in numbers: sum = sum + n * n return sum#但是必须先填入一个 list 或 tuple&gt;&gt;&gt;calc([1,2,3])14 每次必须传入一个 list 或者 tuple, 太繁琐. ##加* 所以一般将函数的参数改为可变参数 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 在参数前加一个*号. 在内部流程中,参数 numbers 接收到的是一个tuple. 12&gt;&gt;&gt;calc(1,2)5 如果要传入一个 list 或 tuple, 则可以选择在 list 或 tuple 前加一个*号,把 list 或 tuple的元素变成可变参数传入: 123&gt;&gt;&gt;nums=[1,2,3]&gt;&gt;&gt;calc(*nums)14 关键字参数关键字参数的设置可变参数允许传入任意个数参数,自动组装成一个 tuple. 关键字参数允许传入任意个数含参数名的参数,自动组装成一个 dict. 12345def person(name,age,**kw): print(name,age,kw)&gt;&gt;&gt;person('Bo',5,city='Beijing')Bo,5,other:&#123;'city':'Beijing'&#125; 在 person 函数里,我们能保证收到两个必须参数name和age,如果调用者需要提供更多信息,我们也可以收到这些信息,而且这些信息可以是任意的. 也可以先做一个 dict 来存储这些额外的信息, 12345&gt;&gt;&gt;extra=&#123;'city':'Beijing','job':'Engineer','location':'changping'&#125;##可以对个别 key 值调用&gt;&gt;&gt;person('Ja',24,city=extra['city'])##也可以一次性全部调用&gt;&gt;&gt;person('Ja',23,**extra) * extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 *\\ kw 参数, kw 获得一个 dict, 这里并不是指针改变,而是拷贝,所以 kw 的后续改动并不会影响到函数外的 extra. 命名关键字参数关键字参数检查因为在传入时并没有规定参数的格式,所以传入的信息会比较杂乱, 有时希望检查某些参数是否输入: 123456def person(name,age,**kw): if 'city' in kw: pass if 'job' in kw: pass print('name:',name,'age:',age,'other:',kw) 但传入的信息还是很杂乱, 关键字参数限制有时希望限制关键字参数的名字: 12def person(name,age,*,city,job): print(name,age,city,job) *后面的参数都将被视为命名关键字参数. 如果有了一个可变参数,则可变参数后面的参数默认为命名关键字参数 12def person(name,age,*args,city,job): print(name,age,args,city,job) 关键字参数的一些问题 命名关键字参数必须传入参数名. (因为它本质上是一个 dict, 与 key有关,与位置无关) 命名关键字可以设置缺省值 1def person(name,age,*,city='Beijing',job): 注意区分位置参数和命名关键字参数,命名关键字参数实质是传入了一个 dict, 与位置无关. 参数组合参数顺序参数定义是一定要按照以下顺序 必选参数,默认参数,可变参数,命名关键字参数,关键字参数 比如 123def f1(a,b,c=0,*args,**kw):def f2(a,b,c=0,*,d,**kw): 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125; 通过list,tuple 和 dict 传入12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 总结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})。 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python 一些数据类型辨析","slug":"Python/title: 4种数据结构对比","date":"2017-05-22T07:37:47.000Z","updated":"2018-03-07T12:45:25.000Z","comments":true,"path":"2017/05/22/Python/title: 4种数据结构对比/","link":"","permalink":"http://mcode.tech/2017/05/22/Python/title:%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/","excerpt":"list,tuple,dict,set 四种数据类型的定义和异同.","text":"list,tuple,dict,set 四种数据类型的定义和异同. listlist 是一种有序的集合,可以随时添加和删除其中的元素. 123456789101112131415161718#声明 classmates = ['Mi','Bo','Tr'] #长度 len(classmates) #索引 classmates[0] ##倒数第一个索引 classmates[-1] #追加 classmates.append('Ad') #插入 classmates.insert(1,'Ja') #删除末尾 classmates.pop() ##删除指定位置 classmates.pop(1) ##list的元素可以为其他的数据结构 L=['Ad',123,['ad','ds']] tupletuple是不可修改的 list.一旦初始化后,就不能修改. 因为不可修改,所以代码更为安全. 123456#声明classmates = ('Mi','Bo','Tr')#因为括号()既可以表示 tuple, 又可以表示数学公式中的小括号.#故 Python 规定.只有1个元素的tuple 定义时必须加一个**,**,来消除歧义t=(1)t=(1,) 另外,因为特殊的结构,还存在一种”可变”的tuple. 12#\"可变\"的 tuplet = (\"Ad\",123,['sad','asda']) 因为, tuple 内含的 list 是可变的,而 tuple 本身的指向和结构并没有发生改变. dictdict即为 dictionary, 在其他语言中也称为 map. 使用键-值(key-value)存储,查找速度极快. 12#声明d = &#123;'Mi':95,'Bo':85,'Tr':75&#125; dict 和 list 查找速度对比list: 把字典从第一页向后翻,直到查找到. 所以 list 中查找元素, list 越大,查找越慢 dict: 给定一个 key 值,来计算出 value 的存放位置. 比如” Mi”,dict 在内部进行计算出 Mi对应存放 value 的”页码”,即可直接取出 value. 123456789#初始化后赋值d['Mi']=97#Key 不存在会报错##判断 key 是否存在'Mi'in d##通过 get 方法,如果 key 不存在,返回指定 valued.get('Mi',-1)#删除一个 keyd.pop('Bo') dict 是一种空间换时间的方法. dict 的 key 值是不可变对象 因为 key 值决定了 value 的存储位置,如果 key 值变化,则整个 dict 就陷入了混乱. list 是可变的,故 list 不能为 key. setset 是无序无重复的元素集合 创建一个 set, 需要提供一个 list 作为输入集合 12345678910111213141516#声明&gt;&gt;&gt;s = set([1,2,3,3])#重复元素会被自动过滤&gt;&gt;&gt;s&#123;1,2,3&#125;#添加元素s.add(4)#删除元素s.remove(3)#可以做 交集,并集等操作&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 小结list是有序可变,中括号 1list = ['ad',123,False] tuple 是有序不可变,小括号 1tuple = ('ada',1231,list,['dsa','dasda']) dict 是无序, key-value ,中括号 1dict = &#123;'Ad':96,'Mi':97&#125; set 是无序,无重复,set(list) 1s = set(['ads','dasd',123])","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"MySQL导出时 add-drop-table 问题","slug":"DB/title: Mysql","date":"2017-05-22T02:22:49.000Z","updated":"2017-05-23T05:01:29.000Z","comments":true,"path":"2017/05/22/DB/title: Mysql/","link":"","permalink":"http://mcode.tech/2017/05/22/DB/title:%20Mysql/","excerpt":"在使用 mysqldump 导出数据库某表后,直接使用 导入该 sql 文件,该表内的元数据会被删除.","text":"在使用 mysqldump 导出数据库某表后,直接使用 导入该 sql 文件,该表内的元数据会被删除. 原来是通过 mysqldump工具导出时,默认情况下会在 create 语句前加 add-drop-table, 导致每个导出文件内都有 droptable 命令. 所以需要在导出时加入 –skip-add-drop-table 参数,这样就可以在导入时避免删除掉原有数据.","categories":[{"name":"DB","slug":"DB","permalink":"http://mcode.tech/categories/DB/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/tags/MySQL/"}]},{"title":"Mac 的一些技巧","slug":"Mac/title: Mac 的一些小技巧","date":"2017-05-16T09:25:28.000Z","updated":"2017-05-23T05:03:37.000Z","comments":true,"path":"2017/05/16/Mac/title: Mac 的一些小技巧/","link":"","permalink":"http://mcode.tech/2017/05/16/Mac/title:%20Mac%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"在使用 Mac 过程中的一些小技巧和快捷键.","text":"在使用 Mac 过程中的一些小技巧和快捷键. 通过Command+点击在新窗口中打开Finder侧边栏上的项目 Command+鼠标拖拽可以移动后方的窗口，同时不影响前端窗口 Command+点击Dock上的图标可以打开应用在Finder中的位置 Command+回车Spotlight中的搜索结果可以直接在Finder中查看 Command+回车Spotlight中的搜索结果可以直接在Finder中查看","categories":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"}]},{"title":"Markdown 语法和 MWeb 写作使用说明","slug":"Markdown 语法和 MWeb 写作使用说明","date":"2017-04-12T05:51:12.000Z","updated":"2017-05-17T06:50:04.000Z","comments":true,"path":"2017/04/12/Markdown 语法和 MWeb 写作使用说明/","link":"","permalink":"http://mcode.tech/2017/04/12/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。","text":"Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 &#96;&lt;h1&gt;&#96; ## 第二级标题 &#96;&lt;h2&gt;&#96; ###### 第六级标题 &#96;&lt;h6&gt;&#96; 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成&#96;&lt;em&gt;&#96;*_这些文字会生成&#96;&lt;u&gt;&#96;_**这些文字会生成&#96;&lt;strong&gt;&#96;**__这些文字会生成&#96;&lt;strong&gt;&#96;__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 &#96;* + 空格键&#96;* 项目二* 项目二的子项目一 无序列表 &#96;TAB + * + 空格键&#96;* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 &#96;数字 + . + 空格键&#96;2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 &#96;TAB + 数字 + . + 空格键&#96;2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96; 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http:&#x2F;&#x2F;zh.mweb.im&#x2F;asset&#x2F;img&#x2F;set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http:&#x2F;&#x2F;github.com)自动生成连接 &lt;http:&#x2F;&#x2F;www.github.com&#x2F;&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：&#96;&lt;addr&gt;&#96; &#96;code&#96; CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125;CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 12345********- - - 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x &#x3D; \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; &#x3D;1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) &#x3D; (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","categories":[],"tags":[]},{"title":"test","slug":"数据挖掘—将数据转换成知识","date":"2017-03-13T00:37:19.000Z","updated":"2017-05-15T07:13:16.000Z","comments":true,"path":"2017/03/13/数据挖掘—将数据转换成知识/","link":"","permalink":"http://mcode.tech/2017/03/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/","excerpt":"","text":"数据 未处理的。 知识 已经经过处理和分析。 模式 信息 含义广泛，包含未处理和已处理。 数据挖掘—将数据转换成知识KDD（knowledge discovery form data）知识发现 等同于数据挖掘 在各个行业，对数据挖掘的认识不同，因为他们所受的教育和氛围以及基础知识，让他们在细微地方不同。 数据挖掘特点 数据真实 数据海量 决策者的随机查询 挖掘出来的知识一般不能预知，是潜在的新颖知识 数据挖掘的功能 6类 概念描述 concept description 关联关系（Association） 分类和预测（） ​ 分类—离散的数据 预测—l连续的数据 聚类分析（cluster analysis） 异常分析 趋势和演化分析（Trend and evolution analysis） 判断发现模式是否有趣（interesting）分为主观和客观两个方面。 数据挖掘框架 Techniques Applications Principles (imp) 数据挖掘的分类数据挖掘算法的组件化思想 （IMP）五个标准组件 模型和模式结构 数据挖掘任务 评分函数 搜索和优化方法 效果 数据管理策略 效率 模型是全局的，模式是局部的。两者相互联系。 当面对一个新的应用时，数据挖掘人员应该从组件的角度，根据应用需求，考虑应该选取哪些组件，来组成一个新的算法，而不是考虑哪个现成的算法。","categories":[{"name":"Diary","slug":"Diary","permalink":"http://mcode.tech/categories/Diary/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"http://mcode.tech/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://mcode.tech/tags/Games/"}]}],"categories":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/categories/Flask/"},{"name":"SQL","slug":"SQL","permalink":"http://mcode.tech/categories/SQL/"},{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://mcode.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/categories/MySQL/"},{"name":"Nginx","slug":"Nginx","permalink":"http://mcode.tech/categories/Nginx/"},{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"},{"name":"生活","slug":"生活","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/"},{"name":"猫","slug":"生活/猫","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/%E7%8C%AB/"},{"name":"App","slug":"App","permalink":"http://mcode.tech/categories/App/"},{"name":"算法","slug":"算法","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"算法/Python","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/Python/"},{"name":"DB","slug":"DB","permalink":"http://mcode.tech/categories/DB/"},{"name":"Diary","slug":"Diary","permalink":"http://mcode.tech/categories/Diary/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://mcode.tech/tags/Flask/"},{"name":"SQL","slug":"SQL","permalink":"http://mcode.tech/tags/SQL/"},{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://mcode.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://mcode.tech/tags/DB/"},{"name":"server","slug":"server","permalink":"http://mcode.tech/tags/server/"},{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"},{"name":"猫","slug":"猫","permalink":"http://mcode.tech/tags/%E7%8C%AB/"},{"name":"App","slug":"App","permalink":"http://mcode.tech/tags/App/"},{"name":"算法探索","slug":"算法探索","permalink":"http://mcode.tech/tags/%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/"},{"name":"PS3","slug":"PS3","permalink":"http://mcode.tech/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://mcode.tech/tags/Games/"}]}