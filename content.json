{"meta":{"title":"Mcode","subtitle":null,"description":"简单，快乐","author":"Muyu","url":"http://mcode.tech","root":"/"},"pages":[{"title":"about","date":"2017-10-20T08:50:25.000Z","updated":"2017-10-20T08:50:57.000Z","comments":false,"path":"about/index.html","permalink":"http://mcode.tech/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-20T08:38:20.000Z","updated":"2017-10-20T08:50:07.000Z","comments":false,"path":"categories/index.html","permalink":"http://mcode.tech/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-20T08:38:36.000Z","updated":"2017-10-20T08:49:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://mcode.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-07-21T06:05:55.794Z","updated":"2020-07-21T06:05:55.794Z","comments":true,"path":"2020/07/21/hello-world/","link":"","permalink":"http://mcode.tech/2020/07/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"MySQL语法基础","slug":"mysql语法基础","date":"2018-03-16T09:14:14.000Z","updated":"2018-03-16T09:17:02.000Z","comments":true,"path":"2018/03/16/mysql语法基础/","link":"","permalink":"http://mcode.tech/2018/03/16/mysql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"MySQL基础语法知识","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/categories/MySQL/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://mcode.tech/tags/DB/"}]},{"title":"Nginx 进阶模块","slug":"Nginx 进阶","date":"2018-03-13T04:12:59.000Z","updated":"2018-03-13T04:13:29.000Z","comments":true,"path":"2018/03/13/Nginx 进阶/","link":"","permalink":"http://mcode.tech/2018/03/13/Nginx%20%E8%BF%9B%E9%98%B6/","excerpt":"简介","text":"简介 ##静态资源配置 配置语法- sendfile 123Syntax: sendfile on | off;Default: sendfile off;Context: server,location,if in location 配置语法- tcp-nopush 1234Syntax: tcp_nopush on | offDefault: tcp_push off;Context: http,server,location#在 sendfile 开启的情况下, 提高网络包的传递效率 不着急推送,而是将多个 tcp 打包进行集中发送,以提升效率.适合大文件 配置语法- tcp-nodelay 1234Syntax: tcp_nodelay on | offDefault: tcp_nodelay on;Context: http,server,location#在 keepalive 连接下,提高网络包的传递实时性 配置语法-压缩 1234#压缩等级设置Syntax: gzip_comp_level level;Default: gzip_comp_level 1;Context: http,server,location 扩展 Nginx 压缩模块 http_gzip_static_module-预读 gzip 功能. http_gunzip_module-应用支持 gunzip 的压缩功能. (很少用到) gzip 对文本的压缩很好,对图片的压缩一般. 12 浏览器缓存HTTP 协议定义的缓存机制(如 Expires,Cache-control等) 校验过期机制 校验是否过期 Expires(http1.0),Cache-Control(http1.1) (max-age定义一个周期) 如果 max-age 显示已经过期,则会检查后面两个校验 协议中 Etag头信息校验 Etag(保存一个字符串,来识别缓存,类似”别名”) Last-Modified 头信息校验 Last-Modified(保存一个时间,精确到秒,如果两个时间不一致,则服务器会传递一份新的) Max-age&lt;=0时,就要求每次请求都会要求服务器检查是否过期.即使服务器端设置了 max-age, 但是浏览器为了实时更新,会将 request里 max-age 设置为0. 静态资源配置场景设置 配置语法-expires location / { expires 24h; } 跨域访问为什么浏览器禁止跨域访问? 不安全,容易出现 CSRF 攻击. nginx 怎么做? 123Syntax: add_header name value [always];Default: - Context: http,server,location,if in location 如果服务器允许跨域访问,则浏览器不会禁止. 通过检查Access-Control-Allow-Origin 头来确定是否允许. 1234location ~ .*\\.(htm|html)$ &#123; add_header Access-Control-Allow-Origin http://www.qq.com; add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;&#125; 如果将 域名替换成*,则会对 CSRF 攻击完全开放. ##防盗链 简单防盗链实现. 防盗链设置思路. 首要方式:区别哪些请求是非正常的用户请求 基于 http_refer 防盗链配置模块 12345678# valid_referers表示允许哪些referer信息访问 #none表示允许没有带referer的信息过来 #blocked表示#ip 只允许这个ip的referer过来访问.valid_referers none blocked ip ;if($invalid_referer)&#123; return 403;&#125; ‘referer’是告诉服务器这个请求是从哪个页面链接过来的. 如果直接访问页面,则在 access.log 里面为 “-“. 进阶解决方案: 后期补充 代理服务正向代理 客户端—代理—|— 服务端 反向代理 客户端—|—代理—服务端 区别在于代理的对象不一样. 正向代理代理的对象是客户端. 反向代理代理的对象是服务端. 配置语法12345Syntax: proxy_pass URL;Default: -Context: location,if in location,limit_except#http://ip:80/url/ 服务器 A (10.211.55.15) 服务器 B(10.211.55.16) 服务器A, 12345location / &#123; if($http_x_forwarded_for !~*\"^10\\.211\\.55\\.16\")&#123; return 403; &#125;&#125; 这样设置后,所有不是来自服务器 B 的访问,都会被返回403. 服务器 B, 123location /&#123; proxy_pass $http_host$request_uri;&#125; 注意 uri 和 url 是不同的. uri 统一资源标志符, url 统一资源定位符. 一个用于解析,一个用于直接传递路径. 其他语法配置 proxy_buffering缓冲区 proxy_redirect跳转重定向 proxy_set_header 头信息 ,扩展 proxy_hide_header,proxy_set_body proxy_connect_timeout 超时 ,扩展 proxy_read_timeout,proxy_send_timeout proxy 常用配置1234567891011121314151617location / &#123;proxy_pass http://127.0.0.1:8080;proxy_redirect default;proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffer_size 32k;proxy_buffering on;proxy_buffers 4 128k;proxy_busy_buffers_size 256k;proxy_max_temp_file_size 256k;&#125; 如果有多个 proxy 方案,则可以使用 123location / &#123; include proxy_params;&#125; 然后把配置放在文件里.","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://mcode.tech/categories/Nginx/"}],"tags":[{"name":"server","slug":"server","permalink":"http://mcode.tech/tags/server/"}]},{"title":"Nginx基础&常用模块","slug":"Python/Nginx基础&常用模块","date":"2018-03-12T16:25:22.000Z","updated":"2018-03-12T16:25:47.000Z","comments":true,"path":"2018/03/13/Python/Nginx基础&常用模块/","link":"","permalink":"http://mcode.tech/2018/03/13/Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/","excerpt":"简介","text":"简介 1234567nginx -v #查看 nginx 编译参数nginx -V#检查 nginx 配置文件语法是否正确nginx -t -c /etc/nginx/nginx.conf #重新载入配置文件nginx -s reload Nginx 的中间件架构Nginx 是一个开源且高性能可靠的 HTTP 中间件,代理服务. ##为什么选择 Nginx? 原因1,IO 多路复用 epoll. IO 复用就是将多个 IO 流使用一个 socket 来传递. 原因2,轻量级 原因3,CPU 亲和(affinity) CPU 亲和是一种把 CPU 核心和 Nginx 工作进程绑定方式,把每个 worker 进程固定在一个 CPU 上执行,减少切换 CPU 的 cache miss, 获得更好的性能. 原因4,sendfile Nginx 目录讲解 路径 类型 作用 /etc/logrotate.d/nginx 配置文件 Nginx 日志轮转,用于 logrotate 服务的日志切割 / etc/nginx 目录,配置文件 Nginx 主配置文件 / etc/nginx/nginx.conf 主要配置文件 /etc/nginx/nginx/conf.d /etc/nginx/conf.d/default.conf 默认配置文件 /etc/nginx/fastcgi_params 配置文件 fastcgi 配置 /etc/nginx/uwsgi_params param(参数) /etc/nginx/scgi_params /etc/nginx/koi-utf 配置文件 编码转换映射转化文件 /etc/nginx/koi-win /etc/nginx/win-utf /etc/nginx/mime.types 配置文件 设置 http 协议的 Content-Type 与扩展名对应关系 /usr/lib/systemd/system/nginx-debug.service 配置文件 centos7中,用于配置出系统守护进程管理器管理方式 /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug 看/ etc/nginx/conf.d 看/ etc/nginx/nginx.conf HTTP请求request-包括请求行,请求头部,请求数据 response-包括状态行,消息报头,响应正文 Curl -CommandLine Uniform Resource Locator curl是利用URL语法在命令行方式下工作的开源文件传输工具. 通过编辑配置文件,可以更改 error.log和 access.log 的记录, 具体哪些参数可以添加,可以参考 Nginx.org 上面的文档. ###Nginx 变量 1.http请求变量 2.Nginx 内置变量 3.自定义变量 Nginx 模块讲解1nginx -t -c /etc/nginx/nginx.conf _stub_status_moule模块,显示 Nginx 当前处理链接的状态,用于监控 Nginx 当前连接的信息 需要在/etc/nginx/conf.d/default.conf添加 123location /mystatus &#123; stub_status;&#125; --with-http_random_index_modulegx_http_sub_modulesub_filter,sub_filter_last_modified,sub_filter_once,sub_filter_types替换 HTTP 页面 limit_conn_module连接频率限制limit_req_module请求频率限制HTTP协议的连接与请求 HTTP 协议版本 连接关系 HTTP1.0 TCP 不能复用 HTTP1.1 顺序性 TCP 复用 HTTP2.0 多路复用 TCP 复用 HTTP 请求建立在一次 TCP 连接基础上 一次 TCP 连接至少产生一次 HTTP 请求 1234ab -n 50 -c 20 http:&#x2F;&#x2F;www.qq.com-n 表示请求数为50 , -c 20是同时并发请求数ab 是 Apache 自带的压力测试工具,是一个很实用的测试工具. ###Nginx 访问控制 http_access_module基于 ip 的访问控制. 如果要写 12345location / &#123; allow all; deny 10.211.55.2;&#125;##需要注意 allow all的位置, 如果 allow all 在前面,则后面所有的 deny 都会无效. access_module的局限性:因为存在7lay LSB和 CDN 等,所以 remote_addr 不一定是需要进行限制的 ip 地址. 无法保证 remote_addr 的准确性 进阶方法 方案1.采用别的 HTTP 头信息控制访问, http_x_forwarded_for 1http_x_forwarded_for = Client IP, Proxy(1)IP,Proxy(2)IP... 但是 x_forwarded_for 只是一个协议,并没有强制要求对方遵守,故是可以被篡改的,安全性并不高. 方案2.结合 geo 模块 方案3.通过 HTTP 自定义变量传递 http_auth_basic_module基于用户的信任登录1234location &#x2F; &#123; auth_basic &#39;this is a test&#39;; auth_basic_user_file &#x2F;path;&#125; 可以使用 htpasswd来进行加密. 该工具集成在 httpd-tools 里面. 局限性 1.用户信息依赖文件方式 2.操作机械,效率低下 解决方案: 1.Nginx 结合 LUA 实现高效验证 2.Nginx 和 LDAP 大同,利用 Nginx-auth-ldap 模块.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"列表推导式","slug":"Python/列表推导式","date":"2018-03-09T04:57:13.000Z","updated":"2018-03-09T04:57:52.000Z","comments":true,"path":"2018/03/09/Python/列表推导式/","link":"","permalink":"http://mcode.tech/2018/03/09/Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/","excerpt":"Python 推导式","text":"Python 推导式 在数学中有一个集合推导式 用 map 函数123a = [1,2,3,4,5,6,7,8]r = list(map(lambda x : x*x*x,a))print(r) ##用列表推导式 123a = [1,2,3,4,5,6,7,8]b = [i**3 for i in a]print(b) 可以看到,列表推导式更为简洁. 如果有条件判断的话1​ 如果只选择大于等于5的部分​```a = [1,2,3,4,5,6,7,8]b = [i**3 for i in a if i &gt;=5]print(b) 123456789101112131415161718如果用 map 函数的话,还需要结合 filter 来过滤.__tips:__ _set ,字典和元组也可以_&#96;&#96;&#96;pythonstudents &#x3D; &#123; &#39;m&#39;:18, &#39;y&#39;:20, &#39;t&#39;:15&#125;b &#x3D; [key for key,value in students.items()]print(b)b &#x3D; &#123;value:key for key,value in students.items()&#125;print(b)","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python 进阶-数据结构与算法进阶训练 ","slug":"Python/Python进阶-数据结构与算法进阶训练","date":"2018-03-08T19:53:27.000Z","updated":"2018-03-09T04:54:41.000Z","comments":true,"path":"2018/03/09/Python/Python进阶-数据结构与算法进阶训练/","link":"","permalink":"http://mcode.tech/2018/03/09/Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/","excerpt":"训练数据筛选,排序,查找,统计,记录等方面的处理能力.","text":"训练数据筛选,排序,查找,统计,记录等方面的处理能力. 2.1如何在列表,字典,集合中根据条件筛选数据123456789101112131415161718192021from random import randinta = [1,2,3,4,5,-6,6,7,8,-2,-4]#用过滤器b = list(filter(lambda x:x&gt;0,a))print(b)#用列表推导式c = [i for i in a if i&gt;0 ]print(c)#字典推导式d = &#123;x:randint(60,100) for x in range(1,5)&#125;print(d)e = &#123; k:v for k,v in d.items() if v&gt;90&#125;print(e)#集合推导式f = set(a)g = (x for x in f if a%3==0)print(g) 用函数,或者用推导式来根据条件进行筛选. 推导式耗费的时间更少. 2.2如何为元组中的每个元素命名,提高程序可读性 实际案例,在学生信息系统中数据为固定格式:(名字,年龄,性别,邮箱…) 为了减少存储开销,对每个学生信息用元组表示: (‘Jim’,16,’male’,’dwad@qq.com’) 在访问时,就不可避免的需要使用 student[2]这种索引来访问,降低了程序的可读性. 方案1 定义类似于其他语言的枚举类型,即定义一系列数值常量. 123NAME = 1AGE = 2student[NAME] 方案2 使用标准库中 collections.nametuple 来给 tuple 内个位置命名 1234567from collections import namedtupleStudent = namedtuple('Student',['name','age','sex','email'])s = Student('Jim',16,'male','dwad@qe.com')print(s)print(s.name,s.email)#s是 tuple 的子类print(isinstance(s,tuple)) 开销仅仅比 tuple 大了一点,但可以精确定位元组内元素位置. 2.3如何统计序列中元素的出现频度 1.某随机序列[12,5,6,4,6,5,5,7….]中,找到出现次数最高的3个元素,它们出现次数是多少? 2.对某英文文章的单词,进行词频统计,找到出现次数最高的10个单词,它们出现次数是多少? 使用 collections.Counter . 将序列传入 Counter 的构造器,得到 Counter 对象是元素频度的字典. Counter.most_common(n)方法可以得到频度最高的 n 个元素的列表. 1234567from collections import Counterfrom random import randintdata = [randint(1,20) for x in range(1,20)]print(data)c = Counter(data)print(c)print(c.most_common(3)) 2.4如何根据字典中值得大小,对字典中的项排序 某班成绩以字典形式存储: {‘Li’:79,’Da’:31….} 根据成绩高低,计算学生排名. 使用内置函数 sorted. 1.利用 zip 将字典数据转化成元组 123456from random import randintd = &#123;x:randint(60,100) for x in 'zuadw'&#125;print(d)print(d.keys())print(d.values())print(sorted(zip(d.values(),d.keys()))) 在 Python2中还有 dict.itervalues 方法,但是在 Python3中已经删除了. zip 的作用是将两个序列,通过一定顺序组合成一个元组. 之后就可以使用 sorted()函数来对其进行排序. 2.传递 sorted 函数的 key 参数 12print(d.items())print(sorted(d.items(),key=lambda x: x[1])) 这里利用了3个知识点. 利用 d.items 的结构, 利用 sorted 的 key 参数来进行排序,利用匿名函数的特性. 2.5如何快速找到多个字典中的公共键(key)? 每轮球员进球统计: 第一轮:{‘苏亚雷斯’:1,’梅西’:2,’本泽马’:1,’C 罗’:3…} 第二轮:{‘苏亚雷斯’:2,’C 罗’:1,’格里兹曼’:2,’贝尔’:1….} …. 统计前 N 轮,每场比赛都有进球的球员. 解决方法: 利用集合(set)的交集操作 Step1:使用字典的 viewkeys()方法,得到一个字典 keys 的集合. Step2:使用 map 函数,得到所有字典的 keys 的集合. Step3:使用 reduce 函数,取得所有字典的 keys 的集合的交集. 123456789from random import randint,samplefrom functools import reduces1 = &#123;x:randint(1,4) for x in sample('abcdefg',randint(3,6))&#125;s2 = &#123;x:randint(1,4) for x in sample('abcdefg',randint(3,6))&#125;s3 = &#123;x:randint(1,4) for x in sample('abcdefg',randint(3,6))&#125;print(s1)print(s2)print(s3)print(reduce(lambda a,b:a&amp;b, map(dict.keys,[s1,s2,s3]))) 2.6如何让字典保持有序 选手完成题目后,吧该选手解题用时记录到字典中,以便赛后按选手名查询成绩, {‘Li’:(2,3)….} 比赛结束以后,需按排名顺序依次打印选手成绩,如何实现? 使用 collections.OrderdDict,即有序字典. 12345678from collections import OrderedDictd = OrderedDict()d['jim']=(1,35)d['leo']=(2,34)d['dw']=(2,53)for k in d: print(k)print(d) 不过直接使用 d={}来创建,发现顺序也是保持一致的. 这点需要进一步探究. 2.7如何实现用户的历史记录功能(最多 n 条)? 制作一个简单的猜数字小游戏,添加历史记录功能,显示用户最近猜过的数字,如何实现? 解决方案: 使用容量为 n 的队列存储历史记录. 使用标准库 collection 中的 deque, 它是一个双向队列.(先进先出) 程序退出前,可以使用 pickle 将队列对象存入文件,再次运行程序时将其导入. 12345678910111213141516from random import randintN = randint(0,100)def guess(k): if k == N: print('yes') return True if k &lt; N: print('less') else: print('more') return Falsewhile True: line = input('input a num:') if guess(int(line)): break 上面的代码实现了小游戏的功能,需要再进一步添加历史记录功能. 12345678910111213141516171819202122232425from random import randintfrom collections import dequehistory = deque([],5)N = randint(0,100)def guess(k): if k == N: print('yes') return True if k &lt; N: print('less') else: print('more') return Falsewhile True: line = input('input a num:') print(type(line)) if line.isdigit(): k = int(line) history.append(k) print(history) if guess(k): break elif line == 'h': print(list(history)) 需要注意的是, 1.str.isdigit()用来判断字符串是否为数字. 2.isinstance方法可以用来判断是否是统一类型. 3.raw_input 和 input,在 python3中已经统一成 input 了. 4.注意版本不同时 input 的返回类型不同.","categories":[{"name":"Python  ","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"装饰器","slug":"Python/装饰器","date":"2018-03-08T15:18:49.000Z","updated":"2018-03-08T15:20:38.000Z","comments":true,"path":"2018/03/08/Python/装饰器/","link":"","permalink":"http://mcode.tech/2018/03/08/Python/%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"对装饰器的理解","text":"对装饰器的理解 装饰器实现的例子12345678910import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper@decoratordef f1(): print('This is a func') 使用装饰器的原因 对修改是封闭的,对扩展是开放的. 装饰器将核心业务代码和其他”装饰性”的代码进行分离,这样不仅提高了代码复用,而且也方便了代码管理. @就像是一个装饰一样,为函数增加了新的功能. 带有一个参数的装饰器12345678910import timedef decorator(func): def wrapper(func_name): print(time.time()) func() return wrapper@decoratordef f1(func_name): print('This is a func'+func_name) 不同数量参数的装饰器装饰器应具有通用性,所以不应被参数数量所限制,所以这里可以使用可变参数 *args. 12345678910111213141516import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decoratordef f1(func_name): print('This is a func'_func_name)@decoratordef f2(func_name1,func_name2): print('This is a func'+func_name1) print('This is a func'+func_name2)f1('func')f2('func1','func2') 加入了关键字参数时1234567891011121314151617181920212223import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decoratordef f1(func_name): print('This is a func'_func_name)@decoratordef f2(func_name1,func_name2): print('This is a func'+func_name1) print('This is a func'+func_name2)def f2(func_name1,func_name2,**kw): print('This is a func'+func_name1) print('This is a func'+func_name2) print(kw) f1('func')f2('func1','func2')f2('func1','func2',a = 1, b = 2,c = '123') 技巧总结通过* args(可变参数),**kw(关键字参数)来提升装饰器的通用性.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"None,布尔,空","slug":"Python/None,布尔,空","date":"2018-03-07T12:43:51.000Z","updated":"2018-03-07T12:55:35.000Z","comments":true,"path":"2018/03/07/Python/None,布尔,空/","link":"","permalink":"http://mcode.tech/2018/03/07/Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/","excerpt":"None,布尔,空的对应关系,还有对象和布尔的对应关系","text":"None,布尔,空的对应关系,还有对象和布尔的对应关系 None 的定义空就是空, 不等于空字符串,不等于空列表,不等于0,不等于 False 1234567891011121314151617a = 0b = ''c = []print(a==None)print(b==None)print(c==None)print(a is None)print(type(None))=&gt;FalseFalseFalseFalse&lt;class 'NoneType'&gt; __None 本身是一个对象,是一个类型__ 12345678910111213141516def fun(): return Nonea = fun()if not a: print('S')else: print('F')if a is None: print('S')else: print('F') =&gt;SS 12345678910111213141516def fun(): return Nonea =[]if not a: print('S')else: print('F')if a is None: print('S')else: print('F') =&gt;SF 体会上面两个例子. 可以看到 None 是一种类型,也是一个对象. not None=True,None是一个对象. a is None ,None是一个类型 用 None 作控制字符12345if a: passif not a: pass​ 这样,在 a = None,a = ‘’,a = [],a = False 时都可以起到控制作用​``` 123456789101112# None和布尔类型的区别&#96;&#96;&#96;pythonprint(type(None))print(type(False))print(type(True))&#x3D;&gt;&lt;class &#39;NoneType&#39;&gt;&lt;class &#39;bool&#39;&gt;&lt;class &#39;bool&#39;&gt; None表示不存在, False 和 True 表示真假 在 if控制中12if Noneif False 虽然得到的结果是相同的,但并不代表他们的意义是相同的. True 和 False 对应关系123''[]None 对应 Fasle 对象和布尔的关系但是对于自定义对象则可能会出现其他情况 123456789101112class Test(): passtest = Test()print(bool(None))print(bool([]))print(bool(test))=&gt;FalseFalseTrue 12345678910111213class Test(): def __len__(self): return 0test = Test()print(bool(None))print(bool([]))print(bool(test))=&gt;FalseFalseFalse 几乎所有对象中,对象存在对应着True, 但是对于自定义对象来说,则不一定. 这和自定义对象中两个内置函数相关. __len__和__bool__ __len__返回0: 123456789101112131415class Test(): #def __bool__(self): # print('bool called') # return False def __len__(self): print('len called') return 0print(len(Test()))print(bool(Test()))=&gt;len called0len calledFalse __len__返回非0: 123456789101112131415class Test(): #def __bool__(self): # print('bool called') # return False def __len__(self): print('len called') return 3print(len(Test()))print(bool(Test()))=&gt;len called3len calledTrue 所以,对于对象来说, bool(对象)是通过对__ len__ 函数的&quot;返回值&quot;进行判断来确定 True 和 False 的. 当存在__bool__函数时,则由__bool__函数接管: 123456789101112131415class Test(): def __bool__(self): print('bool called') return True def __len__(self): print('len called') return 0print(len(Test()))print(bool(Test()))=&gt;len called0bool calledTrue 当存在__bool__函数时, bool(Test())并没有调用__len__,而是直接调用了__bool__.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python爬虫问题, SSL 验证出错","slug":"Python/python爬虫问题, SSL验证问题","date":"2018-03-07T07:50:31.000Z","updated":"2018-03-07T07:53:58.000Z","comments":true,"path":"2018/03/07/Python/python爬虫问题, SSL验证问题/","link":"","permalink":"http://mcode.tech/2018/03/07/Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/","excerpt":"在使用 Python爬虫时,会遇到 urlopen 出错","text":"在使用 Python爬虫时,会遇到 urlopen 出错 #python爬虫问题, SSL验证问题 问题调试时报错 1urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed 原因Python 升级到2.7.9以后映入到一个新特性,当使用 urllib.urlopen 打开一个 https 链接时,会验证一次 SSL 证书. 当目标网站使用的而是一个自签名的证书时,就会抛出一个 1URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed 解决方案1.使用 ssl 创建未经验证的上下文,在 urlopen 中传入上下文参数 12345import sslimport urllib2context = ssl._create_unverified_context()print urllib2.urlopen(\"https://www.panda.tv/cate/lol\", context=context).read() 2.全局取消证书验证 123456import sslimport urllib2 ssl._create_default_https_context = ssl._create_unverified_context print urllib2.urlopen(\"https://www.panda.tv/cate/lol\").read() 因为爬虫并不担心安全性,故直接使用第二种方案.","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"正则学习笔记","slug":"Python/2018-01-04","date":"2018-01-04T08:39:01.000Z","updated":"2018-03-07T07:48:11.000Z","comments":true,"path":"2018/01/04/Python/2018-01-04/","link":"","permalink":"http://mcode.tech/2018/01/04/Python/2018-01-04/","excerpt":"","text":"","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"youtube-dl 下载","slug":"Mac/title: youtube下载","date":"2017-06-16T05:39:25.000Z","updated":"2017-06-19T02:25:50.000Z","comments":true,"path":"2017/06/16/Mac/title: youtube下载/","link":"","permalink":"http://mcode.tech/2017/06/16/Mac/title:%20youtube%E4%B8%8B%E8%BD%BD/","excerpt":"youtube 上有很多不错的视频,奈何超清画质不能下载,所以琢磨了琢磨 youtube-dl, 用来下载 youtube 的视频. 据说也可以下载优酷,土豆之类的.","text":"youtube 上有很多不错的视频,奈何超清画质不能下载,所以琢磨了琢磨 youtube-dl, 用来下载 youtube 的视频. 据说也可以下载优酷,土豆之类的. 使用 youtube-dl 进行下载, youtube-dl 自动调用 FFmpeg 进行音频和视频的合并. 在 zsh 内部写了别名, 所以直接在终端中使用 youtube +要下载视频的 URL, 就能下载到 影片文件夹. 默认下载分辨率最高的资源.","categories":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"}]},{"title":"琥珀的猫粮选定","slug":"杂/title: 琥珀的猫粮选定","date":"2017-06-13T05:32:25.000Z","updated":"2017-06-13T09:38:34.000Z","comments":true,"path":"2017/06/13/杂/title: 琥珀的猫粮选定/","link":"","permalink":"http://mcode.tech/2017/06/13/%E6%9D%82/title:%20%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/","excerpt":"小琥珀长大了,之前给他买的应急粮已经吃的差不多了,所以也该做做猫粮方面的而研究.","text":"小琥珀长大了,之前给他买的应急粮已经吃的差不多了,所以也该做做猫粮方面的而研究. 给琥珀选择食粮,找了很多资料. 首先得了解猫咪的身体需要: 1234567猫的营养要求非常特殊,不能只看原料成分选猫粮!猫自身不能合成的氨基酸:牛磺酸,精氨酸.猫自身不能合成:维生素 A, 维生素 B3,维生素 B6,维生素 D.还有 花生四烯酸. 其次,要对猫粮原材料了解: 选猫粮的时候,要注意成分,肉粉没有肉好,另外注意防腐剂, 买的时候注意看前三种原材料. 前三种都是肉,已经具有好粮的潜质了. 国内常见的品牌有: 下面的营养表并不稳定,因为各大宠物粮制造公司不停地调整配方. 渴望,传说中的”高富帅”猫粮, 没的说,有钱上.营养:粗蛋白(最小值) 35％，粗脂肪(最小值) 20％，粗纤维（最大）3％ GO!,加拿大的品牌,最近价格炒起来了, 性价比还是不错,各方面均为上品,还是蛮推荐的.营养:粗蛋白(最小值) 46％，粗脂肪(最小值) 18％，粗纤维(最大）1.5％ NOW 是传说中的”土豆饼干”,土豆味比较大,但吃起来并没有土豆味,配方很好,对猫猫的毛发和肠胃都很有帮助.营养:粗蛋白(最小值) 31％，脂肪(最小值) 18％，纤维（最大）3.5％ 雪山幼猫粮,价格适合,口味不错,搭配平衡,总的来说是很好的中阶猫粮,而且有官方旗舰店,并不担心断粮和假粮,品质有保障.==暂定为琥珀的猫粮了==.营养:粗蛋白（最小值）34％，粗脂肪（最小值）17％，粗纤维（最大）3％ 素力高,推荐金装素力高,性价比不错,营养表和原材料表也很好看.营养: 粗蛋白（最小值）40％，粗脂肪（最小值）18％，粗纤维（最大）3％ 安娜玛特,比较推荐的是他的红莓款,多种维生素的添加配上不错的营养表,但最近价格被炒起来了,性价比不高.营养:粗蛋白（最小值）33％，粗脂肪（最小值）15％，粗纤维（最大）3％ 美士,据说口碑很好很好,但尝过的人都认为口味一般,中庸便宜是他的特点.营养: 粗蛋白（最小值）36％，粗脂肪（最小值）19％，粗纤维（最大）4％ 牛油果,美国的品牌,还没接触过,据说增肥效果显著.营养: 粗蛋白（最小值）32％，粗脂肪（最小值）20％，粗纤维（最大）3％ EVO ,是玛氏的高阶品牌,有钱上,值得拥有.营养表和成分表都是很暴力的.营养:粗蛋白(最小值) 50%, 粗脂肪(最小值) 22%, 粗纤维(最大值) 2.5% 皇家猫粮油太大,另外有”诱食剂风波,”是玛氏的中阶品牌,不过在医院和猫舍的口碑还不错.如果预算不足,这个是很好的选择. 伟嘉是玛氏的低阶品牌,也可以说是垃圾粮,不推荐食用. 初步确定幼猫期吃专业幼猫粮,比如 雪山还有 Go! 长大了,可以考虑雪山,金装素力高和 Go!","categories":[{"name":"生活","slug":"生活","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/"},{"name":"猫","slug":"生活/猫","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/%E7%8C%AB/"}],"tags":[{"name":"猫","slug":"猫","permalink":"http://mcode.tech/tags/%E7%8C%AB/"}]},{"title":"GitHub也是有离线版的","slug":"杂/title: GitHub也是有离线版的","date":"2017-06-09T09:14:27.000Z","updated":"2017-06-13T09:46:01.000Z","comments":true,"path":"2017/06/09/杂/title: GitHub也是有离线版的/","link":"","permalink":"http://mcode.tech/2017/06/09/%E6%9D%82/title:%20GitHub%E4%B9%9F%E6%98%AF%E6%9C%89%E7%A6%BB%E7%BA%BF%E7%89%88%E7%9A%84/","excerpt":"","text":"因为伟大的 GFW 墙掉了 AWS, 所以GitHub的 Windows 版总是安装失败,所以去找了找是否有离线版安装包. 12在线版安装:https:&#x2F;&#x2F;github-windows.s3.amazonaws.com&#x2F;GitHubSetup.exe离线版安装:https:&#x2F;&#x2F;github-windows.s3.amazonaws.com&#x2F;standalone&#x2F;GitHubDesktop.exe 因为在安装过程中要保持联网,所以安装离线版安装包也有可能会失败,多试几次即可.","categories":[{"name":"App","slug":"App","permalink":"http://mcode.tech/categories/App/"}],"tags":[{"name":"App","slug":"App","permalink":"http://mcode.tech/tags/App/"}]},{"title":"Mac 下的一些软件推荐","slug":"Mac/title: Mac 下的一些软件推荐","date":"2017-06-09T08:17:41.000Z","updated":"2017-06-09T08:17:41.000Z","comments":true,"path":"2017/06/09/Mac/title: Mac 下的一些软件推荐/","link":"","permalink":"http://mcode.tech/2017/06/09/Mac/title:%20Mac%20%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"先挖坑","categories":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"}]},{"title":"Python 的生成器","slug":"Python/title: 生成器","date":"2017-05-24T07:42:53.000Z","updated":"2017-05-24T09:15:33.000Z","comments":true,"path":"2017/05/24/Python/title: 生成器/","link":"","permalink":"http://mcode.tech/2017/05/24/Python/title:%20%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"生成器可以动态的生成后续的元素, 是一种基于某种算法推算出来的, 因为在需要时才生成,故使用生成器可以节省大量的空间. 在 Python 中,这种一边循环一边计算的机制,称为生成器: generator.","text":"生成器可以动态的生成后续的元素, 是一种基于某种算法推算出来的, 因为在需要时才生成,故使用生成器可以节省大量的空间. 在 Python 中,这种一边循环一边计算的机制,称为生成器: generator. 创建 generator[]改()只要将一个列表生成式的[]改成(),就创建了一个 generator: 123456&gt;&gt;&gt;L=[x*x for x in range(10)]&gt;&gt;&gt;L[0,1,4,9,16,25,36,49,64,81]&gt;&gt;&gt;g=(x*x for x in range(10))&gt;&gt;&gt;g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; L 是 一个 list, g 是 一个 generator. 通过 next()函数,可以获得 generator 的下一个返回值. 即,按照设定的算法生成了后续序列 一般来说,是使用 for 循环来迭代 generator. 123&gt;&gt;&gt;g=(x*x for x in range(10))&gt;&gt;&gt;for n in g: print(n) yield有些函数也可以通过算法实现自增, 但是这种函数只是有了’自我生成算法‘,还缺少一个非常重要的标志’yield‘. yield 取代 return, 为函数返回值. 如果一个函数定义包含关键字 yield, 那么这个函数就不再是一个普通的函数,而是一个 generator. yield 与 return 的区别当一个生成器函数调用 yield, 生成器函数的’状态‘会被冻结,所有的变量的值会被保留下来,下一行要执行的代码的位置也会被记录,知道再次调用 next().一旦 next() 再次被调用,生成器函数会从它上次离开的地方开始. 总结 generator 是用来产生一系列的值的. yield 向 generator 函数返回结果 yield 唯一做的另一件事就是保存一个 generator 的状态 generator 是特殊类型的迭代器 可以通过 next()来获取 generator 的下一个值 可以通过隐私调用 next()来忽略某些值. 例子杨辉三角问题 每个数等于它上方两数之和。 每行数字左右对称，由1开始逐渐变大 下面是我的代码: 1234567891011121314151617181920212223def triangles(): if n==0: L2=[1] yield L2 if n==1: L2=[1,1] yield L2 while n&gt;1: L=L2.copy() i = 0 while i &lt; n-1: L2[i+1]=L[i]+L[i+1] i=i+1 L2.append(1) yield L2 n = 0for t in triangles(): print(t) n = n + 1 if n == 10: break 在代码中,还有一个值得注意的地方. L=L2是软复制,仅仅是指针指向. 如果不希望两个 list 之间的变动相互干扰,就需要使用 L.copy()方法来实现硬复制. 另外,我的代码表现出很浓的 C 风格. 以下是看到的其他同学的实践方法,值得学习: 123456def triangles(): L = [1] while True: yield L L.append(0) L = [L[i - 1] + L[i] for i in range(len(L))] 还有另一种写法: 12345678def triangles(): ret = [1] while True: yield ret for i in range(1, len(ret)): ret[i] = pre[i] + pre[i - 1] ret.append(1) pre = ret[:] ​","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"汉诺塔很有趣","slug":"C/title: 汉诺塔很有趣","date":"2017-05-24T01:30:26.000Z","updated":"2017-05-24T09:34:21.000Z","comments":true,"path":"2017/05/24/C/title: 汉诺塔很有趣/","link":"","permalink":"http://mcode.tech/2017/05/24/C/title:%20%E6%B1%89%E8%AF%BA%E5%A1%94%E5%BE%88%E6%9C%89%E8%B6%A3/","excerpt":"汉诺塔的规则很有趣,","text":"汉诺塔的规则很有趣, 汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘. 不过先把 B站上的一个视频搬上来吧. 简单来说, 只关注最底下的最大的盘子,一次递归.","categories":[{"name":"算法","slug":"算法","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"算法/Python","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/Python/"}],"tags":[{"name":"算法探索","slug":"算法探索","permalink":"http://mcode.tech/tags/%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/"}]},{"title":"Python函数的一些问题","slug":"Python/title: Python函数的一些问题","date":"2017-05-22T09:36:41.000Z","updated":"2017-05-23T09:10:51.000Z","comments":true,"path":"2017/05/22/Python/title: Python函数的一些问题/","link":"","permalink":"http://mcode.tech/2017/05/22/Python/title:%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"默认函数,可变函数等一些关于函数定义方面的问题.","text":"默认函数,可变函数等一些关于函数定义方面的问题. 默认参数默认参数定义1234567891011121314151617#先定义个函数def power(x): return x*x&gt;&gt;&gt;power(5)25#扩展这个函数def power(x,n): s = 1 while n &gt; 0: n = n - 1 s = s * n return s&gt;&gt;&gt;power(5,3)125 但是这时候再调用第一个函数,则会报错. 即,调用函数 power()缺少了一个位置参数 n. 这时候就需要使用默认参数了 1234567891011def power(x,n=2): s = 1 while n &gt; 0: n = n - 1 s = s * n return s#如果需要使用 n不等于2的情况,则需要明确传入 n 值.#必选参数在前,默认参数在后,否则可能会报错.#当函数有多个函数时,把变化比较大的参数放在前面,变化比较小的放后面.#变化小的参数可以作为默认参数,这样可以降低调用的难度以及优化代码 多个默认参数,有时按照顺序提供默认参数,有时可以不按顺序提供默认参数 1234#顺序enroll('Bo','M',7)#不按照顺序enroll('Ad','M',city='Tianjin') 默认参数坑12345678def add_end(L=[]): L.append('END') renturn L &gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 函数定义的是在某个列后加入一个 ‘END’, 但是函数好像每次都记住了上次添加了’ END’后的 list. 原因如下: Python函数在定义的时候,默认函数L的值就被确定了,因为 默认函数 L 也是一个变量,它指向对象[],每次调用该函数时,如果改变了 L 的内容,则下次调用时,默认参数的内容就发生了变化,不再是默认的定义. 故,需要特别注意!! 默认参数必须指向不变对象!! 12可变对象:list,dict,ser不变对象: str,None,tuple 可变参数可变参数是指传入的参数个数是可变的. list法123456789#可以通过传入一个 list 作为函数的参数,从而实现参数个数可变.def calc(numble): sum = 0 for n in numbers: sum = sum + n * n return sum#但是必须先填入一个 list 或 tuple&gt;&gt;&gt;calc([1,2,3])14 每次必须传入一个 list 或者 tuple, 太繁琐. ##加* 所以一般将函数的参数改为可变参数 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 在参数前加一个*号. 在内部流程中,参数 numbers 接收到的是一个tuple. 12&gt;&gt;&gt;calc(1,2)5 如果要传入一个 list 或 tuple, 则可以选择在 list 或 tuple 前加一个*号,把 list 或 tuple的元素变成可变参数传入: 123&gt;&gt;&gt;nums=[1,2,3]&gt;&gt;&gt;calc(*nums)14 关键字参数关键字参数的设置可变参数允许传入任意个数参数,自动组装成一个 tuple. 关键字参数允许传入任意个数含参数名的参数,自动组装成一个 dict. 12345def person(name,age,**kw): print(name,age,kw)&gt;&gt;&gt;person('Bo',5,city='Beijing')Bo,5,other:&#123;'city':'Beijing'&#125; 在 person 函数里,我们能保证收到两个必须参数name和age,如果调用者需要提供更多信息,我们也可以收到这些信息,而且这些信息可以是任意的. 也可以先做一个 dict 来存储这些额外的信息, 12345&gt;&gt;&gt;extra=&#123;'city':'Beijing','job':'Engineer','location':'changping'&#125;##可以对个别 key 值调用&gt;&gt;&gt;person('Ja',24,city=extra['city'])##也可以一次性全部调用&gt;&gt;&gt;person('Ja',23,**extra) * extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 *\\ kw 参数, kw 获得一个 dict, 这里并不是指针改变,而是拷贝,所以 kw 的后续改动并不会影响到函数外的 extra. 命名关键字参数关键字参数检查因为在传入时并没有规定参数的格式,所以传入的信息会比较杂乱, 有时希望检查某些参数是否输入: 123456def person(name,age,**kw): if 'city' in kw: pass if 'job' in kw: pass print('name:',name,'age:',age,'other:',kw) 但传入的信息还是很杂乱, 关键字参数限制有时希望限制关键字参数的名字: 12def person(name,age,*,city,job): print(name,age,city,job) *后面的参数都将被视为命名关键字参数. 如果有了一个可变参数,则可变参数后面的参数默认为命名关键字参数 12def person(name,age,*args,city,job): print(name,age,args,city,job) 关键字参数的一些问题 命名关键字参数必须传入参数名. (因为它本质上是一个 dict, 与 key有关,与位置无关) 命名关键字可以设置缺省值 1def person(name,age,*,city='Beijing',job): 注意区分位置参数和命名关键字参数,命名关键字参数实质是传入了一个 dict, 与位置无关. 参数组合参数顺序参数定义是一定要按照以下顺序 必选参数,默认参数,可变参数,命名关键字参数,关键字参数 比如 123def f1(a,b,c=0,*args,**kw):def f2(a,b,c=0,*,d,**kw): 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125; 通过list,tuple 和 dict 传入12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 总结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})。 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"Python 一些数据类型辨析","slug":"Python/title: 4种数据结构对比","date":"2017-05-22T07:37:47.000Z","updated":"2018-03-07T12:45:25.000Z","comments":true,"path":"2017/05/22/Python/title: 4种数据结构对比/","link":"","permalink":"http://mcode.tech/2017/05/22/Python/title:%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/","excerpt":"list,tuple,dict,set 四种数据类型的定义和异同.","text":"list,tuple,dict,set 四种数据类型的定义和异同. listlist 是一种有序的集合,可以随时添加和删除其中的元素. 123456789101112131415161718#声明 classmates = ['Mi','Bo','Tr'] #长度 len(classmates) #索引 classmates[0] ##倒数第一个索引 classmates[-1] #追加 classmates.append('Ad') #插入 classmates.insert(1,'Ja') #删除末尾 classmates.pop() ##删除指定位置 classmates.pop(1) ##list的元素可以为其他的数据结构 L=['Ad',123,['ad','ds']] tupletuple是不可修改的 list.一旦初始化后,就不能修改. 因为不可修改,所以代码更为安全. 123456#声明classmates = ('Mi','Bo','Tr')#因为括号()既可以表示 tuple, 又可以表示数学公式中的小括号.#故 Python 规定.只有1个元素的tuple 定义时必须加一个**,**,来消除歧义t=(1)t=(1,) 另外,因为特殊的结构,还存在一种”可变”的tuple. 12#\"可变\"的 tuplet = (\"Ad\",123,['sad','asda']) 因为, tuple 内含的 list 是可变的,而 tuple 本身的指向和结构并没有发生改变. dictdict即为 dictionary, 在其他语言中也称为 map. 使用键-值(key-value)存储,查找速度极快. 12#声明d = &#123;'Mi':95,'Bo':85,'Tr':75&#125; dict 和 list 查找速度对比list: 把字典从第一页向后翻,直到查找到. 所以 list 中查找元素, list 越大,查找越慢 dict: 给定一个 key 值,来计算出 value 的存放位置. 比如” Mi”,dict 在内部进行计算出 Mi对应存放 value 的”页码”,即可直接取出 value. 123456789#初始化后赋值d['Mi']=97#Key 不存在会报错##判断 key 是否存在'Mi'in d##通过 get 方法,如果 key 不存在,返回指定 valued.get('Mi',-1)#删除一个 keyd.pop('Bo') dict 是一种空间换时间的方法. dict 的 key 值是不可变对象 因为 key 值决定了 value 的存储位置,如果 key 值变化,则整个 dict 就陷入了混乱. list 是可变的,故 list 不能为 key. setset 是无序无重复的元素集合 创建一个 set, 需要提供一个 list 作为输入集合 12345678910111213141516#声明&gt;&gt;&gt;s = set([1,2,3,3])#重复元素会被自动过滤&gt;&gt;&gt;s&#123;1,2,3&#125;#添加元素s.add(4)#删除元素s.remove(3)#可以做 交集,并集等操作&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 小结list是有序可变,中括号 1list = ['ad',123,False] tuple 是有序不可变,小括号 1tuple = ('ada',1231,list,['dsa','dasda']) dict 是无序, key-value ,中括号 1dict = &#123;'Ad':96,'Mi':97&#125; set 是无序,无重复,set(list) 1s = set(['ads','dasd',123])","categories":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"}]},{"title":"MySQL导出时 add-drop-table 问题","slug":"DB/title: Mysql","date":"2017-05-22T02:22:49.000Z","updated":"2017-05-23T05:01:29.000Z","comments":true,"path":"2017/05/22/DB/title: Mysql/","link":"","permalink":"http://mcode.tech/2017/05/22/DB/title:%20Mysql/","excerpt":"在使用 mysqldump 导出数据库某表后,直接使用 导入该 sql 文件,该表内的元数据会被删除.","text":"在使用 mysqldump 导出数据库某表后,直接使用 导入该 sql 文件,该表内的元数据会被删除. 原来是通过 mysqldump工具导出时,默认情况下会在 create 语句前加 add-drop-table, 导致每个导出文件内都有 droptable 命令. 所以需要在导出时加入 –skip-add-drop-table 参数,这样就可以在导入时避免删除掉原有数据.","categories":[{"name":"DB","slug":"DB","permalink":"http://mcode.tech/categories/DB/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/tags/MySQL/"}]},{"title":"Mac 的一些技巧","slug":"Mac/title: Mac 的一些小技巧","date":"2017-05-16T09:25:28.000Z","updated":"2017-05-23T05:03:37.000Z","comments":true,"path":"2017/05/16/Mac/title: Mac 的一些小技巧/","link":"","permalink":"http://mcode.tech/2017/05/16/Mac/title:%20Mac%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"在使用 Mac 过程中的一些小技巧和快捷键.","text":"在使用 Mac 过程中的一些小技巧和快捷键. 通过Command+点击在新窗口中打开Finder侧边栏上的项目 Command+鼠标拖拽可以移动后方的窗口，同时不影响前端窗口 Command+点击Dock上的图标可以打开应用在Finder中的位置 Command+回车Spotlight中的搜索结果可以直接在Finder中查看 Command+回车Spotlight中的搜索结果可以直接在Finder中查看","categories":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"}]},{"title":"Markdown 语法和 MWeb 写作使用说明","slug":"Markdown 语法和 MWeb 写作使用说明","date":"2017-04-12T05:51:12.000Z","updated":"2017-05-17T06:50:04.000Z","comments":true,"path":"2017/04/12/Markdown 语法和 MWeb 写作使用说明/","link":"","permalink":"http://mcode.tech/2017/04/12/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。","text":"Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 &#96;&lt;h1&gt;&#96; ## 第二级标题 &#96;&lt;h2&gt;&#96; ###### 第六级标题 &#96;&lt;h6&gt;&#96; 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成&#96;&lt;em&gt;&#96;*_这些文字会生成&#96;&lt;u&gt;&#96;_**这些文字会生成&#96;&lt;strong&gt;&#96;**__这些文字会生成&#96;&lt;strong&gt;&#96;__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 &#96;* + 空格键&#96;* 项目二* 项目二的子项目一 无序列表 &#96;TAB + * + 空格键&#96;* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 &#96;数字 + . + 空格键&#96;2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 &#96;TAB + 数字 + . + 空格键&#96;2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96; 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http:&#x2F;&#x2F;zh.mweb.im&#x2F;asset&#x2F;img&#x2F;set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http:&#x2F;&#x2F;github.com)自动生成连接 &lt;http:&#x2F;&#x2F;www.github.com&#x2F;&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：&#96;&lt;addr&gt;&#96; &#96;code&#96; CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125;CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 12345********- - - 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x &#x3D; \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; &#x3D;1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) &#x3D; (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","categories":[],"tags":[]},{"title":"test","slug":"数据挖掘—将数据转换成知识","date":"2017-03-13T00:37:19.000Z","updated":"2017-05-15T07:13:16.000Z","comments":true,"path":"2017/03/13/数据挖掘—将数据转换成知识/","link":"","permalink":"http://mcode.tech/2017/03/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/","excerpt":"","text":"数据 未处理的。 知识 已经经过处理和分析。 模式 信息 含义广泛，包含未处理和已处理。 数据挖掘—将数据转换成知识KDD（knowledge discovery form data）知识发现 等同于数据挖掘 在各个行业，对数据挖掘的认识不同，因为他们所受的教育和氛围以及基础知识，让他们在细微地方不同。 数据挖掘特点 数据真实 数据海量 决策者的随机查询 挖掘出来的知识一般不能预知，是潜在的新颖知识 数据挖掘的功能 6类 概念描述 concept description 关联关系（Association） 分类和预测（） ​ 分类—离散的数据 预测—l连续的数据 聚类分析（cluster analysis） 异常分析 趋势和演化分析（Trend and evolution analysis） 判断发现模式是否有趣（interesting）分为主观和客观两个方面。 数据挖掘框架 Techniques Applications Principles (imp) 数据挖掘的分类数据挖掘算法的组件化思想 （IMP）五个标准组件 模型和模式结构 数据挖掘任务 评分函数 搜索和优化方法 效果 数据管理策略 效率 模型是全局的，模式是局部的。两者相互联系。 当面对一个新的应用时，数据挖掘人员应该从组件的角度，根据应用需求，考虑应该选取哪些组件，来组成一个新的算法，而不是考虑哪个现成的算法。","categories":[{"name":"Diary","slug":"Diary","permalink":"http://mcode.tech/categories/Diary/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"http://mcode.tech/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://mcode.tech/tags/Games/"}]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/categories/MySQL/"},{"name":"Nginx","slug":"Nginx","permalink":"http://mcode.tech/categories/Nginx/"},{"name":"Python","slug":"Python","permalink":"http://mcode.tech/categories/Python/"},{"name":"Python  ","slug":"Python","permalink":"http://mcode.tech/categories/Python/"},{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/categories/Mac/"},{"name":"生活","slug":"生活","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/"},{"name":"猫","slug":"生活/猫","permalink":"http://mcode.tech/categories/%E7%94%9F%E6%B4%BB/%E7%8C%AB/"},{"name":"App","slug":"App","permalink":"http://mcode.tech/categories/App/"},{"name":"算法","slug":"算法","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"算法/Python","permalink":"http://mcode.tech/categories/%E7%AE%97%E6%B3%95/Python/"},{"name":"DB","slug":"DB","permalink":"http://mcode.tech/categories/DB/"},{"name":"Diary","slug":"Diary","permalink":"http://mcode.tech/categories/Diary/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://mcode.tech/tags/DB/"},{"name":"server","slug":"server","permalink":"http://mcode.tech/tags/server/"},{"name":"Python","slug":"Python","permalink":"http://mcode.tech/tags/Python/"},{"name":"Mac","slug":"Mac","permalink":"http://mcode.tech/tags/Mac/"},{"name":"猫","slug":"猫","permalink":"http://mcode.tech/tags/%E7%8C%AB/"},{"name":"App","slug":"App","permalink":"http://mcode.tech/tags/App/"},{"name":"算法探索","slug":"算法探索","permalink":"http://mcode.tech/tags/%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2/"},{"name":"MySQL","slug":"MySQL","permalink":"http://mcode.tech/tags/MySQL/"},{"name":"PS3","slug":"PS3","permalink":"http://mcode.tech/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://mcode.tech/tags/Games/"}]}