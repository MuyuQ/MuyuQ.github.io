{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Welcome to Mcode","text":"","path":["Welcome to Mcode"],"tags":[]},{"location":"#_1","level":2,"title":"简单记录生活","text":"<p>一些分享</p>","path":["Welcome to Mcode"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/","level":1,"title":"汉诺塔问题详解","text":"<p>汉诺塔的规则很有趣。</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_2","level":2,"title":"问题起源","text":"<p>汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p> <p>不过先把 B站上的一个视频搬上来吧.</p> <p></p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_3","level":2,"title":"问题规则","text":"<p>汉诺塔问题看似简单，但背后蕴含着深刻的数学原理：</p> <ol> <li>三根柱子：通常标记为A（起始柱）、B（辅助柱）、C（目标柱）</li> <li>移动规则：</li> <li>每次只能移动一个圆盘</li> <li>大圆盘不能放在小圆盘上面</li> <li>目标是将所有圆盘从起始柱移动到目标柱</li> </ol>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_4","level":2,"title":"递归解法","text":"<p>简单来说，只关注最底下的最大的盘子，一次递归。</p> <p>汉诺塔问题的解决思路非常巧妙，采用分治法的思想：</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_5","level":3,"title":"核心思想","text":"<p>要将n个盘子从A柱移动到C柱，可以分解为三个步骤：</p> <ol> <li>将上面的n-1个盘子从A柱借助C柱移动到B柱</li> <li>将最大的第n个盘子从A柱直接移动到C柱</li> <li>将n-1个盘子从B柱借助A柱移动到C柱</li> </ol>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#python","level":3,"title":"Python实现","text":"<pre><code>def hanoi(n, source, target, auxiliary):\n    \"\"\"\n    汉诺塔问题的递归解法\n\n    参数:\n    n: 圆盘数量\n    source: 起始柱子\n    target: 目标柱子\n    auxiliary: 辅助柱子\n    \"\"\"\n    # 基础情况：只有一个圆盘时，直接移动\n    if n == 1:\n        print(f\"将第1个圆盘从 {source} 移动到 {target}\")\n        return 1  # 返回移动次数\n\n    # 递归步骤1：将n-1个圆盘从起始柱移动到辅助柱\n    count1 = hanoi(n - 1, source, auxiliary, target)\n\n    # 执行步骤2：将最大的圆盘移动到目标柱\n    print(f\"将第{n}个圆盘从 {source} 移动到 {target}\")\n    count2 = 1\n\n    # 递归步骤3：将n-1个圆盘从辅助柱移动到目标柱\n    count3 = hanoi(n - 1, auxiliary, target, source)\n\n    # 返回总移动次数\n    return count1 + count2 + count3\n\n# 示例调用\nprint(\"3个圆盘的移动步骤：\")\ntotal_moves = hanoi(3, 'A', 'C', 'B')\nprint(f\"总共需要 {total_moves} 步\")\n</code></pre>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_6","level":3,"title":"算法分析","text":"<p>时间复杂度：O(2^n) - 汉诺塔问题的时间复杂度是指数级的，因为每增加一个圆盘，移动步数就会翻倍 - 对于n个圆盘，最少需要 2^n - 1 步才能完成</p> <p>空间复杂度：O(n) - 由于递归调用栈的深度为n，所以空间复杂度为O(n)</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_7","level":2,"title":"数学奥秘","text":"<p>汉诺塔问题不仅是一个有趣的智力游戏，还蕴含着深刻的数学规律：</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_8","level":3,"title":"移动步数公式","text":"<p>对于n个圆盘，最少移动步数为：2^n - 1</p> <p>让我们看看几个具体例子： - 1个圆盘：2^1 - 1 = 1步 - 2个圆盘：2^2 - 1 = 3步 - 3个圆盘：2^3 - 1 = 7步 - 4个圆盘：2^4 - 1 = 15步 - ... - 64个圆盘：2^64 - 1 = 18,446,744,073,709,551,615步</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#64","level":3,"title":"神话中的64个圆盘","text":"<p>根据印度神话，如果真的有僧侣在移动64个黄金圆盘，假设每秒移动一次，需要约5800亿年才能完成！这个数字远超过宇宙的年龄，因此传说中说当僧侣们完成这个任务时，世界就会终结。</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_9","level":2,"title":"实际应用","text":"<p>虽然汉诺塔看起来只是一个数学游戏，但它在计算机科学中有重要的应用价值：</p> <ol> <li>递归思维训练：是学习递归算法的经典案例</li> <li>分治法理解：体现了将复杂问题分解为简单子问题的思想</li> <li>栈结构演示：递归调用的过程可以用栈来模拟</li> <li>算法复杂度分析：展示指数时间复杂度的实际例子</li> </ol>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"C/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#_10","level":2,"title":"总结","text":"<p>汉诺塔问题是一个经典的递归问题，它完美地展现了以下几个重要概念：</p> <ol> <li>递归的本质：将一个问题分解为相同类型但规模更小的子问题</li> <li>分治思想：将复杂问题拆分成若干个更容易解决的小问题</li> <li>数学之美：简单的规则背后隐藏着深刻的数学规律</li> <li>算法效率：通过汉诺塔问题我们可以直观地理解指数时间复杂度的概念</li> </ol> <p>无论是作为智力挑战还是算法学习的范例，汉诺塔都是一个值得深入研究的经典问题。它告诉我们，有时候解决复杂问题的关键就在于找到正确的分解方式。</p>","path":["C","汉诺塔问题详解"],"tags":[]},{"location":"DB/MySQL%E4%B8%ADCHAR%E4%B8%8EVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB/","level":1,"title":"MySQL中CHAR与VARCHAR的区别详解","text":"<ol> <li> <p>CHAR固定长度, VARCHAR可变长度</p> </li> <li> <p>如果实际存入数据长度小于指定长度,CHAR会填充空格到指定长度,VARCHAR会缩短到实际长度.</p> </li> <li> <p>如果实际存入数据长度大于指定长度,两者低版本会截取,高版本会报错</p> </li> <li> <p>CHAR效率比VARCHAR高,但是相对而言费存储空间. 因为VARCHAR会多一个字节记录长度.每次修改完数据后都会重新计算一次,导致效率变慢.</p> </li> <li> <p>CHAR在内存和硬盘上都会按照最大的指定长度分配空间,而VARCHAR在硬盘上会按照实际长度分配空间,在内存上按照指定长度分配空间.这导致两个问题</p> </li> </ol> <p>5.1 如果将varchar指定长度非常大,会导致内存占用很高,反而不利.</p> <p>5.2 如果定义varchar(30),更改前字符长度为10,系统分配了10个存储单位.但更改后字符长度变为20,还在最大长度范围内,但是原存储位置无法满足其存储需求.系统需要进行额外的操作,比如拆分和分页.</p> <ol> <li>MyISAM表推荐使用CHAR,缺点是占用磁盘</li> </ol> <p>InnoDB表,推荐使用VARCHAR.</p> <p>如果存储的信息很短,那么推荐使用CHAR,  因为VARCHAR还有额外的开销.</p> <p>如果是长度固定的数据,比如说uid,CHAR更适合.</p> <p>如果是频繁改动的column,推荐使用CHAR,因为VARCHAR每次都有额外的长度计算工作.</p>","path":["DB","MySQL中CHAR与VARCHAR的区别详解"],"tags":[]},{"location":"DB/MySQL%E4%B8%ADCHAR%E4%B8%8EVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB/#_1","level":2,"title":"核心要点总结","text":"<ul> <li>CHAR是固定长度字符串类型，会用空格填充到指定长度；VARCHAR是可变长度字符串类型，只占用实际数据所需的存储空间</li> <li>在存储效率方面，CHAR适用于长度相对固定的短字符串，VARCHAR适用于长度变化较大的字符串</li> <li>CHAR在读取操作上通常比VARCHAR更高效，但会占用更多存储空间</li> <li>VARCHAR需要额外的1字节（或更多）来存储字符串的实际长度，且在数据修改时需要重新计算长度</li> <li>不同存储引擎有不同推荐：MyISAM表推荐使用CHAR，InnoDB表推荐使用VARCHAR</li> <li>对于长度固定的数据（如UID）或频繁修改的字段，推荐使用CHAR以提高性能</li> <li>使用VARCHAR时要注意合理设置最大长度，避免因内存分配问题影响性能</li> </ul>","path":["DB","MySQL中CHAR与VARCHAR的区别详解"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","level":1,"title":"MySQL基础语法","text":"<p>MySQL是最流行的开源关系型数据库管理系统之一，广泛应用于Web开发、数据分析等领域。掌握MySQL的基础语法是每个开发者必备的技能。</p> <p>本文将带你系统学习MySQL的基础语法，从核心概念到实际操作，帮助你建立起完整的知识体系。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_1","level":2,"title":"目录","text":"<ul> <li>MySQL核心概念</li> <li>数据库与表的操作</li> <li>数据操作（CRUD）</li> <li>查询进阶</li> <li>MySQL高级特性</li> <li>最佳实践与规范</li> <li>总结</li> </ul>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#mysql_1","level":2,"title":"MySQL核心概念","text":"<p>在学习MySQL之前，我们需要了解一些基本概念：</p> <ol> <li>数据库（Database）：存储数据的仓库，可以看作是一个文件夹</li> <li>表（Table）：数据库中的具体数据结构，类似于Excel表格，由行和列组成</li> <li>字段（Field/Column）：表中的列，定义了数据的类型和约束</li> <li>记录（Record/Row）：表中的行，代表一条具体的数据</li> <li>主键（Primary Key）：唯一标识表中每一行记录的字段，是数据库设计的核心要素</li> </ol> <p>扩展说明：在实际开发中，除了主键外，还有其他重要的键概念： - 外键（Foreign Key）：用于建立和加强两个表数据之间的链接 - 候选键（Candidate Key）：表中可以唯一标识记录的属性或属性组 - 复合键（Composite Key）：由多个字段组成的主键</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_2","level":2,"title":"数据库与表的操作","text":"","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_3","level":3,"title":"创建和使用数据库","text":"<p>创建数据库是使用 MySQL 的第一步，以下是创建数据库的基本语法：</p> <pre><code>-- 创建数据库\nCREATE DATABASE `mydatabase`;\n\n-- 使用数据库\nUSE `mydatabase`;\n</code></pre> <p>实例讲解：假设我们要创建一个学校管理系统数据库，可以这样操作： <pre><code>-- 创建学校管理系统数据库\nCREATE DATABASE `school_management`;\n\n-- 使用学校管理系统数据库\nUSE `school_management`;\n</code></pre></p> <p>重要提醒：反引号并不是必须的，但强烈建议使用，它可以防止在创建数据库或表时使用到 MySQL 的关键字而产生冲突。</p> <p>扩展说明：创建数据库时还可以指定字符集和排序规则： <pre><code>-- 创建数据库并指定字符集和排序规则\nCREATE DATABASE `school_management` \nCHARACTER SET utf8mb4 \nCOLLATE utf8mb4_unicode_ci;\n</code></pre> 这样可以确保数据库正确处理中文和其他特殊字符。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_4","level":3,"title":"创建数据表","text":"<p>创建表是数据库设计的重要环节，以下是创建表的基本语法：</p> <pre><code>-- 创建学生表，包含ID和姓名字段\nCREATE TABLE `student`(\n  `id` INT NOT NULL AUTO_INCREMENT,      -- 学生ID，整数类型，非空，自动递增\n  `name` VARCHAR(200) NOT NULL,          -- 学生姓名，可变长字符串，最大200字符，非空\n  PRIMARY KEY (`id`)                     -- 设置主键为ID字段\n);\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_5","level":4,"title":"常见数据类型说明","text":"类型 说明 适用场景 INT 整数类型 年龄、数量等整数值 CHAR 固定长度字符串 手机号、身份证号等固定长度文本 VARCHAR 可变长度字符串 姓名、地址等长度不固定的文本 DATETIME 日期时间类型 时间戳、创建时间等 TEXT 长文本类型 文章内容、描述信息等 DECIMAL 精确小数类型 金额、价格等需要精确计算的数值 <p>扩展说明：MySQL提供了丰富的数据类型，根据实际需求选择合适的类型非常重要： - 数值类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT、FLOAT、DOUBLE、DECIMAL - 字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT - 日期时间类型：DATE、TIME、DATETIME、TIMESTAMP、YEAR</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_6","level":4,"title":"字段约束说明","text":"<p>在创建表时，可以为字段添加约束来保证数据的完整性：</p> 约束类型 说明 示例 NOT NULL 字段不能为空 <code>name VARCHAR(50) NOT NULL</code> UNIQUE 字段值必须唯一 <code>email VARCHAR(100) UNIQUE</code> PRIMARY KEY 主键约束 <code>id INT PRIMARY KEY</code> FOREIGN KEY 外键约束 <code>student_id INT, FOREIGN KEY (student_id) REFERENCES students(id)</code> DEFAULT 默认值 <code>status VARCHAR(20) DEFAULT 'active'</code> CHECK 检查约束 <code>age INT CHECK (age &gt;= 0 AND age &lt;= 150)</code> <p>实例讲解：我们为学校管理系统创建一个更完整的学生表： <pre><code>-- 创建学生信息表，包含完整的字段定义和约束\nCREATE TABLE `students`(\n  `id` INT NOT NULL AUTO_INCREMENT,                    -- 学生ID，主键且自动递增\n  `student_id` CHAR(10) NOT NULL UNIQUE,               -- 学号（固定长度且唯一）\n  `name` VARCHAR(50) NOT NULL,                         -- 姓名\n  `age` INT NOT NULL CHECK (age &gt;= 0 AND age &lt;= 150),  -- 年龄（带检查约束）\n  `gender` CHAR(1) NOT NULL,                           -- 性别（M/F）\n  `email` VARCHAR(100) UNIQUE,                         -- 邮箱（唯一）\n  `birth_date` DATE NULL,                              -- 出生日期\n  `enrollment_date` DATETIME DEFAULT CURRENT_TIMESTAMP,-- 入学时间（默认当前时间）\n  `status` VARCHAR(20) DEFAULT 'active',               -- 状态（默认值）\n  PRIMARY KEY (`id`)                                   -- 设置主键\n);\n</code></pre></p> <p>重要提示：CHAR 类型适合存储长度固定的字符串，如手机号、身份证号等；VARCHAR 类型适合存储长度不固定的字符串，如姓名、地址等。选择合适的数据类型对数据库性能至关重要。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_7","level":3,"title":"查看表结构","text":"<p>在 MySQL 中，可以使用以下命令来查看表的结构信息：</p> <pre><code>-- 查看表结构的两种方式\nDESCRIBE 表名;    -- 方式一：使用DESCRIBE命令\nEXPLAIN 表名;     -- 方式二：使用EXPLAIN命令\n</code></pre> <p>扩展说明：还可以使用以下命令获取更多表信息： <pre><code>-- 查看创建表的完整SQL语句\nSHOW CREATE TABLE students;\n\n-- 查看表的索引信息\nSHOW INDEX FROM students;\n</code></pre></p> <p>实例讲解：查看我们刚创建的学生表结构： <pre><code>-- 查看学生表结构\nDESCRIBE students;\n\n-- 或者使用另一种方式查看学生表结构\nEXPLAIN students;\n</code></pre></p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#crud","level":2,"title":"数据操作（CRUD）","text":"<p>CRUD是数据库操作的核心，分别代表Create（创建）、Read（读取）、Update（更新）和Delete（删除）。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#1-create","level":3,"title":"1. 插入数据（Create）","text":"<p>向表中插入数据是数据库操作的基本需求之一，MySQL 提供了多种插入数据的方式。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_8","level":4,"title":"插入完整记录","text":"<pre><code>-- 插入完整记录（需要为所有字段提供值）\nINSERT INTO `students` VALUES(1,'张三','三哥','男',now());\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_9","level":4,"title":"指定字段插入","text":"<p>当只需要插入部分字段的数据时，可以指定字段名：</p> <pre><code>-- 指定字段插入（只需为指定字段提供值）\nINSERT INTO `students`(`name`,`nickname`,`sex`,`in_time`) VALUES('张三2','三哥2','男',now());\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_10","level":4,"title":"插入部分字段","text":"<p>对于允许为空的字段，可以省略不插入：</p> <pre><code>-- 插入部分字段（未指定的字段将使用默认值或NULL）\nINSERT INTO `students`(`name`,`nickname`,`sex`) VALUES('张三3','三哥3','男');\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_11","level":4,"title":"批量插入","text":"<p>当需要插入多条记录时，可以使用批量插入以提高效率：</p> <pre><code>-- 批量插入多条记录（一次性插入多行数据，提高效率）\nINSERT INTO `students`(`name`,`nickname`,`sex`) VALUES\n('张三4','三哥4','男'),\n('张三5','三哥5','男'),\n('张三6','三哥6','男');\n</code></pre> <p>实例讲解：向学生表中插入几条记录： <pre><code>-- 插入单条学生记录（指定所有必要字段）\nINSERT INTO `students`(`student_id`, `name`, `age`, `gender`, `birth_date`, `enrollment_date`) \nVALUES('2023001', '张小明', 18, 'M', '2005-03-15', NOW());\n\n-- 批量插入多条学生记录（一次性插入多行数据）\nINSERT INTO `students`(`student_id`, `name`, `age`, `gender`, `birth_date`, `enrollment_date`) VALUES\n('2023002', '李小红', 17, 'F', '2006-07-22', NOW()),\n('2023003', '王小强', 19, 'M', '2004-11-08', NOW()),\n('2023004', '赵小丽', 18, 'F', '2005-01-30', NOW());\n</code></pre></p> <p>重要注意：虽然 MySQL 中 <code>VALUE</code> 和 <code>VALUES</code> 在语法上都可以使用，但为了规范和一致性，建议统一使用 <code>VALUES</code>。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#2-read","level":3,"title":"2. 查询数据（Read）","text":"<p>查询是数据库中最常用的操作之一，可以通过各种条件筛选出需要的数据：</p> <pre><code>-- 基本查询语句示例\nSELECT `name`,`nickname`            -- 选择要查询的字段\nFROM `students`                     -- 指定数据来源表\nWHERE `sex`='男'                    -- 设置查询条件\nORDER BY `id` DESC                  -- 按ID倒序排列\nLIMIT 1,2;                          -- 限制返回结果数量\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#3-update","level":3,"title":"3. 更新数据（Update）","text":"<p>修改表中的数据使用 <code>UPDATE</code> 语句，可以根据条件更新指定的记录：</p> <pre><code>-- 更新满足条件的记录\nUPDATE `students` \nSET `nickname`='没有昵称'     -- 设置要更新的字段和值\nWHERE `sex`='女';              -- 设置更新条件\n</code></pre> <p>实例讲解：更新学生信息： <pre><code>-- 将所有女学生的昵称设置为\"女同学\"\nUPDATE students \nSET nickname='女同学' \nWHERE gender='F';\n\n-- 更新指定学号学生的信息\nUPDATE students \nSET age=19, enrollment_date=NOW() \nWHERE student_id='2023001';\n\n-- 同时更新多个字段\nUPDATE students \nSET age=age+1, status='graduate' \nWHERE enrollment_date &lt; '2020-01-01';\n</code></pre></p> <p>危险警告：务必在 <code>UPDATE</code> 语句中使用 <code>WHERE</code> 条件，否则将更新表中的所有记录！这可能导致灾难性后果。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#update","level":4,"title":"UPDATE 语法规则","text":"<ol> <li>使用 <code>SET</code> 关键字指定要更新的字段和值</li> <li>使用 <code>WHERE</code> 设置更新条件</li> <li>可以同时更新多个字段：</li> </ol> <pre><code>-- 同时更新多个字段\nUPDATE `students` \nSET `nickname`='新昵称', `in_time`=NOW() \nWHERE `id`=1;\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#4-delete","level":3,"title":"4. 删除数据（Delete）","text":"<p>删除表中的数据使用 <code>DELETE</code> 语句：</p> <pre><code>-- 删除满足条件的记录\nDELETE FROM `students`       -- 指定要删除数据的表\nWHERE `sex`='男';            -- 设置删除条件\n</code></pre> <p>实例讲解：删除学生记录： <pre><code>-- 删除所有男学生记录\nDELETE FROM students WHERE gender='M';\n\n-- 删除指定学号的学生记录\nDELETE FROM students WHERE student_id='2023001';\n\n-- 删除毕业超过5年的学生记录\nDELETE FROM students \nWHERE status='graduate' AND enrollment_date &lt; DATE_SUB(NOW(), INTERVAL 5 YEAR);\n</code></pre></p> <p>危险警告：务必在 <code>DELETE</code> 语句中使用 <code>WHERE</code> 条件，否则将删除表中的所有记录！这是极其危险的操作。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#delete","level":4,"title":"DELETE 语法规则","text":"<ol> <li>使用 <code>WHERE</code> 设置删除条件</li> <li>如果需要清空整个表，建议使用 <code>TRUNCATE</code> 语句（效率更高）：</li> </ol> <pre><code>-- 清空整个表的数据（比DELETE更快，且重置自增ID）\nTRUNCATE TABLE `students`;\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#delete-truncate","level":4,"title":"DELETE 与 TRUNCATE 的区别","text":"特性 DELETE TRUNCATE 性能 较慢（逐行删除） 快速（重置表） 条件 支持 WHERE 条件 不支持条件 事务 可回滚 不可回滚 计数器 不重置自增ID 重置自增ID 触发器 会触发DELETE触发器 不会触发DELETE触发器","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_12","level":2,"title":"查询进阶","text":"","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#where","level":3,"title":"常用WHERE条件","text":"操作符 说明 示例 = 等于 <code>WHERE age = 18</code> != 或 &lt;&gt; 不等于 <code>WHERE age != 18</code> &gt;, &lt;, &gt;=, &lt;= 比较运算 <code>WHERE age &gt;= 18</code> BETWEEN 在范围内 <code>WHERE age BETWEEN 18 AND 25</code> IN 在列表中 <code>WHERE gender IN ('M', 'F')</code> LIKE 模糊匹配 <code>WHERE name LIKE '%小%'</code> IS NULL 为空 <code>WHERE email IS NULL</code> IS NOT NULL 不为空 <code>WHERE email IS NOT NULL</code>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_13","level":3,"title":"聚合函数","text":"函数 说明 示例 COUNT() 计数 <code>SELECT COUNT(*) FROM students</code> SUM() 求和 <code>SELECT SUM(age) FROM students</code> AVG() 平均值 <code>SELECT AVG(age) FROM students</code> MAX() 最大值 <code>SELECT MAX(age) FROM students</code> MIN() 最小值 <code>SELECT MIN(age) FROM students</code>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_14","level":3,"title":"分组查询","text":"<p>使用 <code>GROUP BY</code> 可以按指定字段分组统计：</p> <pre><code>-- 统计每个性别的学生人数\nSELECT gender, COUNT(*) as count \nFROM students \nGROUP BY gender;\n\n-- 统计平均年龄并按性别分组\nSELECT gender, AVG(age) as avg_age \nFROM students \nGROUP BY gender;\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_15","level":3,"title":"连接查询","text":"<p>当需要从多个表中获取数据时，可以使用连接查询：</p> <pre><code>-- 内连接：查询学生及其课程信息\nSELECT s.name, c.course_name \nFROM students s \nINNER JOIN enrollments e ON s.id = e.student_id\nINNER JOIN courses c ON e.course_id = c.id;\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_16","level":3,"title":"排序规则","text":"<ul> <li>默认情况下，排序是正序（升序），使用 <code>ASC</code> 关键字</li> <li>倒序（降序）需要显式指定 <code>DESC</code> 关键字</li> </ul>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_17","level":3,"title":"分页查询","text":"<p>使用 <code>LIMIT</code> 可以实现分页功能：</p> <pre><code>-- 查询前10条记录\nSELECT * FROM `students` LIMIT 10;\n\n-- 查询第11-20条记录\nSELECT * FROM `students` LIMIT 10, 10;\n\n-- 或者使用另一种写法\nSELECT * FROM `students` LIMIT 10 OFFSET 10;\n</code></pre> <p>实例讲解：对学生表进行各种查询操作： <pre><code>-- 查询所有学生信息\nSELECT * FROM students;\n\n-- 查询特定性别学生的名字和年龄\nSELECT name, age FROM students WHERE gender='F';\n\n-- 查询年龄大于17岁的学生，按年龄降序排列\nSELECT * FROM students WHERE age &gt; 17 ORDER BY age DESC;\n\n-- 查询学生总数\nSELECT COUNT(*) AS student_count FROM students;\n\n-- 分页查询：每页显示2条记录，查询第二页\nSELECT * FROM students LIMIT 2 OFFSET 2;\n\n-- 复杂查询：查询年龄在18-20岁之间的女生，按入学时间排序\nSELECT * FROM students \nWHERE age BETWEEN 18 AND 20 AND gender='F' \nORDER BY enrollment_date DESC;\n</code></pre></p> <p>重要提示：<code>LIMIT offset, count</code> 中，offset 是起始位置（从0开始），count 是返回记录数。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#mysql_2","level":2,"title":"MySQL高级特性","text":"","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#index","level":3,"title":"索引（Index）","text":"<p>索引是提高查询性能的重要手段：</p> <pre><code>-- 创建普通索引\nCREATE INDEX idx_student_name ON students(name);\n\n-- 创建复合索引\nCREATE INDEX idx_student_gender_age ON students(gender, age);\n\n-- 查看索引\nSHOW INDEX FROM students;\n\n-- 删除索引\nDROP INDEX idx_student_name ON students;\n</code></pre> <p>重要提示：合理使用索引可以大幅提升查询速度，但过多的索引会影响插入和更新性能。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#view","level":3,"title":"视图（View）","text":"<p>视图是虚拟表，可以简化复杂查询：</p> <pre><code>-- 创建视图\nCREATE VIEW active_students AS\nSELECT id, student_id, name, age, gender\nFROM students\nWHERE status = 'active';\n\n-- 使用视图\nSELECT * FROM active_students WHERE age &gt; 18;\n</code></pre>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_18","level":2,"title":"最佳实践与规范","text":"","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#mysql_3","level":3,"title":"MySQL语法规范建议","text":"<ol> <li>MySQL 关键字最好全部使用大写，这是一种通用的规范，有助于提高代码的可读性。</li> <li>对于生产环境的数据库，建议建立专门的只读账户，以防止误操作带来的风险。</li> <li>必须设置一个主键，用于唯一标识每条记录</li> <li>字段定义之间必须用逗号<code>,</code>分隔，而不是分号<code>;</code></li> <li>最后一个字段定义后不能有逗号</li> <li>需要设置默认的编码方式以支持中文（推荐使用 utf8 或 utf8mb4）</li> <li>表名和字段名建议使用小写字母和下划线组合，如 <code>student_info</code></li> <li>为每个表添加注释，说明表的用途</li> <li>为每个字段添加注释，说明字段的含义</li> </ol>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#mysql_4","level":3,"title":"MySQL中的注释","text":"<p>在 MySQL 中可以使用以下方式添加注释：</p> <pre><code>-- 这是一个单行注释\n/* 这是一个多行注释 */\n# 这也是单行注释（MySQL特有）\n</code></pre> <p>实例讲解：在创建表时添加注释说明： <pre><code>-- 创建学生信息表\nCREATE TABLE `students`(\n  `id` INT NOT NULL AUTO_INCREMENT COMMENT '学生ID，主键',\n  `student_id` CHAR(10) NOT NULL COMMENT '学号',\n  `name` VARCHAR(50) NOT NULL COMMENT '学生姓名',\n  `age` INT NOT NULL COMMENT '学生年龄',\n  PRIMARY KEY (`id`)\n) COMMENT='学生信息表';\n</code></pre></p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_19","level":2,"title":"总结","text":"<p>通过本文的学习，我们系统地掌握了MySQL的基础语法知识，涵盖了从入门到进阶的各个重要方面：</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_20","level":3,"title":"核心知识点回顾","text":"<ol> <li> <p>基础概念理解：深入理解了数据库、表、字段、记录、主键等核心概念，为后续学习打下了坚实基础。</p> </li> <li> <p>数据库与表操作：熟练掌握了数据库和表的创建、使用及结构查看，能够独立设计简单的数据库结构。</p> </li> <li> <p>CRUD操作技能：全面掌握了数据的增删改查操作，这是数据库应用中最常用的功能。</p> </li> <li> <p>查询技巧进阶：学习了复杂的查询技巧，包括条件查询、聚合函数、分组查询、连接查询等，能够满足多样化的数据检索需求。</p> </li> <li> <p>高级特性应用：初步了解了索引和视图等高级特性，为性能优化和复杂查询奠定了基础。</p> </li> <li> <p>规范与最佳实践：遵循了MySQL的语法规范和最佳实践，培养了良好的编码习惯。</p> </li> </ol>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_21","level":3,"title":"学习意义与价值","text":"<p>掌握MySQL基础语法不仅能够帮助我们： - 构建和维护各种应用程序的后台数据库 - 进行数据分析和报表生成 - 实现高效的用户数据管理 - 为进一步学习数据库优化、集群部署等高级主题奠定基础</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#_22","level":3,"title":"下一步学习建议","text":"<p>在掌握了这些基础知识后，建议继续深入学习： - 事务处理：了解ACID特性，掌握事务的使用方法 - 存储过程与函数：学习如何编写复杂的业务逻辑 - 触发器：掌握自动化数据处理机制 - 性能优化：深入了解索引优化、查询优化等技术 - 备份与恢复：学习数据安全保障措施</p> <p>数据库技术是现代软件开发不可或缺的一部分，希望本文能够帮助你在MySQL学习的道路上迈出坚实的一步。记住，理论知识需要通过实践来巩固，建议在实际项目中多加练习，不断提升自己的数据库操作技能。</p>","path":["DB","MySQL基础语法"],"tags":[]},{"location":"DB/MySQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","level":1,"title":"MySQL多表查询","text":"<p>多表查询分为inner join,outer join. outer join包括left join,right join,full join.根据具体需要进行选择.</p> <ol> <li>左联结(left join),联结结果保留左边的全部数据</li> <li>右联结(right join),联结结果保留右边的全部数据</li> <li>内联结(inner join),取两表的公共数据</li> <li>完全联结(full join),只要其中某个表存在匹配，FULL JOIN 关键字就会返回行.</li> </ol>","path":["DB","MySQL多表查询"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","level":1,"title":"MySQL mysqldump --skip-add-drop-table 参数完全指南","text":"","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_1","level":2,"title":"问题描述","text":"<p>在使用 mysqldump 导出数据库某表后，直接使用导入该 sql 文件时，该表内的原有数据会被删除。</p> <p>原来是通过 mysqldump 工具导出时，默认情况下会在 CREATE TABLE 语句前添加 <code>DROP TABLE</code> 语句，导致每个导出文件内都有删除表的命令。</p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_2","level":2,"title":"问题原因","text":"<p>mysqldump 默认行为：为了确保在导入时能够正确重建表结构，mysqldump 工具默认会在每个 CREATE TABLE 语句之前添加 DROP TABLE IF EXISTS 语句。这样的设计目的是为了避免在导入数据时出现表已存在的错误。</p> <p>DROP TABLE IF EXISTS 的作用机制： <pre><code>-- 执行 mysqldump 默认导出的 SQL 文件时的操作流程\n-- 1. 首先检查表是否存在，如果存在则删除\nDROP TABLE IF EXISTS `users`;\n-- 2. 然后重新创建表结构\nCREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n-- 3. 最后插入数据\nINSERT INTO `users` VALUES (1,'Alice'),(2,'Bob');\n</code></pre></p> <p>这种机制虽然保证了表结构的一致性，但在某些场景下可能会导致意外的数据丢失。</p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_3","level":2,"title":"解决方案","text":"","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#-skip-add-drop-table","level":3,"title":"方案一：使用 --skip-add-drop-table 参数","text":"<p>在导出时加入 <code>--skip-add-drop-table</code> 参数，这样就可以在导入时避免删除掉原有数据。</p> <pre><code># 使用 --skip-add-drop-table 参数导出数据库\nmysqldump -u username -p --skip-add-drop-table database_name table_name &gt; backup.sql\n</code></pre> <p>参数说明： - <code>--skip-add-drop-table</code>：阻止 mysqldump 在输出中生成 DROP TABLE 语句</p> <p>使用示例： <pre><code># 导出特定表时不包含 DROP TABLE 语句\nmysqldump -u root -p --skip-add-drop-table mydb users &gt; users_backup.sql\n\n# 导出整个数据库时不包含 DROP TABLE 语句\nmysqldump -u root -p --skip-add-drop-table mydb &gt; db_backup.sql\n</code></pre></p> <p>注意事项： - 使用此参数时，目标数据库中的表必须已经存在且结构兼容 - 如果目标表不存在，则会报错 \"Table 'xxx' doesn't exist\"</p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_4","level":3,"title":"方案二：结合其他参数使用","text":"<p>除了单独使用 <code>--skip-add-drop-table</code> 外，还可以与其他参数组合使用以满足不同需求：</p> <p>1. 与 --add-drop-database 组合使用： <pre><code># 导出整个数据库并跳过删除表语句，但保留数据库级别的 DROP 语句\nmysqldump -u username -p --add-drop-database --skip-add-drop-table database_name &gt; backup.sql\n</code></pre></p> <p>2. 仅导出数据不导出表结构： <pre><code># 只导出数据，不包含任何表结构定义\nmysqldump -u username -p --skip-add-drop-table --no-create-info database_name table_name &gt; data_only.sql\n</code></pre></p> <p>3. 导出特定条件的数据： <pre><code># 导出满足特定条件的数据\nmysqldump -u username -p --skip-add-drop-table --where=\"status='active'\" database_name users &gt; active_users.sql\n</code></pre></p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_5","level":2,"title":"最佳实践","text":"","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#1","level":3,"title":"1. 根据需求选择合适的参数","text":"<p>数据追加场景： <pre><code># 当需要向现有表追加数据而不删除现有数据时\nmysqldump -u username -p --skip-add-drop-table database_name table_name &gt; append_backup.sql\n</code></pre></p> <p>完整备份与恢复场景： <pre><code># 当需要完整的备份与恢复时（默认行为）\nmysqldump -u username -p database_name table_name &gt; full_backup.sql\n</code></pre></p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#2","level":3,"title":"2. 确保数据一致性和兼容性","text":"<p>在使用 <code>--skip-add-drop-table</code> 参数前，需要确保源表和目标表的结构兼容：</p> <p>表结构检查方法： <pre><code>-- 检查表结构是否一致\nSHOW CREATE TABLE source_table;\nSHOW CREATE TABLE target_table;\n\n-- 或者使用 DESCRIBE 查看列信息\nDESCRIBE source_table;\nDESCRIBE target_table;\n</code></pre></p> <p>使用 Python 脚本检查表结构兼容性： <pre><code>def check_table_compatibility(source_schema, target_schema):\n    \"\"\"\n    检查源表和目标表结构是否兼容\n\n    Args:\n        source_schema (dict): 源表结构 {'column_name': 'data_type'}\n        target_schema (dict): 目标表结构 {'column_name': 'data_type'}\n\n    Returns:\n        bool: 表结构是否兼容\n    \"\"\"\n    # 检查列名和数据类型是否匹配\n    for col_name, col_type in source_schema.items():\n        if col_name not in target_schema:\n            print(f\"警告: 目标表缺少列 {col_name}\")\n            return False\n        if col_type != target_schema[col_name]:\n            print(f\"警告: 列 {col_name} 数据类型不匹配\")\n            return False\n    return True\n\n# 示例使用\nsource_table = {\n    'id': 'int(11)',\n    'name': 'varchar(255)',\n    'email': 'varchar(255)'\n}\n\ntarget_table = {\n    'id': 'int(11)',\n    'name': 'varchar(255)',\n    'email': 'varchar(255)'\n}\n\nif check_table_compatibility(source_table, target_table):\n    print(\"表结构兼容，可以安全使用 --skip-add-drop-table 参数\")\nelse:\n    print(\"表结构不兼容，请先调整表结构\")\n</code></pre></p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#3-mysqldump","level":3,"title":"3. 其他常用的 mysqldump 参数","text":"<pre><code># 推荐的完整备份命令\nmysqldump -u username -p \\\n  --single-transaction \\\n  --routines \\\n  --triggers \\\n  --events \\\n  --hex-blob \\\n  --opt \\\n  database_name &gt; backup.sql\n</code></pre> <p>参数说明： - <code>--single-transaction</code>：对 InnoDB 引擎进行一致性备份，避免锁表 - <code>--routines</code>：导出存储过程和函数 - <code>--triggers</code>：导出触发器 - <code>--events</code>：导出事件调度器 - <code>--hex-blob</code>：以十六进制格式导出二进制字段 - <code>--opt</code>：启用一组优化选项的快捷方式</p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#4","level":3,"title":"4. 导入数据时的注意事项","text":"<pre><code># 导入数据的标准命令\nmysql -u username -p database_name &lt; backup.sql\n</code></pre> <p>重要提示： - 在导入前确保目标数据库已存在 - 如果使用了 <code>--skip-add-drop-table</code>，确保目标表结构兼容 - 对于大文件导入，可以考虑临时调整 MySQL 的配置参数以提升性能</p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#5","level":3,"title":"5. 性能优化建议","text":"<p>对于大型数据库的备份和恢复操作，还需要考虑以下性能优化措施：</p> <p>备份性能优化： <pre><code># 使用压缩减少备份文件大小\nmysqldump -u username -p --compress database_name &gt; backup.sql\n\n# 并行处理多个表（需要配合其他工具）\n# 使用 mydumper 替代 mysqldump 进行并行备份\nmydumper -u username -p --database=database_name --threads=4 --compress\n</code></pre></p> <p>恢复性能优化： <pre><code># 禁用自动提交以提高导入速度\nmysql -u username -p database_name --init-command=\"SET autocommit=0\" &lt; backup.sql\n\n# 临时调整 MySQL 参数以加快导入速度\nmysql -u username -p database_name --init-command=\"\n  SET foreign_key_checks=0;\n  SET unique_checks=0;\n  SET autocommit=0;\n\" &lt; backup.sql\n</code></pre></p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_6","level":2,"title":"总结","text":"<p><code>--skip-add-drop-table</code> 参数的核心作用是防止在数据导入过程中意外删除现有表结构和数据。这个参数在以下场景特别有用：</p> <ol> <li>数据合并：当需要将新数据追加到现有表中时</li> <li>结构保护：当希望保留现有表结构不变时</li> <li>安全操作：当不确定导入文件内容，希望避免误删数据时</li> </ol>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_7","level":3,"title":"关键要点回顾","text":"<ul> <li>参数功能：<code>--skip-add-drop-table</code> 阻止 mysqldump 在输出中生成 DROP TABLE 语句</li> <li>使用前提：目标表必须已存在且结构兼容</li> <li>适用场景：数据追加、增量备份、表结构保护等场景</li> <li>风险控制：使用前务必检查表结构兼容性，避免导入失败</li> </ul>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/MySQL%E5%AF%BC%E5%87%BA%E6%97%B6%20add-drop-table%20%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#_8","level":3,"title":"最佳实践建议","text":"<ol> <li>备份策略：根据业务需求选择合适的备份参数组合</li> <li>兼容性检查：在使用前验证源表和目标表的结构一致性</li> <li>性能优化：对于大型数据库，考虑使用并行备份工具如 mydumper</li> <li>安全性保障：定期测试备份和恢复流程，确保数据安全</li> </ol> <p>合理使用 mysqldump 的各种参数，能够帮助我们更好地管理数据库备份与恢复工作，提升数据操作的安全性和效率。</p>","path":["DB","MySQL mysqldump --skip-add-drop-table 参数完全指南"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/","level":1,"title":"SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字","text":"<p>在数据库查询中，掌握各种SQL关键字对于高效检索和处理数据至关重要。本文将详细介绍INNER JOIN、DISTINCT和HAVING这三个常用的SQL关键字，帮助你更好地理解和应用它们。</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#inner-join","level":2,"title":"INNER JOIN关键字","text":"<p>INNER JOIN关键字用于返回两个表中字段匹配关系的记录。它只返回两个表中满足连接条件的记录。</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_1","level":3,"title":"基本语法","text":"<pre><code>SELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name = table2.column_name;\n</code></pre>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_2","level":3,"title":"实例说明","text":"<p>以下示例展示了如何使用INNER JOIN获取网站名称及其访问日志：</p> <pre><code>SELECT Websites.name, access_log.count, access_log.date\nFROM Websites\nINNER JOIN access_log\nON Websites.id = access_log.site_id\nORDER BY access_log.count;\n</code></pre> <p>在这个例子中： - <code>Websites</code>和<code>access_log</code>是两个要连接的表 - <code>ON Websites.id = access_log.site_id</code>是连接条件 - 结果集包含两个表中满足连接条件的所有记录</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#onwhere","level":2,"title":"ON和WHERE的区别","text":"<p>在SQL查询中，ON和WHERE子句都用于过滤数据，但它们的作用时机和目的不同：</p> <ul> <li>ON子句：在生成临时表时就会进行条件对比，用于确定哪些记录应该被连接</li> <li>WHERE子句：在临时表生成之后再进行过滤，用于进一步筛选结果</li> </ul> <p>理解这个区别有助于优化查询性能和获得预期的结果。</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#select-distinct","level":2,"title":"SELECT DISTINCT语句","text":"<p>在实际的数据表中，一个列可能会包含多个重复值。当我们只需要列出不同的值时，可以使用DISTINCT关键字。</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_3","level":3,"title":"基本语法","text":"<pre><code>SELECT DISTINCT column_name\nFROM table_name;\n</code></pre>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_4","level":3,"title":"实例说明","text":"<p>以下示例展示了如何使用DISTINCT获取不重复的部门名称：</p> <pre><code>SELECT DISTINCT adep\nFROM ATHLETE;\n</code></pre> <p>如果需要结合聚合函数使用DISTINCT，可以参考以下示例：</p> <pre><code>SELECT adep, SUM(score) \nFROM ATHLETE\nINNER JOIN SCORE\nON ATHLETE.Aneo = SCORE.Aneo\nGROUP BY adep;\n</code></pre>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#having","level":2,"title":"HAVING关键字","text":"<p>WHERE关键字无法与聚合函数一起使用，而HAVING关键字正是为了解决这个问题。HAVING子句用于过滤分组后的结果。</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_5","level":3,"title":"基本语法","text":"<pre><code>SELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE column_name operator value\nGROUP BY column_name\nHAVING aggregate_function(column_name) operator value;\n</code></pre>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_6","level":3,"title":"实例说明","text":"<p>以下示例展示了如何使用HAVING筛选总访问量超过200的网站：</p> <pre><code>SELECT Websites.name, SUM(access_log.count) AS total_access\nFROM Websites\nINNER JOIN access_log\nON Websites.id = access_log.site_id\nGROUP BY Websites.name\nHAVING SUM(access_log.count) &gt; 200\nORDER BY total_access DESC;\n</code></pre> <p>在这个例子中： - 使用<code>GROUP BY</code>按网站名称分组 - 使用<code>HAVING</code>筛选总访问量超过200的记录 - 最终结果按照总访问量降序排列</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SELECT%20DISTINCT%20%E8%AF%AD%E5%8F%A5/#_7","level":2,"title":"总结","text":"<p>通过掌握INNER JOIN、DISTINCT和HAVING这些关键字，我们可以更灵活地处理数据库查询需求：</p> <ul> <li>使用INNER JOIN连接多个表获取关联数据</li> <li>使用DISTINCT去除重复记录获取唯一值</li> <li>使用HAVING对分组后的数据进行筛选</li> </ul> <p>合理运用这些关键字能够显著提升SQL查询的效率和准确性。</p>","path":["DB","SQL学习：掌握INNER JOIN、DISTINCT和HAVING关键字"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","level":1,"title":"SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作","text":"<p>在数据库设计中，一对多关系是一种常见的关系类型。在这种关系中，\"一\"的一方可以关联到\"多\"的一方的多个记录，但\"多\"的一方只能关联到\"一\"的一方的一个记录。</p> <p>例如，在城市和国家的模型中，一个国家可以有多个城市，但一个城市只能属于一个国家。在这种情况下，国家是\"一\"的一方，城市是\"多\"的一方。</p> <p>在\"一\"类中添加一个关系属性作为集合属性。当调用这个属性时返回所有相关的对象。</p> <p>比如城市和国家模型。</p> <pre><code># 定义City模型类，继承自db.Model\n# 这个类映射到数据库中的city表\n# 每个城市都属于一个国家，通过外键nation_id关联\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一条记录\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示城市名称在数据库中不能重复\n    name = db.Column(db.String(50), unique=True)\n\n# 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\n# 每个国家可以拥有多个城市\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n</code></pre> <p>需要实现一个国家对应多个城市。</p>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_1","level":4,"title":"建立一对多关系","text":"<p>第一步: </p> <p>在\"多\"的一侧创建外键。</p> <pre><code># 定义City模型类，继承自db.Model\n# 这个类映射到数据库中的city表\n# 每个城市都属于一个国家，通过外键nation_id关联\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一条记录\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示城市名称在数据库中不能重复\n    name = db.Column(db.String(50), unique=True)\n    # 外键指向nation表的id字段\n    # db.ForeignKey('nation.id')指定外键约束，关联到nation表的id字段\n    # 通过这个外键，建立了城市到国家的多对一关系\n    nation_id = db.Column(db.Integer, db.ForeignKey('nation.id'))\n    # 需要注意的是nation.id,表名是小写(因为SQLAlchemy生成的表默认为类名称的小写形式)\n</code></pre> <p>第二步:</p> <p>在\"一\"的一侧定义关系属性。(集合关系属性,列表)</p> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\n# 每个国家可以拥有多个城市\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 定义一对多关系，一个国家可以有多个城市\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # 通过cities属性可以访问该国家的所有城市\n    cities = db.relationship('City', backref='nation')\n</code></pre>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#nationcitiessqlalchemycitynation_idcitynation_idnationid","level":1,"title":"当关系属性<code>nation.cities</code>被调用时,SQLAlchemy会找到<code>city表</code>的外键字段(<code>nation_id</code>)。然后查询<code>city表</code>中<code>nation_id</code>为当前主键值(<code>nation.id</code>)的记录,返回包含这些记录的列表。","text":"<p>需要注意的是,使用关系函数定义的集合关系属性不是数据库字段,而是一个查询函数。所以返回值并不固定,而是根据查询结果动态变化。</p>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#relationship","level":4,"title":"relationship函数常用参数说明","text":"<p><code>relationship</code>函数有许多参数可以用来定制关系的行为，以下是几个常用的参数：</p> <ol> <li><code>backref</code>参数：在一对多关系中，可以在\"一\"的一侧使用<code>backref</code>参数自动在\"多\"的一侧创建反向引用。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用backref参数创建双向关系\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # 通过cities属性可以访问该国家的所有城市\n    cities = db.relationship('City', backref='nation')\n</code></pre> <p>这样，在<code>City</code>模型中就自动有了一个<code>nation</code>属性，可以直接访问该城市的所属国家。</p> <ol> <li><code>lazy</code>参数：控制关联对象的加载方式。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用lazy参数控制加载方式\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # lazy='select'指定加载方式为select模式（默认）\n    # select模式会在访问cities属性时发出新的SELECT语句加载数据\n    cities = db.relationship('City', backref='nation', lazy='select')\n</code></pre> <ol> <li><code>cascade</code>参数：控制级联操作行为。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用cascade参数控制级联操作\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # cascade='all, delete-orphan'指定级联操作为全部操作，并删除孤儿对象\n    # 当删除国家时，所有关联的城市也会被删除\n    # 当城市不再关联到任何国家时，城市记录也会被删除\n    cities = db.relationship('City', backref='nation', cascade='all, delete-orphan')\n</code></pre>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_2","level":4,"title":"创建和使用对象","text":"<p>创建国家和城市对象：</p> <pre><code># 创建国家对象，nation_name属性设置为'中国'\n# 这会创建一个新的Nation实例，但尚未保存到数据库\nchina = Nation(nation_name='中国')\n# 创建国家对象，nation_name属性设置为'美国'\n# 这会创建另一个Nation实例，同样尚未保存到数据库\nusa = Nation(nation_name='美国')\n\n# 将china对象添加到数据库会话中\n# db.session.add()将对象标记为待插入状态\n# 此时对象还未真正写入数据库\n# 只有在commit()之后才会真正保存到数据库\ndb.session.add(china)\n# 将usa对象添加到数据库会话中\ndb.session.add(usa)\n# 提交会话，将国家对象保存到数据库\n# db.session.commit()会执行所有待处理的数据库操作\ndb.session.commit()\n\n# 创建城市对象，name属性设置为'北京'，通过nation参数直接关联到china对象\n# 在创建时直接建立与国家的关联关系\nbeijing = City(name='北京', nation=china)\n# 创建城市对象，name属性设置为'上海'，通过nation参数直接关联到china对象\nshanghai = City(name='上海', nation=china)\n# 创建城市对象，name属性设置为'纽约'，通过nation参数直接关联到usa对象\nnew_york = City(name='纽约', nation=usa)\n\n# 将beijing对象添加到数据库会话中\ndb.session.add(beijing)\n# 将shanghai对象添加到数据库会话中\ndb.session.add(shanghai)\n# 将new_york对象添加到数据库会话中\ndb.session.add(new_york)\n# 提交会话，将城市对象保存到数据库\ndb.session.commit()\n</code></pre>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_3","level":4,"title":"查询关系数据","text":"<p>通过关系属性查询数据：</p> <pre><code># 通过Nation模型查询nation_name为'中国'的国家对象，返回第一个匹配的结果\n# filter_by()方法用于筛选符合条件的记录\n# first()方法返回查询结果的第一条记录，如果没有则返回None\nchina = Nation.query.filter_by(nation_name='中国').first()\n# 打印国家名称\nprint(f\"{china.nation_name}的城市有:\")\n# 遍历china对象的cities关系属性，获取所有关联的城市对象\n# cities是由relationship定义的关系属性，返回一个城市对象列表\nfor city in china.cities:\n    # 打印城市名称\n    print(f\"- {city.name}\")\n\n# 通过City模型查询name为'北京'的城市对象，返回第一个匹配的结果\nbeijing = City.query.filter_by(name='北京').first()\n# 通过beijing对象的nation属性（由backref自动创建）获取关联的国家对象，并打印信息\n# nation属性是由backref='nation'自动创建的反向引用属性\nprint(f\"{beijing.name}属于{beijing.nation.nation_name}\")\n</code></pre>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_4","level":4,"title":"建立关系","text":"<p>1.直接通过外键字段赋值。</p> <pre><code># 直接为city对象的nation_id外键字段赋值，关联到ID为1的国家\n# 这是最直接的方式，通过设置外键字段的值来建立关系\ncity.nation_id = 1\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre> <p>2.通过关系属性添加</p> <pre><code># 通过nation对象的cities关系属性添加beijing城市对象到城市列表中\n# append()方法会将beijing对象添加到关联的城市列表中\n# 同时会自动设置beijing对象的nation_id外键字段\nnation.cities.append(beijing)\n# beijing为City对象\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre> <p>3.直接将一个对象列表赋值给关系属性</p> <pre><code># 直接将包含beijing和shanghai对象的列表赋值给nation对象的cities关系属性\n# 这种方式会替换原有的所有关联关系\n# 如果原来有关联的城市，会被移除；如果beijing或shanghai原来关联到其他国家，也会被断开\nnation.cities = [beijing, shanghai]\n# beijing和shanghai均为对象\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_5","level":4,"title":"建立双向关系","text":"<p>通过在<code>relationship</code>中使用<code>backref</code>参数，我们已经建立了双向关系：</p> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 定义一对多关系，backref参数自动在City模型中创建nation属性\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # 通过cities属性可以访问该国家的所有城市\ncities = db.relationship('City', backref='nation')\n\n# 定义City模型类，继承自db.Model\n# 这个类映射到数据库中的city表\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    name = db.Column(db.String(50), unique=True)\n    # 外键指向nation表的id字段\n    # db.ForeignKey('nation.id')指定外键约束，关联到nation表的id字段\n    # 通过这个外键，建立了城市到国家的多对一关系\n    nation_id = db.Column(db.Integer, db.ForeignKey('nation.id'))\n</code></pre> <p>这样就建立了双向关系： - 通过<code>nation.cities</code>可以获取该国家的所有城市 - 通过<code>city.nation</code>可以获取该城市所属的国家</p> <p>下面是一对多关系操作的流程图：</p> <pre><code>graph LR\n    A[定义模型类] --&gt; B{是否包含外键}\n    B --&gt;|是| C[多的一方]\n    B --&gt;|否| D[一的一方]\n    C --&gt; E[添加nation_id外键字段]\n    D --&gt; F[添加relationship关系属性]\n    E --&gt; G[创建对象实例]\n    F --&gt; G\n    G --&gt; H{如何建立关系}\n    H --&gt; I[直接赋值外键]\n    H --&gt; J[通过关系属性append]\n    H --&gt; K[直接赋值对象列表]\n    I --&gt; L[查询数据]\n    J --&gt; L\n    K --&gt; L\n    L --&gt; M[通过cities访问城市]\n    L --&gt; N[通过nation访问国家]</code></pre> <p>使用示例：</p> <pre><code># 通过Nation模型查询nation_name为'中国'的国家对象，返回第一个匹配的结果\n# filter_by()方法用于筛选符合条件的记录\n# first()方法返回查询结果的第一条记录，如果没有则返回None\nchina = Nation.query.filter_by(nation_name='中国').first()\n# 打印国家名称\nprint(f\"{china.nation_name}的城市有:\")\n# 遍历china对象的cities关系属性，获取所有关联的城市对象\n# cities是由relationship定义的关系属性，返回一个城市对象列表\nfor city in china.cities:\n    # 打印城市名称\n    print(f\"- {city.name}\")\n\n# 通过City模型查询name为'北京'的城市对象，返回第一个匹配的结果\nbeijing = City.query.filter_by(name='北京').first()\n# 通过beijing对象的nation属性（由backref自动创建）获取关联的国家对象，并打印信息\n# nation属性是由backref='nation'自动创建的反向引用属性\nprint(f\"{beijing.name}属于{beijing.nation.nation_name}\")\n</code></pre>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_6","level":2,"title":"核心要点总结","text":"<ul> <li>一对多关系：\"一\"的一方可以关联\"多\"的一方的多个记录，\"多\"的一方只能关联\"一\"的一方的一个记录，这是数据库设计中最常见的关系类型之一</li> <li>外键：在\"多\"的一侧创建，指向\"一\"的一侧的主键，通过外键约束建立数据关联，确保数据完整性</li> <li>relationship函数：在\"一\"的一侧定义，用于建立对象间的关系，这是一个查询函数而非数据库字段，返回值根据查询结果动态变化</li> <li>backref参数：最佳实践，自动在\"多\"的一侧创建反向引用，实现双向关系访问，简化代码编写</li> <li>lazy参数：最佳实践，控制关联对象加载方式，包括select、joined、subquery、dynamic等模式，可根据性能需求选择合适的加载策略</li> <li>cascade参数：最佳实践，控制级联操作行为，如save-update、delete、all、delete-orphan等，确保数据一致性和完整性</li> <li>关系建立方式：可以通过直接赋值外键字段、通过关系属性append方法、或直接赋值对象列表三种方式建立一对多关系</li> <li>数据查询：通过关系属性可以方便地访问关联数据，支持正向查询（从一到多）和反向查询（从多到一）</li> </ul>","path":["DB","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/","level":1,"title":"SQLAlchemy一对多关系详解与实现","text":"<p>在数据库设计中，一对多关系是一种常见的关系类型。在这种关系中，\"一\"的一方可以关联到\"多\"的一方的多个记录，但\"多\"的一方只能关联到\"一\"的一方的一个记录。</p> <p>例如，在城市和国家的模型中，一个国家可以有多个城市，但一个城市只能属于一个国家。在这种情况下，国家是\"一\"的一方，城市是\"多\"的一方。</p> <p>在\"一\"类中添加一个关系属性作为集合属性。当调用这个属性时返回所有相关的对象。</p> <p>比如城市和国家模型。</p> <pre><code># 定义City模型类，继承自db.Model\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    name = db.Column(db.String(50), unique=True)\n\n# 定义Nation模型类，继承自db.Model\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n</code></pre> <p>需要实现一个国家对应多个城市。</p>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_1","level":4,"title":"建立一对多关系","text":"<p>第一步: </p> <p>在\"多\"的一侧创建外键。</p> <pre><code># 定义City模型类，继承自db.Model\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    name = db.Column(db.String(50), unique=True)\n    # 外键指向nation表的id字段\n    # db.ForeignKey('nation.id')指定外键约束，关联到nation表的id字段\n    nation_id = db.Column(db.Integer, db.ForeignKey('nation.id'))\n    # 需要注意的是nation.id,表名是小写(因为SQLAlchemy生成的表默认为类名称的小写形式)\n</code></pre> <p>第二步:</p> <p>在\"一\"的一侧定义关系属性。(集合关系属性,列表)</p> <pre><code># 定义Nation模型类，继承自db.Model\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 定义一对多关系，一个国家可以有多个城市\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    cities = db.relationship('City', backref='nation')\n</code></pre> <p>当关系属性<code>nation.cities</code>被调用时,SQLAlchemy会找到<code>city表</code>的外键字段(<code>nation_id</code>)。然后查询<code>city表</code>中<code>nation_id</code>为当前主键值(<code>nation.id</code>)的记录,返回包含这些记录的列表。</p> <p>需要注意的是,使用关系函数定义的集合关系属性不是数据库字段,而是一个查询函数。所以返回值并不固定,而是根据查询结果动态变化。</p>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_2","level":4,"title":"一对多关系结构图","text":"<pre><code>graph LR\n    A[Nation&lt;br/&gt;国家表] -- 一对多 --&gt; B[City&lt;br/&gt;城市表]\n    A -- 主键 --&gt; A1[id]\n    B -- 外键 --&gt; B1[nation_id]\n    B -- 主键 --&gt; B2[id]\n    A1 -.-&gt;|关联| B1</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#relationship","level":4,"title":"relationship函数常用参数说明","text":"<p><code>relationship</code>函数有许多参数可以用来定制关系的行为，以下是几个常用的参数：</p> <ol> <li><code>backref</code>参数：在一对多关系中，可以在\"一\"的一侧使用<code>backref</code>参数自动在\"多\"的一侧创建反向引用。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用backref参数创建双向关系\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    cities = db.relationship('City', backref='nation')\n</code></pre> <p>这样，在<code>City</code>模型中就自动有了一个<code>nation</code>属性，可以直接访问该城市的所属国家。</p> <ol> <li><code>lazy</code>参数：控制关联对象的加载方式。</li> <li><code>select</code>（默认值）：在访问属性时发出新的SELECT语句加载数据</li> <li><code>joined</code>：使用JOIN语句加载数据</li> <li><code>subquery</code>：使用子查询加载数据</li> <li><code>dynamic</code>：返回一个查询对象，允许进一步过滤</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用lazy参数控制加载方式\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # lazy='select'指定加载方式为select模式（默认）\n    cities = db.relationship('City', backref='nation', lazy='select')\n</code></pre> <ol> <li><code>cascade</code>参数：控制级联操作行为。</li> <li><code>save-update</code>：默认选项，保存或更新父对象时也会保存或更新子对象</li> <li><code>delete</code>：删除父对象时也删除子对象</li> <li><code>all</code>：应用所有级联选项</li> <li><code>delete-orphan</code>：删除孤立对象（当子对象不再关联到父对象时）</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用cascade参数控制级联操作\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # cascade='all, delete-orphan'指定级联操作为全部操作，并删除孤儿对象\n    cities = db.relationship('City', backref='nation', cascade='all, delete-orphan')\n</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_3","level":4,"title":"创建和使用对象","text":"<p>创建国家和城市对象：</p> <pre><code># 创建国家对象，nation_name属性设置为'中国'\nchina = Nation(nation_name='中国')\n# 创建国家对象，nation_name属性设置为'美国'\nusa = Nation(nation_name='美国')\n\n# 将china对象添加到数据库会话中\ndb.session.add(china)\n# 将usa对象添加到数据库会话中\ndb.session.add(usa)\n# 提交会话，将国家对象保存到数据库\ndb.session.commit()\n\n# 创建城市对象，name属性设置为'北京'，通过nation参数直接关联到china对象\nbeijing = City(name='北京', nation=china)\n# 创建城市对象，name属性设置为'上海'，通过nation参数直接关联到china对象\nshanghai = City(name='上海', nation=china)\n# 创建城市对象，name属性设置为'纽约'，通过nation参数直接关联到usa对象\nnew_york = City(name='纽约', nation=usa)\n\n# 将beijing对象添加到数据库会话中\ndb.session.add(beijing)\n# 将shanghai对象添加到数据库会话中\ndb.session.add(shanghai)\n# 将new_york对象添加到数据库会话中\ndb.session.add(new_york)\n# 提交会话，将城市对象保存到数据库\ndb.session.commit()\n</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_4","level":4,"title":"查询关系数据","text":"<p>通过关系属性查询数据：</p> <pre><code># 通过Nation模型查询nation_name为'中国'的国家对象，返回第一个匹配的结果\nchina = Nation.query.filter_by(nation_name='中国').first()\n# 打印国家名称\nprint(f\"{china.nation_name}的城市有:\")\n# 遍历china对象的cities关系属性，获取所有关联的城市对象\nfor city in china.cities:\n    # 打印城市名称\n    print(f\"- {city.name}\")\n\n# 通过City模型查询name为'北京'的城市对象，返回第一个匹配的结果\nbeijing = City.query.filter_by(name='北京').first()\n# 通过beijing对象的nation属性（由backref自动创建）获取关联的国家对象，并打印信息\nprint(f\"{beijing.name}属于{beijing.nation.nation_name}\")\n</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_5","level":4,"title":"建立关系","text":"<p>1.直接通过外键字段赋值。</p> <pre><code># 直接为city对象的nation_id外键字段赋值，关联到ID为1的国家\ncity.nation_id = 1\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre> <p>2.通过关系属性添加</p> <pre><code># 通过nation对象的cities关系属性添加beijing城市对象到城市列表中\nnation.cities.append(beijing)\n# beijing为City对象\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre> <p>3.直接将一个对象列表赋值给关系属性</p> <pre><code># 直接将包含beijing和shanghai对象的列表赋值给nation对象的cities关系属性\nnation.cities = [beijing, shanghai]\n# beijing和shanghai均为对象\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_6","level":4,"title":"建立双向关系","text":"<p>通过在<code>relationship</code>中使用<code>backref</code>参数，我们已经建立了双向关系：</p> <pre><code># 定义Nation模型类，继承自db.Model\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 定义一对多关系，backref参数自动在City模型中创建nation属性\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    cities = db.relationship('City', backref='nation')\n\n# 定义City模型类，继承自db.Model\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    name = db.Column(db.String(50), unique=True)\n    # 外键指向nation表的id字段\n    # db.ForeignKey('nation.id')指定外键约束，关联到nation表的id字段\n    nation_id = db.Column(db.Integer, db.ForeignKey('nation.id'))\n</code></pre> <p>这样就建立了双向关系： - 通过<code>nation.cities</code>可以获取该国家的所有城市 - 通过<code>city.nation</code>可以获取该城市所属的国家</p> <p>使用示例：</p> <pre><code># 通过Nation模型查询nation_name为'中国'的国家对象，返回第一个匹配的结果\nchina = Nation.query.filter_by(nation_name='中国').first()\n# 打印国家名称\nprint(f\"{china.nation_name}的城市有:\")\n# 遍历china对象的cities关系属性，获取所有关联的城市对象\nfor city in china.cities:\n    # 打印城市名称\n    print(f\"- {city.name}\")\n\n# 通过City模型查询name为'北京'的城市对象，返回第一个匹配的结果\nbeijing = City.query.filter_by(name='北京').first()\n# 通过beijing对象的nation属性（由backref自动创建）获取关联的国家对象，并打印信息\nprint(f\"{beijing.name}属于{beijing.nation.nation_name}\")\n</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_7","level":4,"title":"双向关系访问流程图","text":"<pre><code>graph LR\n    A[Nation对象] -- cities属性 --&gt; B[City对象列表]\n    B -- nation属性 --&gt; A\n    A -- 查询 --&gt; C[数据库Nation表]\n    B -- 查询 --&gt; D[数据库City表]</code></pre>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"DB/SQLAlchemy%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/#_8","level":2,"title":"核心要点总结","text":"<ul> <li>一对多关系：一的一方可以关联多的一方的多个记录，多的一方只能关联一的一方的一个记录</li> <li>外键：在多的一侧创建，指向一的一侧的主键，建立数据关联</li> <li>relationship函数：在一的一侧定义，用于建立对象间的关系，非数据库字段</li> <li>backref参数：最佳实践，自动在多的一侧创建反向引用，实现双向关系</li> <li>lazy参数：最佳实践，控制关联对象加载方式，优化查询性能</li> <li>cascade参数：最佳实践，控制级联操作行为，确保数据一致性</li> </ul>","path":["DB","SQLAlchemy一对多关系详解与实现"],"tags":[]},{"location":"Mac/Mac%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","level":1,"title":"Mac 的一些小技巧","text":"<ul> <li> <p>通过Command+点击在新窗口中打开Finder侧边栏上的项目</p> </li> <li> <p>Command+鼠标拖拽可以移动后方的窗口，同时不影响前端窗口</p> </li> <li> <p>Command+点击Dock上的图标可以打开应用在Finder中的位置</p> </li> <li> <p>Command+回车Spotlight中的搜索结果可以直接在Finder中查看</p> </li> <li> <p>Command+回车Spotlight中的搜索结果可以直接在Finder中查看</p> </li> </ul>","path":["Mac","Mac 的一些小技巧"],"tags":[]},{"location":"Mac/youtube%E4%B8%8B%E8%BD%BD/","level":1,"title":"Youtube下载","text":"<p>youtube 上有很多不错的视频,奈何超清画质不能下载,所以琢磨了琢磨 youtube-dl, 用来下载 youtube 的视频.</p> <p>据说也可以下载优酷,土豆之类的.</p> <p>使用 youtube-dl 进行下载, youtube-dl 自动调用 FFmpeg 进行音频和视频的合并.</p> <p>在 zsh 内部写了别名,</p> <p>所以直接在终端中使用 youtube +要下载视频的 URL, 就能下载到 影片文件夹.</p> <p>默认下载分辨率最高的资源.</p> <p></p>","path":["Mac","Youtube下载"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/","level":1,"title":"Flask配置文件相关","text":"","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#flask","level":2,"title":"Flask配置管理基础","text":"<p>Flask的配置系统实际上是一个字典的子类，能够像字典一样被修改和访问。配置对象用于存储各种应用设置，如数据库连接字符串、密钥和其他环境特定的配置。</p> <pre><code>app = Flask(__name__)\napp.config['TESTING'] = True\n</code></pre> <p>某些配置值也会被转发到Flask对象上，因此您可以直接从那里读取和写入：</p> <pre><code>app.testing = True\n</code></pre> <p>要一次更新多个键，可以使用dict.update()方法：</p> <pre><code>app.config.update(\n    TESTING=True,\n    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n)\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#flask-2025","level":2,"title":"现代Flask配置管理最佳实践 (2025年)","text":"","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#1","level":3,"title":"1. 使用配置类和继承模式","text":"<p>现代Flask应用推荐使用类和继承的方式来组织配置，这样可以更好地管理不同环境的配置：</p> <pre><code>import os\nfrom datetime import timedelta\n\nclass Config:\n    \"\"\"基础配置类\"\"\"\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard-to-guess-string'\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    PERMANENT_SESSION_LIFETIME = timedelta(days=7)\n\n    @staticmethod\n    def init_app(app):\n        pass\n\nclass DevelopmentConfig(Config):\n    \"\"\"开发环境配置\"\"\"\n    DEBUG = True\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(os.path.dirname(__file__), 'data-dev.sqlite')\n\nclass TestingConfig(Config):\n    \"\"\"测试环境配置\"\"\"\n    TESTING = True\n    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or 'sqlite://'\n    WTF_CSRF_ENABLED = False\n\nclass ProductionConfig(Config):\n    \"\"\"生产环境配置\"\"\"\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(os.path.dirname(__file__), 'data.sqlite')\n\n    @classmethod\n    def init_app(cls, app):\n        Config.init_app(app)\n\n        # 在生产环境中进行额外的初始化\n        import logging\n        from logging.handlers import SysLogHandler\n        syslog_handler = SysLogHandler()\n        syslog_handler.setLevel(logging.WARNING)\n        app.logger.addHandler(syslog_handler)\n\n# 配置字典，便于选择不同的配置\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#2-python-dotenv","level":3,"title":"2. 使用环境变量和python-dotenv","text":"<p>为了安全地管理敏感信息（如密钥、密码），推荐使用环境变量和<code>python-dotenv</code>库：</p> <p>首先安装python-dotenv： <pre><code>pip install python-dotenv\n</code></pre></p> <p>创建一个.env文件来存储环境变量（注意：此文件不应提交到版本控制系统）： <pre><code>SECRET_KEY=your-secret-key-here\nDATABASE_URL=postgresql://user:password@localhost/dbname\nMAIL_SERVER=smtp.googlemail.com\nMAIL_PORT=587\nMAIL_USE_TLS=True\nMAIL_USERNAME=your-email@gmail.com\nMAIL_PASSWORD=your-password\n</code></pre></p> <p>在应用中加载环境变量： <pre><code># 在应用初始化时加载环境变量\nfrom dotenv import load_dotenv\nimport os\n\n# 加载.env文件中的环境变量\nload_dotenv()\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard-to-guess-string'\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'app.db')\n</code></pre></p>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#3","level":3,"title":"3. 应用工厂模式","text":"<p>现代Flask应用推荐使用应用工厂模式来创建应用实例，这使得配置更加灵活：</p> <pre><code>from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom config import config\n\ndb = SQLAlchemy()\n\ndef create_app(config_name):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)\n\n    db.init_app(app)\n\n    # 注册蓝图\n    from .main import main as main_blueprint\n    app.register_blueprint(main_blueprint)\n\n    from .auth import auth as auth_blueprint\n    app.register_blueprint(auth_blueprint, url_prefix='/auth')\n\n    return app\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#4","level":3,"title":"4. 不同的配置加载方法","text":"<p>Flask提供了多种加载配置的方法：</p>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#_1","level":4,"title":"从对象加载配置","text":"<pre><code>app.config.from_object('config.ProductionConfig')\n# 或者\napp.config.from_object(ProductionConfig)\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#python","level":4,"title":"从Python文件加载配置","text":"<pre><code>app.config.from_pyfile('config.py')\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#_2","level":4,"title":"从环境变量加载配置（带前缀）","text":"<pre><code># 只加载以MYAPP_开头的环境变量\napp.config.from_prefixed_env(prefix='MYAPP')\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#_3","level":4,"title":"从映射对象加载配置","text":"<pre><code>config_dict = {\n    'DEBUG': True,\n    'SECRET_KEY': 'my-secret-key'\n}\napp.config.from_mapping(config_dict)\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#5","level":3,"title":"5. 调试模式的正确设置","text":"<p>DEBUG配置值比较特殊，如果在应用开始设置后更改，可能会出现不一致的行为。为了可靠地设置调试模式，请在运行应用时使用<code>--debug</code>选项：</p> <pre><code>flask --app hello run --debug\n</code></pre>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#6","level":3,"title":"6. 安全注意事项","text":"<ol> <li>永远不要在代码中硬编码敏感信息</li> <li>使用环境变量存储密钥和密码</li> <li>确保.env文件不被提交到版本控制系统</li> <li>在生产环境中禁用调试模式</li> <li>定期轮换密钥</li> </ol>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flaks%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/#7","level":3,"title":"7. 配置管理的最佳实践","text":"<ol> <li>分离关注点：将配置与应用程序逻辑分开</li> <li>环境适配：为不同环境（开发、测试、生产）轻松切换配置</li> <li>集中管理：将所有配置设置放在一个地方以便于管理</li> <li>默认值：为配置提供合理的默认值以防缺失</li> <li>验证：在可能的情况下验证配置值的有效性</li> </ol>","path":["Python","Flask配置文件相关"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/","level":1,"title":"Flask端点与蓝图详解","text":"<p>title: Flask端点与蓝图详解</p> <p>Date: 2020/10/30 20:22</p> <p>tags: Flask</p> <p>categories: Flask</p>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/#endpoint","level":2,"title":"端点(endpoint)","text":"<p>端点(Endpoint)是URL规则(rule)和视图函数(view_func)的中间媒介。它是Flask路由系统的核心概念，用于解耦URL与视图函数之间的直接绑定关系，提供更大的灵活性和可扩展性。</p> <pre><code>graph LR\nURL[URL请求] --&gt; Endpoint[端点]\nEndpoint --&gt; ViewFunc[视图函数]\nstyle URL fill:#FFE4C4,stroke:#333\nstyle Endpoint fill:#DDA0DD,stroke:#333\nstyle ViewFunc fill:#98FB98,stroke:#333</code></pre> <p>比如</p> <pre><code># 使用装饰器方式定义路由\n# @app.route()装饰器是Flask提供的便捷方式，用于将URL规则与视图函数关联\n@app.route('/index')\ndef index():\n  # 视图函数返回简单的问候语\n  return 'hello,world'\n\n# 等效于使用add_url_rule方法手动添加URL规则\n# 这种方式更直观地展示了Flask路由系统的底层实现机制\ndef index():\n  # 视图函数返回简单的问候语\n  return 'hello,world'\n# add_url_rule(rule, endpoint, view_func)方法参数说明：\n# rule: URL路径规则，定义了访问该视图函数的URL路径\n# endpoint: 端点名称，默认为视图函数名，用于唯一标识视图函数\n# view_func: 处理该URL的视图函数，负责生成HTTP响应\napp.add_url_rule('/index', 'index', index)\n</code></pre> <p>默认情况下,端点(Endpoint)是视图函数(View Function)的名字。这种设计使得Flask可以通过端点名称唯一标识每个视图函数，无论它们位于哪个模块或蓝图中。</p> <p>开发者也可以显式地更改端点名称，以满足特定的命名需求或避免命名冲突。</p> <pre><code># 显式指定端点名称为'index2'，而不是使用默认的函数名\n# 通过endpoint参数可以自定义端点名称，用于解决命名冲突或满足特定需求\n@app.route('/', endpoint='index2')\ndef index():\n  # 视图函数的具体实现\n  pass\n</code></pre>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/#view_functionsurl_map","level":2,"title":"端点,view_functions,url_map","text":"<p>在每个Flask应用程序对象(app)中都有两个重要的属性与端点机制相关：</p> <p>在view_functions中存储着<code>端点名称(endpoint) → 视图函数(view_func)</code>的键值对映射关系。</p> <p>在url_map中存储着URL规则和端点名称的映射关系。</p> <p>这两个核心数据结构均由<code>add_url_rule</code>方法进行维护和更新，构成了Flask路由系统的基础架构。</p> <pre><code># 导入Flask类\nfrom flask import Flask\n\n# 创建Flask应用实例\napp = Flask(__name__)\n\n# 定义根路径的视图函数\n# 该路由将'/'路径映射到index视图函数，端点名称默认为'index'\n@app.route('/')\ndef index():\n    # 返回简单的文本响应\n    return 'index'\n\n# 定义/hello路径的视图函数\n# 该路由将'/hello'路径映射到hello视图函数，端点名称默认为'hello'\n@app.route('/hello')\ndef hello():\n    # 返回简单的文本响应\n    return 'hello'\n\n# 应用启动入口\nif __name__ == '__main__':\n    # 打印view_functions字典，显示端点与视图函数的映射关系\n    # 格式：{'端点名称': 视图函数对象}\n    print('View Functions:')\n    print(app.view_functions)\n    print('------------')\n    # 打印url_map对象，显示URL规则与端点的映射关系\n    # 格式：Map([Rule对象列表])，每个Rule对象包含URL规则和对应的端点\n    print('URL Map:')\n    print(app.url_map)\n    # 启动Flask开发服务器\n    app.run(host='localhost', port=5004)\n</code></pre> <p>输出:</p> <pre><code>{'static': &lt;bound method _PackageBoundObject.send_static_file of &lt;Flask 'test'&gt;&gt;, \n 'index': &lt;function index at 0x104db2310&gt;, 'hello': &lt;function hello at 0x105ae4160&gt;}\n------------\nMap([&lt;Rule '/hello' (HEAD, GET, OPTIONS) -&gt; hello&gt;,\n &lt;Rule '/' (HEAD, GET, OPTIONS) -&gt; index&gt;,\n &lt;Rule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;])\n</code></pre> <p>所以当一个HTTP请求进入时，Flask会按照以下流程处理：</p> <ol> <li>首先通过URL规则(Rule)在url_map中查找对应的端点名称(endpoint)</li> <li>然后根据端点名称在view_functions中查找对应的视图函数(view_func)</li> <li>最终执行找到的视图函数并返回响应结果</li> </ol> <p>这种两阶段查找机制解耦了URL与视图函数之间的直接绑定关系，提供了更大的灵活性。</p> <pre><code>graph TD\nA[Flask应用] --&gt; B[url_map]\nA --&gt; C[view_functions]\nB --&gt; D[URL ↔ 端点映射]\nC --&gt; E[端点 ↔ 视图函数映射]\nstyle A fill:#FFE4C4,stroke:#333\nstyle B fill:#DDA0DD,stroke:#333\nstyle C fill:#DDA0DD,stroke:#333\nstyle D fill:#98FB98,stroke:#333\nstyle E fill:#98FB98,stroke:#333</code></pre> <p>这个图表清晰地展示了Flask路由系统的核心工作机制：</p> <ol> <li>url_map负责维护URL规则与端点名称之间的映射关系</li> <li>view_functions负责维护端点名称与视图函数之间的映射关系</li> <li>通过这两层映射关系，实现了URL与视图函数的解耦</li> </ol>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/#_1","level":2,"title":"蓝图和端点","text":"<p>当使用蓝图时,端点会变成<code>'&lt;font color=orange&gt;**蓝图名.视图函数名**&lt;/font&gt;'</code>.</p> <p>蓝图(Blueprint)是Flask提供的一个重要特性，它可以将一系列相关的操作组织成一个集合，实现应用的模块化设计。通过蓝图，我们可以将大型应用拆分成多个小的、可重用的组件。建议在命名蓝图时添加_bp后缀，以提高代码可读性和维护性。</p> <p>最佳实践：一般情况下，建议在蓝图对象名称后添加<code>_bp</code>后缀，例如<code>user_bp</code>、<code>admin_bp</code>，这样可以在代码中快速识别出哪些是蓝图对象，提高代码可读性和维护性。</p> <p>蓝图搭配端点的设计，解释了为什么Flask要引入端点机制，而不是直接将URL规则映射到视图函数。</p> <p>蓝图搭配端点，可以实现蓝图的视图函数命名空间(namespace)，有效解决不同模块间视图函数名称冲突的问题。这是Flask模块化设计的重要最佳实践。</p> <p>比如在author_bp蓝图和post_bp蓝图中都注册了一个名为index的视图函数。当在模板中使用<code>url_for('index')</code>获取URL时会产生命名冲突，因为Flask无法确定应该使用哪个蓝图下的index视图函数。使用完整的端点名称可以解决这个问题。</p> <p>而通过<code>url_for('author_bp.index')</code>和<code>url_for('post_bp.index')</code>这种方式，能够明确指定使用哪个蓝图下的视图函数，有效避免冲突并解决视图函数的重名问题。这是处理蓝图中同名视图函数的标准方法。</p> <pre><code>graph TD\nA[Flask应用] --&gt; B[author_bp蓝图]\nA --&gt; C[post_bp蓝图]\nB --&gt; D[index视图函数&lt;br/&gt;端点:author_bp.index]\nC --&gt; E[index视图函数&lt;br/&gt;端点:post_bp.index]\nstyle A fill:#FFE4C4,stroke:#333\nstyle B fill:#DDA0DD,stroke:#333\nstyle C fill:#DDA0DD,stroke:#333\nstyle D fill:#98FB98,stroke:#333\nstyle E fill:#98FB98,stroke:#333</code></pre> <p>这个图表展示了蓝图如何通过命名空间机制解决视图函数重名问题：</p> <ol> <li>命名空间隔离：不同蓝图下的同名视图函数通过<code>蓝图名.视图函数名</code>的方式获得唯一的端点名称</li> <li>明确引用：在使用<code>url_for()</code>函数时，可以通过完整的端点名称明确指定要引用的视图函数</li> </ol>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/#url_prefix","level":2,"title":"蓝图和url_prefix","text":"<p>通过上一小节的蓝图端点命名机制，可以有效避免因视图函数名称重复而导致的端点名称冲突问题。但在实际应用中还需要考虑URL路径冲突的情况。</p> <p>但是如果url也一样该怎么办呢?</p> <p>比如author_bp和post_bp均注册了相同的url</p> <pre><code># 在author蓝图中定义根路径视图函数\n# 该视图函数在author_bp蓝图中注册，端点名称将自动变为'author_bp.index'\n@author_bp.route('/')\ndef index():\n  # 返回author相关的页面内容\n  return 'index'\n\n# 在post蓝图中也存在相同的路由，这会导致URL冲突问题\n# 该视图函数在post_bp蓝图中注册，端点名称将自动变为'post_bp.index'\n# 虽然端点名称不会冲突，但如果不在注册时添加url_prefix，URL路径会冲突\n@post_bp.route('/')\ndef index():\n  # 返回post相关的页面内容\n  return 'post'\n</code></pre> <p>如上所示，当两个蓝图都注册了相同的URL路径时，会出现URL冲突问题。虽然端点名称通过蓝图前缀避免了重名，但URL路径本身仍然会发生冲突。使用url_prefix是解决这一问题的标准方案。</p> <p>为了避免这种情况,最佳实践是在注册蓝图时填入url_prefix参数,</p> <pre><code># 创建Flask应用实例\napp = Flask(__name__)\n\n# 注册author蓝图，并添加URL前缀'/author'\n# 这样author蓝图中的所有路由都会加上'/author'前缀\n# 例如：@author_bp.route('/')会变成'/author/'路径\napp.register_blueprint(author_bp, url_prefix='/author')\n\n# 注册post蓝图，并添加URL前缀'/post'\n# 这样post蓝图中的所有路由都会加上'/post'前缀\n# 例如：@post_bp.route('/')会变成'/post/'路径\napp.register_blueprint(post_bp, url_prefix='/post')\n</code></pre> <p>通过添加URL前缀后，两者的实际访问URL变成了：</p> <pre><code># author蓝图的根路径URL\n/author/\n# post蓝图的根路径URL\n/post/\n</code></pre> <p>这样就成功解决了URL路径冲突的问题，同时保持了端点命名的清晰性。这是Flask蓝图设计中处理URL冲突的标准方法。</p>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/#_2","level":3,"title":"总结:","text":"<ol> <li>Flask请求处理流程：HTTP请求进入 → url_map匹配(URL规则与端点映射) → view_functions查找(端点与视图函数对应) → 执行视图函数并返回响应。</li> <li>蓝图端点命名机制：使用\"<code>蓝图名.视图函数名</code>\"的方式解决了不同蓝图间视图函数重名问题，扩展了视图函数命名空间。</li> <li>URL前缀机制：注册蓝图时填入<code>url_prefix</code>参数，解决了不同蓝图间URL路径冲突的问题，实现URL的层次化管理。</li> <li>命名规范建议：推荐在命名蓝图时添加<code>_bp</code>后缀，提高代码可读性和识别度。</li> </ol> <pre><code>graph TD\nA[HTTP请求] --&gt; B[url_map匹配]\nB --&gt; C[查找view_functions]\nC --&gt; D[执行视图函数]\nA --&gt; E[蓝图端点解析]\nE --&gt; F[URL前缀处理]\nstyle A fill:#FFE4C4,stroke:#333\nstyle B fill:#DDA0DD,stroke:#333\nstyle C fill:#DDA0DD,stroke:#333\nstyle D fill:#98FB98,stroke:#333\nstyle E fill:#87CEEB,stroke:#333\nstyle F fill:#87CEEB,stroke:#333</code></pre> <p>这个流程图展示了Flask处理HTTP请求的完整过程，包括蓝图端点解析和URL前缀处理等关键步骤。</p>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E7%AB%AF%E7%82%B9%E4%B8%8E%E8%93%9D%E5%9B%BE%E8%AF%A6%E8%A7%A3/#_3","level":2,"title":"核心要点总结","text":"<ol> <li> <p>端点(Endpoint)机制：端点是连接URL规则和视图函数的桥梁，默认情况下端点名就是视图函数名。这种设计解耦了URL与视图函数的直接绑定关系。</p> </li> <li> <p>Flask路由核心数据结构：Flask应用通过url_map存储URL规则与端点的映射关系，通过view_functions存储端点与视图函数的对应关系。</p> </li> <li> <p>蓝图端点命名空间：使用蓝图(Blueprint)时，端点会自动加上蓝图名前缀(<code>蓝图名.视图函数名</code>)，有效避免不同蓝图间视图函数重名问题。</p> </li> <li> <p>URL前缀管理：注册蓝图时使用url_prefix参数可以解决不同蓝图间URL路径冲突的问题，实现URL的层次化管理。</p> </li> <li> <p>请求处理完整流程：HTTP请求进入 → url_map匹配(URL规则与端点映射) → view_functions查找(端点与视图函数对应) → 执行视图函数并返回响应。</p> </li> <li> <p>蓝图命名规范：推荐为蓝图对象命名时添加_bp后缀（如user_bp），提高代码可读性和识别度。</p> </li> <li> <p>URL规则添加方式：可以通过app.add_url_rule(rule, endpoint, view_func)显式地添加URL规则，这是装饰器@app.route()的底层实现方式。</p> </li> </ol>","path":["Python","Flask端点与蓝图详解"],"tags":[]},{"location":"Python/Flask%E8%A3%85%E9%A5%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","level":1,"title":"Flask装饰器执行顺序","text":"<p>当一个函数被多个装饰器修饰时，需要注意装饰器的执行顺序问题。</p> <p>装饰器的装饰顺序是由内向外，而执行顺序则是由外向内。（这与函数和函数调用的机制有关）</p>","path":["Python","Flask装饰器执行顺序"],"tags":[]},{"location":"Python/Flask%E8%A3%85%E9%A5%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#_1","level":2,"title":"执行顺序","text":"<p>例子:</p> <pre><code>def decorator_a(func):\n  print('Get in decorator_a')\n  def inner_a(*args, **kwargs):\n    print('Get in inner_a')\n    return func(*args, **kwargs)\n  return inner_a\n\ndef decorator_b(func):\n  print('Get in decorator_b')\n  def inner_b(*args, **kwargs):\n    print('Get in inner_b')\n    return func(*args, **kwargs)\n  return inner_b\n\n@decorator_b\n@decorator_a\ndef f(x):\n  print('Get in f')\n  return x * 2\n\nf(1)\n</code></pre> <p>如果按照一般思维，可能会认为先执行decorator_a，再执行decorator_b，执行结果应该如下:</p> <pre><code>Get in decorator_a\nGet in inner_a\nGet in decorator_b\nGet in inner_b\nGet in f\n</code></pre> <p>但实际执行结果如下:</p> <pre><code>Get in decorator_a\nGet in decorator_b\nGet in inner_b\nGet in inner_a\nGet in f\n</code></pre>","path":["Python","Flask装饰器执行顺序"],"tags":[]},{"location":"Python/Flask%E8%A3%85%E9%A5%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#_2","level":2,"title":"函数和函数调用的区别","text":"<p>在解释上面的问题之前，我们可以先删除代码中的f(1)，再次运行代码，得到的结果如下：</p> <pre><code>Get in decorator_a\nGet in decorator_b\n</code></pre> <p>这引出了两个重要概念：函数和函数调用。</p> <p>在上面的代码中，f称为函数，f(1)称为函数调用，后者是对前者传入参数进行计算后的结果。</p> <p>f是一个函数对象，它本身并不会执行。f(1)才是对函数的调用，这时才会真正执行这个函数对象。</p> <p>对于decorator_b函数而言，它返回的是函数对象inner_a。</p>","path":["Python","Flask装饰器执行顺序"],"tags":[]},{"location":"Python/Flask%E8%A3%85%E9%A5%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#_3","level":2,"title":"装饰器函数在被装饰函数定义好后立即执行","text":"<p>当解释器执行到如下代码时，装饰器函数decorator_a已经被调用了，它以函数f为参数，返回了一个它内部生成的函数inner_a：</p> <pre><code>@decorator_a\ndef f(x):\n  pass\n\n# 相当于\ndef f(x):\n  pass\nf = decorator_a(f)\n</code></pre> <p>传给f的参数会传递给inner_a。在调用inner_a时，会把收到的参数传递给inner_a里的func，即经过修饰后的f。</p>","path":["Python","Flask装饰器执行顺序"],"tags":[]},{"location":"Python/Flask%E8%A3%85%E9%A5%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#_4","level":2,"title":"例子解释","text":"<p>在最开始的代码中，初始化时就已经依次调用了decorator_a和decorator_b，输出Get in decorator_a和Get in decorator_b。此时f实际上是decorator_b里的inner_b。因为f还没有被调用，所以inner_b没有执行。</p> <p>当执行f(1)时，会导致inner_b被调用，输出Get in inner_b，然后在inner_b内部执行<code>return func</code>，此处的func实际上是被decorator_a修饰过的func，所以会调用inner_a，输出Get in inner_a并返回原来f的结果。</p> <p>由于这种嵌套修饰的机制，在实际应用场景中会先验证是否已登录@login_required，再验证权限是否足够@permission_allowed。</p>","path":["Python","Flask装饰器执行顺序"],"tags":[]},{"location":"Python/Flask%E8%A3%85%E9%A5%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#route","level":2,"title":"route装饰器必须在最外层","text":"<p>正确的写法如下：</p> <pre><code>@app.route('/index', methods=['POST'])\n@login_required\ndef index():\n  pass\n</code></pre> <p>在Flask文档中有如下描述：</p> <ul> <li>To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the <code>route()</code> decorator is the outermost.</li> </ul> <p>这是因为如果route装饰器在内层，那么原始的view函数就会被直接传递给add_url_rule，从而跳过登录验证，直接指向最原始的视图函数。</p> <p>上述装饰器用法等同于：</p> <pre><code>def index():\n  pass\nindex = login_required(index)\napp.add_url_rule('/index', endpoint='index', view_func=index)\n</code></pre> <p>将route装饰器写在最外层，才能正常使用登录验证、权限设置等功能。</p>","path":["Python","Flask装饰器执行顺序"],"tags":[]},{"location":"Python/Flask%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","level":1,"title":"Flask请求钩子完全指南","text":"<p>title: Flask请求钩子完全指南：从基础概念到实际应用</p> <p>所谓请求钩子,就是在客户端与服务器交互的过程中统一处理<code>准备工作</code>或者<code>扫尾工作</code>.</p>","path":["Python","Flask请求钩子完全指南"],"tags":[]},{"location":"Python/Flask%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#app","level":3,"title":"APP层的请求钩子","text":"<p>常见的请求钩子</p> <ul> <li>before_first_request：在处理第一个请求前运行。</li> <li>before_request：在每次请求前运行。</li> <li>after_request：<sub>~如果没有未处理的异常抛出，</sub>~在每次请求后运行。</li> <li>teardown_request：在每次请求后运行，即使有未处理的异常抛出。</li> </ul> <pre><code># 从flask框架导入Flask类、url_for函数和redirect函数\n# Flask是主要的应用类，用于创建Web应用实例\n# url_for用于生成URL，redirect用于重定向\nfrom flask import Flask, url_for, redirect\n\n# 创建Flask应用实例，__name__表示当前模块名称\n# __name__作为参数传递给Flask构造函数，用于确定应用的根路径和调试模式等\napp = Flask(__name__)\n\n# 定义路由/index，当访问该路径时会触发index函数\n@app.route('/index')\ndef index():\n    # 故意制造除零异常，用于测试异常处理\n    a = 1 / 0\n    # 返回响应内容\n    return 'run index'\n\n# 定义路由/hello，当访问该路径时会触发hello函数\n@app.route('/hello')\ndef hello():\n    # 返回简单的问候语\n    return 'hello'\n\n# 注册before_first_request钩子，在处理第一个请求前运行\n# 该钩子函数只会在应用启动后接收到的第一个请求前执行一次\n# 通常用于初始化操作，如加载配置、建立数据库连接等\n@app.before_first_request\ndef b_f_r():\n    # 打印提示信息，表示第一个请求前的准备工作\n    # 这里只是简单打印信息，实际应用中可能会进行更复杂的初始化\n    print('before_first_request')\n\n# 注册before_request钩子，在每次请求前运行\n@app.before_request\ndef b_r():\n    # 打印提示信息，表示每次请求前的准备工作\n    print('before_request')\n\n# 定义路由/handel_request，当访问该路径时会触发handel_request函数\n@app.route('/handel_request')\ndef handel_request():\n    # 打印处理请求的信息\n    print('处理请求')\n    # 打印重定向信息\n    print('重定向到/h路径,测试404界面')\n    # 重定向到不存在的/h路径，用于测试404页面\n    return redirect('/h')\n\n# 注册after_request钩子，在每次请求后运行（除非有未处理的异常）\n# 接收response参数，表示HTTP响应对象\n# 该钩子用于在视图函数处理完请求后，返回响应给客户端前进行最后的处理\n@app.after_request\ndef a_r(response):\n    # 打印提示信息，表示请求后的处理工作\n    print('after_request')\n    # 必须返回response对象，可以是原始响应或修改后的响应\n    # 可以在此处修改响应头、压缩响应内容等\n    return response\n\n# 注册teardown_request钩子，在每次请求后运行，即使有未处理的异常也会执行\n# 接收exception参数，记录请求处理过程中的异常信息\n# 无论请求处理成功与否，该钩子都会执行，用于资源清理工作\n@app.teardown_request\ndef t_r(exception):\n    # 打印提示信息，表示请求结束后的清理工作\n    print('teardown_request')\n    # 打印分隔线，标识请求处理流程结束\n    print('======请求结束=======')\n    # 可以选择返回响应对象，通常不需要\n    # 实际应用中，这里常用于关闭数据库连接、释放文件锁等资源清理操作\n    return exception\n\n# 程序入口点，当直接运行此脚本时执行\nif __name__ == '__main__':\n    # 启动Flask开发服务器，监听本地5006端口\n    app.run(host='localhost', port=5006)\n</code></pre> <p>输出如下</p> <pre><code>before_first_request\nbefore_request\n处理请求\n重定向到/h路径,测试404界面\nafter_request\nteardown_request\n======请求结束======\n127.0.0.1 - - [05/Nov/2020 10:20:05] \"GET /handel_request HTTP/1.1\" 302 -\n127.0.0.1 - - [05/Nov/2020 10:20:05] \"GET /h HTTP/1.1\" 404 -\nbefore_request\nafter_request\nteardown_request\n======请求结束======\n</code></pre>","path":["Python","Flask请求钩子完全指南"],"tags":[]},{"location":"Python/Flask%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#flask","level":4,"title":"Flask请求钩子执行流程图","text":"<p>下面的流程图展示了Flask请求钩子的执行顺序和条件：</p> <pre><code>graph LR\n    A[客户端发起请求] --&gt; B[before_first_request]\n    B --&gt; C[before_request]\n    C --&gt; D[视图函数处理请求]\n    D --&gt; E{是否有未处理异常?}\n    E --&gt;|否| F[after_request]\n    E --&gt;|是| G[跳过after_request]\n    F --&gt; H[teardown_request]\n    G --&gt; H\n    H --&gt; I[返回响应给客户端]\n\n    style A fill:#FFE4C4,stroke:#333\n    style B fill:#87CEEB,stroke:#333\n    style C fill:#87CEEB,stroke:#333\n    style D fill:#98FB98,stroke:#333\n    style E fill:#FFD700,stroke:#333\n    style F fill:#87CEEB,stroke:#333\n    style G fill:#D3D3D3,stroke:#333\n    style H fill:#87CEEB,stroke:#333\n    style I fill:#FFE4C4,stroke:#333</code></pre> <p>值得注意的是after_request在Flask 0.7版本以下会因为bug导致遇到未处理的异常时不会运行.</p> <p>网上很多文章指出这个问题但没有标注版本.</p> <p>这个bug在0.7版本中已经修复.isseu</p> <p>下面是文档介绍:</p> <p>after_request(args*, *kwargs*)</p> <p>Register a function to be run after each request. Your function must take one parameter, a <code>response_class</code> object and return a new response object or the same (see <code>process_response()</code>).</p> <p>As of Flask 0.7 this function might not be executed at the end of the request in case an unhandled exception occurred.</p> <p>Note:可能是as of Flask 0.7 这里让大家理解出错. as of 既有截止的意思,也有从...时开始的意思.</p> <p>通过在handel_request函数中加入<code>4/0</code>错误,发现after_request依旧正常执行,可以确认as of在这里是截止的意思.</p> <p>既然after_request和teardown_request都是在请求结束后扫尾,那他们有什么不同呢?</p> <p>根据文档可知:</p> <ol> <li>after_request必须传入一个response对象,必须返回一个response对象.</li> <li>after_request一般用来统一修改响应的内容，比如修改响应头.</li> <li>teardown_request需要传入一个参数记录异常,如果需要可以将这个异常返回.</li> <li>teardown_request一般用来释放程序占用的资源,比如释放数据库连接.</li> </ol>","path":["Python","Flask请求钩子完全指南"],"tags":[]},{"location":"Python/Flask%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_1","level":3,"title":"蓝图层的请求钩子","text":"<p>和app层类似,蓝图层的常用钩子如下:</p> <p>before_app_request,</p> <p>after_app_request,</p> <p>teardown_app_request.</p> <p>Such a function is executed after each request, even if outside of the blueprint.</p>","path":["Python","Flask请求钩子完全指南"],"tags":[]},{"location":"Python/Flask%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_2","level":2,"title":"核心要点总结","text":"<ol> <li>请求钩子是在客户端与服务器交互过程中处理准备工作或扫尾工作的机制</li> <li>before_first_request仅在处理第一个请求前运行一次，常用于初始化操作</li> <li>before_request在每次请求前都会运行，可用于权限检查、日志记录等</li> <li>after_request在每次请求后运行（除非有未处理的异常），主要用于修改响应内容</li> <li>teardown_request在每次请求后运行，即使出现未处理的异常，用于资源清理</li> <li>after_request与teardown_request的主要区别在于用途：前者用于修改响应内容，后者用于释放资源</li> <li>在Flask 0.7版本以下，after_request遇到未处理异常时可能不会执行</li> <li>蓝图层也提供了类似的钩子函数：before_app_request、after_app_request、teardown_app_request</li> </ol>","path":["Python","Flask请求钩子完全指南"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/","level":1,"title":"Nginx基础&常用模块","text":"<p>简介 <pre><code>nginx -v \n#查看 nginx 编译参数\nnginx -V\n#检查 nginx 配置文件语法是否正确\nnginx -t -c /etc/nginx/nginx.conf  \n#重新载入配置文件\nnginx -s reload\n</code></pre></p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#nginx","level":2,"title":"Nginx 的中间件架构","text":"<p>Nginx 是一个开源且高性能可靠的 HTTP 中间件,代理服务.</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#nginx_1","level":2,"title":"为什么选择 Nginx?","text":"<p>原因1,IO 多路复用 epoll.</p> <p>IO 复用就是将多个 IO 流使用一个 socket 来传递.</p> <p>原因2,轻量级</p> <p>原因3,CPU 亲和(affinity)</p> <p><code>CPU 亲和是一种把 CPU 核心和 Nginx 工作进程绑定方式,把每个 worker 进程固定在一个 CPU 上执行,减少切换 CPU 的 cache miss, 获得更好的性能.</code></p> <p>原因4,sendfile</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#nginx_2","level":2,"title":"Nginx 目录讲解","text":"路径 类型 作用 /etc/logrotate.d/nginx 配置文件 Nginx 日志轮转,用于 logrotate 服务的日志切割 / etc/nginx 目录,配置文件 Nginx 主配置文件 / etc/nginx/nginx.conf 主要配置文件 /etc/nginx/nginx/conf.d /etc/nginx/conf.d/default.conf 默认配置文件 /etc/nginx/fastcgi_params 配置文件 fastcgi 配置 /etc/nginx/uwsgi_params param(参数) /etc/nginx/scgi_params /etc/nginx/koi-utf 配置文件 编码转换映射转化文件 /etc/nginx/koi-win /etc/nginx/win-utf /etc/nginx/mime.types 配置文件 设置 http 协议的 Content-Type 与扩展名对应关系 /usr/lib/systemd/system/nginx-debug.service 配置文件 centos7中,用于配置出系统守护进程管理器管理方式 /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug <p>看/ etc/nginx/conf.d</p> <p>看/ etc/nginx/nginx.conf</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#http","level":2,"title":"HTTP请求","text":"<p>request-包括请求行,请求头部,请求数据</p> <p>response-包括状态行,消息报头,响应正文</p> <p>Curl -CommandLine Uniform Resource Locator</p> <p>curl是利用URL语法在命令行方式下工作的开源文件传输工具.</p> <p>通过编辑配置文件,可以更改 error.log和 access.log 的记录,  具体哪些参数可以添加,可以参考 Nginx.org 上面的文档.</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#nginx_3","level":3,"title":"Nginx 变量","text":"<p>1.http请求变量</p> <p>2.Nginx 内置变量</p> <p>3.自定义变量</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#nginx_4","level":2,"title":"Nginx 模块讲解","text":"<pre><code>nginx -t -c /etc/nginx/nginx.conf\n</code></pre>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#___stub_status_moule__","level":4,"title":"__<code>_stub_status_moule</code>__模块,","text":"<p>显示 Nginx 当前处理链接的状态,用于监控 Nginx 当前连接的信息</p> <p>需要在<code>/etc/nginx/conf.d/default.conf</code>添加</p> <pre><code>location /mystatus {\n    stub_status;\n}\n</code></pre>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#-with-http_random_index_module","level":4,"title":"<code>--with-http_random_index_module</code>","text":"","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#gx_http_sub_module","level":4,"title":"<code>gx_http_sub_module</code>","text":"<p><code>sub_filter</code>,<code>sub_filter_last_modified</code>,<code>sub_filter_once</code>,<code>sub_filter_types</code>替换 HTTP 页面 </p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#__limit_conn_module__","level":4,"title":"__<code>limit_conn_module</code>__连接频率限制","text":"","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#__limit_req_module__","level":4,"title":"__<code>limit_req_module</code>__请求频率限制","text":"<p>HTTP协议的连接与请求</p> HTTP 协议版本 连接关系 HTTP1.0 TCP 不能复用 HTTP1.1 顺序性 TCP 复用 HTTP2.0 多路复用 TCP 复用 <p>HTTP 请求建立在一次 TCP 连接基础上</p> <p>一次 TCP 连接至少产生一次 HTTP 请求</p> <pre><code>ab -n 50 -c 20 http://www.qq.com\n\n-n 表示请求数为50 , -c 20是同时并发请求数\nab 是 Apache 自带的压力测试工具,是一个很实用的测试工具.\n</code></pre>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#nginx_5","level":3,"title":"Nginx 访问控制","text":"<p>__<code>http_access_module</code>__基于 ip 的访问控制.</p> <p>如果要写</p> <pre><code>location / {\n    allow all;\n    deny 10.211.55.2;\n}\n##需要注意 allow all的位置, 如果 allow all 在前面,则后面所有的 deny 都会无效.\n</code></pre> <p><code>access_module</code>的局限性:因为存在7lay LSB和 CDN 等,所以 remote_addr 不一定是需要进行限制的 ip 地址. 无法保证 remote_addr 的准确性</p> <p>进阶方法</p> <p>方案1.采用别的 HTTP 头信息控制访问, <code>http_x_forwarded_for</code></p> <p></p> <pre><code>http_x_forwarded_for = Client IP, Proxy(1)IP,Proxy(2)IP...\n</code></pre> <p>但是 x_forwarded_for 只是一个协议,并没有强制要求对方遵守,故是可以被篡改的,安全性并不高.</p> <p>方案2.结合 geo 模块</p> <p>方案3.通过 HTTP 自定义变量传递</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/Nginx%E5%9F%BA%E7%A1%80&%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/#__http_auth_basic_module__","level":4,"title":"__<code>http_auth_basic_module</code>__基于用户的信任登录","text":"<pre><code>location / {\n    auth_basic 'this is a test';\n    auth_basic_user_file /path;\n}\n</code></pre> <p>可以使用 htpasswd来进行加密.  该工具集成在 httpd-tools 里面.</p> <p>局限性</p> <p>1.用户信息依赖文件方式</p> <p>2.操作机械,效率低下</p> <p>解决方案:</p> <p>1.Nginx 结合 LUA 实现高效验证</p> <p>2.Nginx 和 LDAP 大同,利用 Nginx-auth-ldap 模块.</p>","path":["Python","Nginx基础&常用模块"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/","level":1,"title":"None 的定义与特性","text":"<p>深入理解Python中None、布尔值和空值的对应关系，以及对象与布尔值的转换机制</p>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#none","level":1,"title":"None 的定义与特性","text":"<p>None 是Python中一个特殊的常量，它表示\"无\"或\"空\"，但它不等同于空字符串、空列表、数字0或False。</p> <pre><code># 演示None与其他\"空\"值的区别\na = 0       # 数字0\nb = ''      # 空字符串\nc = []      # 空列表\n\nd = None    # None值\n\n# 使用==比较值相等性\nprint(f\"{a} == None: {a == None}\")    # False\nprint(f\"{b} == None: {b == None}\")    # False\nprint(f\"{c} == None: {c == None}\")    # False\n\n# 使用is比较对象身份\nprint(f\"{a} is None: {a is None}\")    # False\nprint(f\"{b} is None: {b is None}\")    # False\nprint(f\"{c} is None: {c is None}\")    # False\n\n# 查看None的类型\nprint(f\"type(None): {type(None)}\")    # &lt;class 'NoneType'&gt;\n</code></pre> <p>关键要点： - None是一个对象：它是NoneType类型的唯一实例 - None表示\"不存在\"：与表示\"假\"的False不同 - 身份比较优于值比较：使用<code>is None</code>而不是<code>== None</code></p> <pre><code># 函数返回None的情况\ndef example_function():\n    # 没有显式return语句的函数默认返回None\n    pass\n\nresult = example_function()\nprint(f\"函数返回值: {result}\")           # None\nprint(f\"返回值类型: {type(result)}\")    # &lt;class 'NoneType'&gt;\n\n# 正确检查None的方式\nif result is None:\n    print(\"函数没有返回有效值\")\nelse:\n    print(\"函数返回了有效值\")\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#none_1","level":2,"title":"None在条件判断中的行为","text":"<p>在布尔上下文中，None被视为False，但在需要明确区分的情况下，应该使用身份比较。</p> <pre><code># 比较None、空列表和False在条件判断中的表现\nvalues = [None, [], False, 0, \"\"]\n\nfor value in values:\n    # 使用not操作符（检查falsy值）\n    if not value:\n        print(f\"not {value!r}: True (falsy)\")\n    else:\n        print(f\"not {value!r}: False (truthy)\")\n\n    # 明确检查None\n    if value is None:\n        print(f\"{value!r} is None: True\")\n    else:\n        print(f\"{value!r} is None: False\")\n    print()\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#none_2","level":2,"title":"使用None作为默认参数","text":"<p>None经常被用作函数参数的默认值，特别是当需要区分\"未提供参数\"和\"提供了特定值\"的情况时。</p> <pre><code># 正确使用None作为默认参数的方式\ndef append_item(item, target_list=None):\n    \"\"\"\n    向列表中添加元素，如果未提供列表则创建新列表\n\n    Args:\n        item: 要添加的元素\n        target_list: 目标列表，默认为None\n\n    Returns:\n        包含元素的列表\n    \"\"\"\n    # 如果target_list为None，则创建一个新的空列表\n    if target_list is None:\n        target_list = []\n\n    target_list.append(item)\n    return target_list\n\n# 测试函数\nlist1 = append_item(\"apple\")\nlist2 = append_item(\"banana\")\nprint(f\"list1: {list1}\")  # ['apple']\nprint(f\"list2: {list2}\")  # ['banana']\n\n# 如果使用可变对象作为默认参数会出问题\n# def bad_append_item(item, target_list=[]):  # 错误做法\n#     target_list.append(item)\n#     return target_list\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#none_3","level":1,"title":"None与布尔类型的根本区别","text":"<p>虽然在条件判断中None和False都会导致条件为假，但它们有着本质的不同。</p> <pre><code># 类型差异\nprint(f\"type(None): {type(None)}\")    # &lt;class 'NoneType'&gt;\nprint(f\"type(False): {type(False)}\")  # &lt;class 'bool'&gt;\nprint(f\"type(True): {type(True)}\")    # &lt;class 'bool'&gt;\n\n# 语义差异\n# None: 表示\"无值\"或\"未定义\"\n# False: 表示逻辑上的\"假\"\n# True: 表示逻辑上的\"真\"\n\n# 在条件语句中的表现\nvalues = [None, False, True]\n\nfor value in values:\n    if value:\n        print(f\"if {value!r}: 条件为真\")\n    else:\n        print(f\"if {value!r}: 条件为假\")\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#falsy","level":2,"title":"布尔值与falsy值的对应关系","text":"<p>在Python中，以下值在布尔上下文中被视为False（称为falsy值）：</p> <pre><code># 所有会被视为False的值\nfalsy_values = [\n    None,        # None\n    False,       # 布尔False\n    0,           # 数字0\n    0.0,         # 浮点数0\n    0j,          # 复数0\n    '',          # 空字符串\n    \"\",          # 空字符串\n    [],          # 空列表\n    (),          # 空元组\n    {},          # 空字典\n    set(),       # 空集合\n]\n\nprint(\"Falsy值及其布尔值:\")\nfor value in falsy_values:\n    print(f\"  {value!r:&lt;10} -&gt; bool({value!r}): {bool(value)}\")\n\n# 任何非空或非零的值都被视为True（truthy值）\ntruthy_values = [\n    True,        # 布尔True\n    1,           # 非零数字\n    -1,          # 负数\n    3.14,        # 浮点数\n    'hello',     # 非空字符串\n    [1, 2, 3],   # 非空列表\n    {'key': 'value'},  # 非空字典\n]\n\nprint(\"\\nTruthy值及其布尔值:\")\nfor value in truthy_values:\n    print(f\"  {value!r:&lt;15} -&gt; bool({value!r}): {bool(value)}\")\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#_1","level":1,"title":"自定义对象与布尔值的关系","text":"<p>对于自定义对象，其在布尔上下文中的表现取决于<code>__bool__()</code>和<code>__len__()</code>这两个特殊方法的实现。</p>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#_2","level":2,"title":"对象的布尔值转换机制","text":"<p>Python使用以下规则来确定对象的布尔值： 1. 如果定义了<code>__bool__()</code>方法，则调用它并返回其结果 2. 如果没有定义<code>__bool__()</code>但定义了<code>__len__()</code>，则根据长度是否为0来判断 3. 如果两者都未定义，则对象默认为True</p> <pre><code># 基本对象的布尔值\nclass BasicObject:\n    \"\"\"未定义__bool__或__len__的对象\"\"\"\n    pass\n\nobj1 = BasicObject()\nprint(f\"基本对象的布尔值: {bool(obj1)}\")  # True (默认为True)\n\n# 定义了__len__但未定义__bool__的对象\nclass LengthObject:\n    \"\"\"通过__len__方法控制布尔值的对象\"\"\"\n    def __init__(self, items=None):\n        self.items = items or []\n\n    def __len__(self):\n        # 返回对象的\"长度\"\n        return len(self.items)\n\n# 长度为0的对象\nempty_obj = LengthObject()\nprint(f\"空对象的长度: {len(empty_obj)}\")      # 0\nprint(f\"空对象的布尔值: {bool(empty_obj)}\")   # False\n\n# 长度大于0的对象\nfilled_obj = LengthObject([1, 2, 3])\nprint(f\"非空对象的长度: {len(filled_obj)}\")    # 3\nprint(f\"非空对象的布尔值: {bool(filled_obj)}\") # True\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#__bool__","level":2,"title":"使用__bool__方法自定义布尔行为","text":"<p>通过实现<code>__bool__()</code>方法，可以完全控制对象在布尔上下文中的表现。</p> <pre><code># 使用__bool__方法控制对象的布尔值\nclass Account:\n    \"\"\"银行账户类，余额为正时为True，否则为False\"\"\"\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def __bool__(self):\n        # 当余额大于0时，账户为True\n        return self.balance &gt; 0\n\n    def __repr__(self):\n        return f\"Account(balance={self.balance})\"\n\n# 测试账户对象\nempty_account = Account(0)      # 空账户\nrich_account = Account(1000)    # 有钱的账户\n\nprint(f\"空账户: {empty_account}\")\nprint(f\"空账户的布尔值: {bool(empty_account)}\")    # False\n\nprint(f\"有钱账户: {rich_account}\")\nprint(f\"有钱账户的布尔值: {bool(rich_account)}\")  # True\n\n# 在条件语句中使用\nif rich_account:\n    print(\"有钱账户可以进行交易\")\n\nif not empty_account:\n    print(\"空账户无法进行交易\")\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#__bool____len__","level":2,"title":"__bool__与__len__的优先级","text":"<p>当同时定义了<code>__bool__()</code>和<code>__len__()</code>方法时，Python会优先使用<code>__bool__()</code>方法。</p> <pre><code># 展示__bool__和__len__的优先级\nclass PriorityDemo:\n    \"\"\"演示__bool__优先于__len__的类\"\"\"\n    def __init__(self, length=0, is_valid=True):\n        self.length = length\n        self.is_valid = is_valid\n\n    def __len__(self):\n        print(\"调用了__len__方法\")\n        return self.length\n\n    def __bool__(self):\n        print(\"调用了__bool__方法\")\n        return self.is_valid\n\n# 创建一个长度为5但is_valid为False的对象\nobj = PriorityDemo(length=5, is_valid=False)\n\nprint(\"获取对象长度:\")\nlength = len(obj)  # 只调用__len__\nprint(f\"长度: {length}\\n\")\n\nprint(\"获取对象布尔值:\")\nboolean = bool(obj)  # 只调用__bool__，不调用__len__\nprint(f\"布尔值: {boolean}\")\n\n# 删除__bool__方法来观察__len__的行为\nprint(\"\\n删除__bool__方法后的表现:\")\ndel PriorityDemo.__bool__\n\nobj2 = PriorityDemo(length=0, is_valid=True)\nprint(f\"长度为0的对象布尔值: {bool(obj2)}\")  # False (因为长度为0)\n\nobj3 = PriorityDemo(length=3, is_valid=False)\nprint(f\"长度为3的对象布尔值: {bool(obj3)}\")  # True (因为长度大于0)\n</code></pre>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/None,%E5%B8%83%E5%B0%94,%E7%A9%BA/#_3","level":2,"title":"实际应用示例","text":"<p>让我们通过几个实际的例子来展示这些概念的应用。</p> <pre><code># 实际应用：用户权限系统\nclass User:\n    \"\"\"用户类\"\"\"\n    def __init__(self, username, permissions=None):\n        self.username = username\n        self.permissions = permissions or []\n\n    def __bool__(self):\n        # 用户存在且有权限时为True\n        return bool(self.username and self.permissions)\n\n    def has_permission(self, permission):\n        \"\"\"检查用户是否有特定权限\"\"\"\n        return permission in self.permissions\n\n# 创建不同状态的用户\nanonymous_user = User(\"\")  # 匿名用户\nregular_user = User(\"alice\", [\"read\"])  # 普通用户\nadmin_user = User(\"bob\", [\"read\", \"write\", \"delete\"])  # 管理员\n\nusers = [anonymous_user, regular_user, admin_user]\n\nfor user in users:\n    if user:  # 检查用户是否有效\n        print(f\"用户 {user.username} 有效，权限: {user.permissions}\")\n    else:\n        print(f\"无效用户或匿名访问\")\n</code></pre> <p>总结要点： 1. None是唯一的NoneType实例，表示\"无值\"而非\"假\" 2. 使用<code>is None</code>进行身份比较比<code>== None</code>更准确且性能更好 3. falsy值包括None、False、0、空容器等，在条件判断中被视为False 4. 自定义对象的布尔值由<code>__bool__()</code>或<code>__len__()</code>决定，前者优先级更高 5. 合理使用这些概念能写出更清晰、更安全的代码</p>","path":["Python","None 的定义与特性"],"tags":[]},{"location":"Python/Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","level":1,"title":"Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用","text":"<p>title: Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用</p> <p>Date: 2020/10/19 21:31</p> <p>tags: Python</p> <p>categories: Python</p>","path":["Python","Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用"],"tags":[]},{"location":"Python/Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/#_1","level":3,"title":"三种拷贝","text":"<ul> <li>直接赋值：其实就是对象的引用（别名）。</li> <li>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</li> <li>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li> </ul> <p>1. b = a: 赋值引用，a 和 b 都指向同一个对象。</p> <p></p> <p>2. b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</p> <p></p> <p>3. b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</p> <p></p>","path":["Python","Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用"],"tags":[]},{"location":"Python/Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/#_2","level":3,"title":"更多实例","text":"<p>以下实例是使用 copy 模块的 copy.copy（ 浅拷贝 ）和（copy.deepcopy ）:</p> <pre><code>#!/usr/bin/python\n# -*-coding:utf-8 -*-\n\n# 导入copy模块，用于实现浅拷贝和深拷贝功能\nimport copy\n\n# 创建一个包含嵌套结构的原始对象\n# 包含整数元素1,2,3,4和一个嵌套列表['a', 'b']\na = [1, 2, 3, 4, ['a', 'b']]  # 原始对象\n\n# 四种不同的拷贝方式演示\nb = a                         # 赋值引用，b与a指向同一对象\nc = copy.copy(a)              # 浅拷贝，创建新的列表对象，但嵌套对象仍为引用\nd = copy.deepcopy(a)          # 深拷贝，递归拷贝所有层级的对象，完全独立\n\n# 修改原始对象a，观察不同拷贝方式的区别\na.append(5)                   # 在a末尾添加元素5\na[4].append('c')              # 在a的嵌套列表['a', 'b']中添加元素'c'\n\n# 打印各个对象的值，验证拷贝效果\nprint('a = ', a)              # 输出修改后的a\nprint('b = ', b)              # 输出b，由于是引用，会同步a的所有修改\nprint('c = ', c)              # 输出c，浅拷贝对象，顶级元素独立但嵌套对象共享\nprint('d = ', d)              # 输出d，深拷贝对象，完全独立不受影响\n</code></pre> <p>输出结果为</p> <pre><code>('a = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])\n('b = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])\n('c = ', [1, 2, 3, 4, ['a', 'b', 'c']])\n('d = ', [1, 2, 3, 4, ['a', 'b']])\n</code></pre>","path":["Python","Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用"],"tags":[]},{"location":"Python/Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/#_3","level":3,"title":"查漏补缺","text":"<p>为什么Python默认的拷贝方式是浅拷贝？</p> <p>时间角度：浅拷贝花费时间更少；</p> <p>空间角度：浅拷贝花费内存更少；</p> <p>效率角度：浅拷贝只拷贝顶层数据，一般情况下比深拷贝效率高。</p> <p>本文知识点总结：</p> <p>不可变对象在赋值时会开辟新空间；</p> <p>可变对象在赋值时，修改一个的值，另一个也会发生改变；</p> <p>深拷贝、浅拷贝对不可变对象拷贝时，不开辟新空间，相当于赋值操作；</p> <p>浅拷贝在拷贝时，只拷贝第一层中的引用，如果元素是可变对象，并且被修改，那么拷贝的对象也会发生变化；</p> <p>深拷贝在拷贝时会逐层进行拷贝，直到所有的引用都是不可变对象为止；</p> <p>Python中有多种方式实现浅拷贝，copy模块的copy函数、对象的copy函数、工厂方法、切片等；</p> <p>大多数情况下，编写程序时都是使用浅拷贝，除非有特定的需求；</p> <p>浅拷贝的优点：拷贝速度快，占用空间少，拷贝效率高。</p>","path":["Python","Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用"],"tags":[]},{"location":"Python/Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/#_4","level":3,"title":"拷贝方式对比流程图","text":"<p>下面用mermaid图表展示三种拷贝方式的核心区别：</p> <pre><code>graph LR\n    A[原始对象] --&gt; B{拷贝方式}\n    B --&gt; C[直接赋值]\n    B --&gt; D[浅拷贝]\n    B --&gt; E[深拷贝]\n    C --&gt; F[引用同一对象]\n    D --&gt; G[新对象,子对象引用]\n    E --&gt; H[完全独立对象]</code></pre> <p>转自:</p> <p>Python 直接赋值、浅拷贝和深度拷贝解析</p> <p>Python 程序员如何防止数据被修改？</p>","path":["Python","Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用"],"tags":[]},{"location":"Python/Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8Python%20%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/#_5","level":3,"title":"核心要点总结","text":"<ol> <li> <p>直接赋值（引用）：不创建新对象，只是给对象增加一个新的引用名称，所有引用共享同一内存地址。</p> </li> <li> <p>浅拷贝：创建一个新的对象，但对于对象中的元素，仅拷贝其引用，而非完整拷贝元素对象本身。</p> </li> <li> <p>深拷贝：递归地拷贝所有层级的对象，创建全新的对象和其包含的所有子对象，完全独立于原对象。</p> </li> <li> <p>不可变对象与拷贝：对于字符串、元组等不可变对象，深浅拷贝都不会创建新对象，实际效果等同于引用。</p> </li> <li> <p>可变对象与拷贝：列表、字典等可变对象在浅拷贝时，顶层对象独立，但内层嵌套对象仍然共享引用。</p> </li> <li> <p>适用场景：浅拷贝适用于大多数场景，具有性能优势；深拷贝适用于需要完全隔离对象的场景，但开销较大。</p> </li> </ol>","path":["Python","Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用Python 拷贝机制详解：直接赋值、浅拷贝与深拷贝的原理与应用"],"tags":[]},{"location":"Python/Python_future%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3_%E5%AE%9E%E7%8E%B0%E6%96%B0%E6%97%A7%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/","level":1,"title":"Python future模块详解 实现新旧版本兼容的关键技术","text":"<p>title: Python __future__模块详解：实现新旧版本兼容的关键技术</p> <p>Date: 2020/12/14 17:33</p> <p>tags: Python</p> <p>categories: Python</p> <p>当如果在旧版本需要使用新版本的某些特性,比如说同时兼容py2和py3的话,就需要使用<code>__future__</code>模块.</p> <p>该模块在2.1版本被引入.</p> <p>官方文档链接:[官方链接][https://docs.python.org/3.9/library/__future__.html?highlight=__future__#module-__future__]</p> <p>在官方文档里提到引入这个模块的三个核心目的.</p> <p><code>__future__</code> is a real module, and serves three purposes:</p> <ul> <li>To avoid confusing existing tools that analyze import statements and expect to find the modules they’re importing.</li> <li>To ensure that future statements run under releases prior to 2.1 at least yield runtime exceptions (the import of <code>__future__</code> will fail, because there was no module of that name prior to 2.1).</li> <li>To document when incompatible changes were introduced, and when they will be — or were — made mandatory. This is a form of executable documentation, and can be inspected programmatically via importing <code>__future__</code> and examining its contents.</li> </ul> <p>简单翻译如下:</p> <p>1.为了不影响现有的导入工具</p> <p>2.为了保证低于2.1版本时报导入错误</p> <p>3.记录何时引入了不可兼容的更改(可选性),何时将其设定成语言的特性(强制性)</p> <p>为了更好地理解__future__模块的工作原理，我们可以通过以下流程图来可视化其工作机制：</p> <pre><code>graph LR\n    A[Python代码] --&gt; B{是否存在__future__导入}\n    B --&gt;|是| C[__future__模块解析]\n    C --&gt; D[启用新特性语法]\n    B --&gt;|否| E[使用默认语法]\n    D --&gt; F[代码执行]\n    E --&gt; F\n    F --&gt; G[兼容性保障]</code></pre> <p>在使用<code>__future__</code>模块后,即可使用新版本的特性. 比如在py2的环境中导入print_function,就可以在其环境中使用print()函数.</p> <pre><code># 导入__future__模块中的print_function特性\n# 使得在Python 2环境中也能使用Python 3的print()函数语法\nfrom __future__ import print_function\n\n# 使用print()函数输出文本\nprint('hello,world')\n</code></pre> <p>详细的feature_name如下:</p> feature optional in mandatory in effect nested_scopes 2.1.0b1 2.2 PEP 227: Statically Nested Scopes generators 2.2.0a1 2.3 PEP 255: Simple Generators 生成器 division 2.2.0a2 3.0 PEP 238: Changing the Division Operator 精确除法 3//4 = 0 absolute_import 2.5.0a1 3.0 PEP 328: Imports: Multi-Line and Absolute/Relative 绝对路径引用 with_statement 2.5.0a1 2.6 PEP 343: The “with” Statement with语句 print_function 2.6.0a2 3.0 PEP 3105: Make print a function print()函数 unicode_literals 2.6.0a2 3.0 PEP 3112: Bytes literals in Python 3000 generator_stop 3.5.0b1 3.7 PEP 479: StopIteration handling inside generators annotations 3.7.0b1 3.10 PEP 563: Postponed evaluation of annotations","path":["Python","Python future模块详解 实现新旧版本兼容的关键技术"],"tags":[]},{"location":"Python/Python_future%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3_%E5%AE%9E%E7%8E%B0%E6%96%B0%E6%97%A7%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/#_1","level":2,"title":"核心要点总结","text":"<ol> <li> <p><code>__future__</code>模块的作用：允许在旧版本Python中使用新版本的特性，实现向后兼容。</p> </li> <li> <p>引入目的：避免影响现有导入工具、确保低版本报错以及记录不兼容更改的引入和强制时间。</p> </li> <li> <p>常用特性导入：如print_function可在Python 2中使用Python 3的print()函数语法。</p> </li> <li> <p>关键特性列表：nested_scopes、generators、division、absolute_import、with_statement、print_function等。</p> </li> <li> <p>版本兼容性：每个特性都有其可选版本和强制版本，需要根据目标环境选择合适的特性导入。</p> </li> <li> <p>实际应用场景：主要用于Python 2到Python 3的迁移过程中，确保代码在两个版本间的兼容性。</p> </li> </ol>","path":["Python","Python future模块详解 实现新旧版本兼容的关键技术"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","level":1,"title":"默认参数","text":"<p>title: Python函数参数详解：默认参数、可变参数与关键字参数的完整指南</p> <p>data: 2017/05/22 17:32:14</p> <p>tags: Python</p> <p>categories: Python</p> <p>默认函数,可变函数等一些关于函数定义方面的问题.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_1","level":1,"title":"默认参数","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_2","level":2,"title":"默认参数定义","text":"<pre><code># 先定义一个简单的平方函数，计算x的平方\ndef power(x):\n    return x*x\n\n&gt;&gt;&gt;power(5)  # 调用函数计算5的平方\n25\n\n# 扩展这个函数，使其可以计算x的n次方\n# x: 底数\n# n: 指数\ndef power(x,n):\n    s = 1  # 初始化结果变量为1\n    # 循环n次，每次将s乘以x\n    while n &gt; 0:\n        n = n - 1  # 指数减1\n        s = s * x  # 结果乘以底数\n    return s  # 返回最终结果\n\n&gt;&gt;&gt;power(5,3)  # 调用函数计算5的3次方\n125\n</code></pre> <p>但是这时候再调用第一个函数,则会报错.</p> <p></p> <p>即,调用函数 power()缺少了一个位置参数 n.</p> <p>这时候就需要使用默认参数了</p> <pre><code># 使用默认参数定义函数，n的默认值为2\n# x: 底数（必选参数）\n# n: 指数（可选参数，默认值为2）\ndef power(x,n=2):\n    s = 1  # 初始化结果变量为1\n    # 循环n次，每次将s乘以x\n    while n &gt; 0:\n        n = n - 1  # 指数减1\n        s = s * x  # 结果乘以底数\n    return s  # 返回最终结果\n\n#如果需要使用 n不等于2的情况,则需要明确传入 n 值.\n#必选参数在前,默认参数在后,否则可能会报错.\n#当函数有多个函数时,把变化比较大的参数放在前面,变化比较小的放后面.\n#变化小的参数可以作为默认参数,这样可以降低调用的难度以及优化代码\n</code></pre> <p>多个默认参数,有时按照顺序提供默认参数,有时可以不按顺序提供默认参数</p> <pre><code>#顺序传参方式调用函数\nenroll('Bo','M',7)\n#关键字参数方式调用函数，提高代码可读性\nenroll('Ad','M',city='Tianjin')\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_3","level":2,"title":"默认参数坑","text":"<pre><code># 错误示例：使用可变对象作为默认参数\n# L: 列表参数，默认值为空列表（这里是有问题的！）\ndef add_end(L=[]):\n    L.append('END')  # 向列表末尾添加'END'元素\n    return L  # 返回修改后的列表\n\n&gt;&gt;&gt; add_end()  # 第一次调用\n['END']\n&gt;&gt;&gt; add_end()  # 第二次调用，结果不是预期的['END']而是['END', 'END']\n['END', 'END']\n</code></pre> <p>函数定义的是在某个列后加入一个 'END', 但是函数好像每次都记住了上次添加了' END'后的 list.</p> <p>原因如下:</p> <p>Python函数在定义的时候,默认函数L的值就被确定了,因为 默认函数 L 也是一个变量,它指向对象[],每次调用该函数时,如果改变了 L 的内容,则下次调用时,默认参数的内容就发生了变化,不再是默认的定义.</p> <p>故,需要特别注意!!</p> <p>默认参数必须指向不变对象!!</p> <pre><code>可变对象:list,dict,set\n不变对象: str,None,tuple\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_4","level":1,"title":"可变参数","text":"<p>可变参数是指传入的参数个数是可变的.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#list","level":2,"title":"list法","text":"<pre><code># 可以通过传入一个 list 作为函数的参数,从而实现参数个数可变.\n# numbers: 包含数字的列表\ndef calc(numbers):\n    sum = 0  # 初始化总和为0\n    # 遍历列表中的每个数字，计算平方和\n    for n in numbers:\n        sum = sum + n * n  # 累加每个数字的平方\n    return sum  # 返回计算结果\n# 但是必须先填入一个 list 或 tuple\n&gt;&gt;&gt;calc([1,2,3])  # 计算1²+2²+3²=1+4+9=14\n14\n</code></pre> <p>每次必须传入一个 list 或者 tuple, 太繁琐.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_5","level":2,"title":"加*","text":"<p>所以一般将函数的参数改为可变参数</p> <pre><code># 使用可变参数定义函数，可以接收任意数量的位置参数\n# *numbers: 可变参数，接收任意数量的位置参数，函数内部作为元组处理\ndef calc(*numbers):\n    sum = 0  # 初始化总和为0\n    # 遍历所有传入的参数，计算平方和\n    for n in numbers:\n        sum = sum + n * n  # 累加每个数字的平方\n    return sum  # 返回计算结果\n</code></pre> <p>在参数前加一个*号.</p> <p>在内部流程中,参数 numbers 接收到的是一个tuple.</p> <pre><code>&gt;&gt;&gt;calc(1,2)  # 直接传入两个参数1和2，计算1²+2²=1+4=5\n5\n</code></pre> <p>如果要传入一个 list 或 tuple, 则可以选择在 list 或 tuple 前加一个*号,把 list 或 tuple的元素变成可变参数传入:</p> <pre><code>&gt;&gt;&gt;nums=[1,2,3]  # 定义一个包含数字的列表\n&gt;&gt;&gt;calc(*nums)  # 使用*解包列表，将列表元素作为单独参数传入函数\n14\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_6","level":1,"title":"关键字参数","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_7","level":2,"title":"关键字参数的设置","text":"<p>可变参数允许传入任意个数参数,自动组装成一个 tuple.</p> <p>关键字参数允许传入任意个数含参数名的参数,自动组装成一个 dict.</p> <pre><code># 定义带有关键字参数的函数\n# name: 姓名（必选参数）\n# age: 年龄（必选参数）\n# **kw: 关键字参数，接收任意数量的键值对参数，函数内部作为字典处理\ndef person(name,age,**kw):\n    print(name,age,kw)  # 打印姓名、年龄和其他关键字参数\n\n&gt;&gt;&gt;person('Bo',5,city='Beijing')  # 传入姓名、年龄和城市信息\nBo 5 {'city': 'Beijing'}\n</code></pre> <p>在 person 函数里,我们能保证收到两个必须参数name和age,如果调用者需要提供更多信息,我们也可以收到这些信息,而且这些信息可以是任意的.</p> <p>也可以先做一个 dict 来存储这些额外的信息,</p> <pre><code>&gt;&gt;&gt;extra={'city':'Beijing','job':'Engineer','location':'changping'}  # 定义一个包含额外信息的字典\n##可以对个别 key 值调用\n&gt;&gt;&gt;person('Ja',24,city=extra['city'])  # 只传入city信息\n##也可以一次性全部调用\n&gt;&gt;&gt;person('Ja',23,**extra)  # 使用**解包字典，将字典的所有键值对作为关键字参数传入\n</code></pre> <p>** extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 ** kw 参数, kw 获得一个 dict, 这里并不是指针改变,而是拷贝,所以 kw 的后续改动并不会影响到函数外的 extra.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_8","level":2,"title":"命名关键字参数","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_9","level":3,"title":"关键字参数检查","text":"<p>因为在传入时并没有规定参数的格式,所以传入的信息会比较杂乱,</p> <p>有时希望检查某些参数是否输入:</p> <pre><code># 对关键字参数进行检查的函数\n# name: 姓名（必选参数）\n# age: 年龄（必选参数）\n# **kw: 关键字参数\ndef person(name,age,**kw):\n    # 检查是否传入了city参数\n    if 'city' in kw:\n        pass  # 实际应用中可以在这里处理city参数\n    # 检查是否传入了job参数\n    if 'job' in kw:\n        pass  # 实际应用中可以在这里处理job参数\n    print('name:',name,'age:',age,'other:',kw)  # 打印所有参数\n</code></pre> <p>但传入的信息还是很杂乱,</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_10","level":3,"title":"关键字参数限制","text":"<p>有时希望限制关键字参数的名字:</p> <pre><code># 使用命名关键字参数限制参数名称\n# name: 姓名（位置参数）\n# age: 年龄（位置参数）\n# city: 城市（命名关键字参数）\n# job: 工作（命名关键字参数）\ndef person(name,age,*,city,job):\n    print(name,age,city,job)  # 打印所有参数\n</code></pre> <p>*后面的参数都将被视为命名关键字参数.**</p> <p>如果有了一个可变参数,则可变参数后面的参数默认为命名关键字参数</p> <pre><code># 混合使用可变参数和命名关键字参数\n# name: 姓名（位置参数）\n# age: 年龄（位置参数）\n# *args: 可变参数，接收额外的位置参数\n# city: 城市（命名关键字参数）\n# job: 工作（命名关键字参数）\ndef person(name,age,*args,city,job):\n    print(name,age,args,city,job)  # 打印所有参数\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_11","level":3,"title":"关键字参数的一些问题","text":"<ul> <li>命名关键字参数必须传入参数名.</li> </ul> <p>(因为它本质上是一个 dict, 与 key有关,与位置无关)</p> <ul> <li>命名关键字可以设置缺省值</li> </ul> <pre><code># 命名关键字参数可以设置默认值\n# name: 姓名（位置参数）\n# age: 年龄（位置参数）\n# city: 城市（命名关键字参数，默认值为'Beijing'）\n# job: 工作（命名关键字参数）\ndef person(name,age,*,city='Beijing',job):\n</code></pre> <ul> <li>注意区分位置参数和命名关键字参数,命名关键字参数实质是传入了一个 dict, 与位置无关.</li> </ul>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_12","level":1,"title":"参数组合","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_13","level":2,"title":"参数顺序","text":"<p>参数定义是一定要按照以下顺序</p> <p>必选参数,默认参数,可变参数,命名关键字参数,关键字参数</p> <p>比如</p> <pre><code># 参数组合示例1：包含所有类型的参数\n# a, b: 位置参数\n# c: 默认参数（默认值为0）\n# *args: 可变参数\n# **kw: 关键字参数\ndef f1(a,b,c=0,*args,**kw):\n\n# 参数组合示例2：包含命名关键字参数\n# a, b: 位置参数\n# c: 默认参数（默认值为0）\n# d: 命名关键字参数\n# **kw: 关键字参数\ndef f2(a,b,c=0,*,d,**kw):\n</code></pre> <pre><code>&gt;&gt;&gt; f1(1, 2)  # 只传入必选参数\na = 1 b = 2 c = 0 args = () kw = {}\n&gt;&gt;&gt; f1(1, 2, c=3)  # 传入必选参数和默认参数\na = 1 b = 2 c = 3 args = () kw = {}\n&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')  # 传入必选参数、默认参数和可变参数\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)  # 传入所有类型的参数\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n&gt;&gt;&gt; f2(1, 2, d=99, ext=None)  # 调用第二个函数\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#listtuple-dict","level":2,"title":"通过list,tuple 和 dict 传入","text":"<pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)  # 定义一个元组\n&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}  # 定义一个字典\n&gt;&gt;&gt; f1(*args, **kw)  # 使用*和**解包元组和字典作为参数传入\na = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n&gt;&gt;&gt; args = (1, 2, 3)  # 定义另一个元组\n&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}  # 定义另一个字典\n&gt;&gt;&gt; f2(*args, **kw)  # 使用*和**解包元组和字典作为参数传入\na = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_14","level":1,"title":"总结","text":"<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p> <p>默认参数必须指向不变对象，如果是可变对象，程序运行时会有逻辑错误！</p> <p>要注意定义可变参数和关键字参数的语法：</p> <p><code>*args</code>是可变参数，args接收的是一个tuple；</p> <p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p> <p>以及调用函数时如何传入可变参数和关键字参数的语法：</p> <p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p> <p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p> <p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。这是Python参数传递的最佳实践。</p> <p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p> <p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#python","level":1,"title":"Python函数参数处理流程","text":"<p>为了更好地理解Python函数参数的处理机制，我们可以用以下图表来展示不同类型参数的处理流程：</p> <pre><code>graph LR\n    A[函数调用] --&gt; B{参数类型识别}\n    B --&gt; C[位置参数]\n    B --&gt; D[默认参数]\n    B --&gt; E[可变参数*args]\n    B --&gt; F[命名关键字参数]\n    B --&gt; G[关键字参数**kwargs]\n    C --&gt; H[按位置匹配]\n    D --&gt; I[使用默认值或传入值]\n    E --&gt; J[收集多余位置参数为元组]\n    F --&gt; K[按名称匹配并验证]\n    G --&gt; L[收集多余关键字参数为字典]\n    H --&gt; M[参数赋值完成]\n    I --&gt; M\n    J --&gt; M\n    K --&gt; M\n    L --&gt; M\n    M --&gt; N[执行函数体]</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_15","level":1,"title":"参数组合规则","text":"<p>Python函数参数遵循严格的定义顺序，下面的图表展示了正确的参数排列规则：</p> <pre><code>graph TB\n    A[参数定义顺序] --&gt; B[必选参数]\n    A --&gt; C[默认参数]\n    A --&gt; D[可变参数*args]\n    A --&gt; E[命名关键字参数]\n    A --&gt; F[关键字参数**kwargs]\n    B --&gt; G[例如: def func(a, b)]\n    C --&gt; H[例如: def func(a, b=2)]\n    D --&gt; I[例如: def func(a, b=2, *args)]\n    E --&gt; J[例如: def func(a, b=2, *args, c, d)]\n    F --&gt; K[例如: def func(a, b=2, *args, c, d, **kwargs)]</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#_16","level":1,"title":"核心要点总结","text":"<ol> <li> <p>默认参数必须指向不变对象：使用可变对象作为默认参数会导致意外的行为，因为默认参数在函数定义时只被计算一次。</p> </li> <li> <p>可变参数的使用：通过在参数前添加<code>*</code>号，可以接收任意数量的位置参数，函数内部将其作为一个tuple处理。</p> </li> <li> <p>关键字参数的灵活性：使用<code>**kw</code>可以接收任意数量的键值对参数，函数内部将其作为一个dict处理。</p> </li> <li> <p>命名关键字参数的限制作用：通过<code>*</code>分隔符或在可变参数后定义参数，可以限制调用者只能传入指定名称的参数。</p> </li> <li> <p>参数定义顺序的重要性：参数必须按照必选参数,默认参数,可变参数,命名关键字参数,关键字参数的顺序定义。</p> </li> <li> <p>参数传递的最佳实践：使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，便于代码的可读性和一致性。</p> </li> </ol>","path":["Python","默认参数"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/","level":1,"title":"Python协程详解：从yield到yield from","text":"<p>title: Python协程详解：从yield到yield from</p> <p>Date: 2020/10/20 14:15</p> <p>tags: Python</p> <p>categories: Python</p>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#_1","level":2,"title":"协程是什么猫?","text":"<p>协程(coroutinr),微线程.一个线程执行.</p> <p>进程是分配和管理资源的最小单位.</p> <p>线程是分配和管理CPU的最小单位,和其他同属一个进程的线程共享所拥有的全部资源.</p> <p>和多线程相比,协程的优势在于:</p> <p>1.极高的执行效率.因为子程序切换由程序自身控制,不是线程切换.没有切换线程带来的开销. 线程数越多,协程性能优势比多线程更明显.</p> <p>2.不需要多线程的锁机制,不存在同时写变量冲突,共享资源不加锁,判断状态就好了.</p> <p>协程可以通过多进程+协程的方法你用多核CPU.</p>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#yield","level":3,"title":"yield可以实现协程","text":"<p>当一个函数中存在yield时,这个函数就是一个生成器.</p> <p>yield的两个特点: 1.返回一个值,保存现场.   2.将调用者的参数传入生成器.</p> <p>这使得yield实现的生成器具有<code>中断等待</code>的功能,从而实现协程.</p>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#yield_1","level":3,"title":"yield实现协程的例子","text":"<pre><code>def consumer():\n    r = ''  # 初始化返回值为空字符串\n    while True:  # 无限循环，持续消费生产者发送的数据\n        n = yield r  # 初始化后,中断在yield r。使用send方法传入数据后，yield返回该数据\n        if not n:  # 如果接收到的数据为空，则退出循环\n            return\n        print('[消费者] 正在消费:{0}'.format(n))  # 打印正在消费的数据\n        r = '200 人民币'  # 设置返回值为'200 人民币'\n\ndef produce(c):  # 生产者函数\n    c.send(None)  # 启动消费者(生成器),进行初始化\n    n = 0  # 初始化计数器\n    while n &lt; 5:  # 循环5次生产数据\n        n = n + 1  # 计数器加1\n        print('[生产者] 正在生产:{0}'.format(n))  # 打印正在生产的商品编号\n        r = c.send(n)  # 调用send方法,将商品编号传入消费者协程,同时接收消费者返回的结果\n        print('[生产者] 消费者返回:{0}'.format(r))  # 打印消费者返回的结果\n        print('-------------------------------------------------')\n    c.close()  # 关闭消费者生成器\n\nc = consumer()  # 构造一个消费者生成器\nproduce(c)  # 启动生产者\n</code></pre>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#_2","level":2,"title":"协程的状态查看","text":"<p>GEN_CREATED:等待执行, 还没有进入协程.</p> <p>GEN_RUNNING:解释器执行</p> <p>GEN_SUSPENDED:阻塞状态,在yield处暂停</p> <p>GEN_CLOSED:执行结束</p> <p>可以通过inspect.getgeneratorstate()函数来确定.</p> <p>为了更直观地理解yield实现的协程工作原理，我们可以用下面的流程图来表示生产者-消费者模型的执行过程：</p> <pre><code>graph LR\n    A[生产者produce] --&gt; B{调用send}\n    B --&gt; C[消费者consumer]\n    C --&gt; D{yield返回值}\n    D --&gt; E[生产者接收返回值]\n    E --&gt; F{是否继续生产}\n    F --&gt;|是| B\n    F --&gt;|否| G[调用close]\n    G --&gt; H[结束]</code></pre>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#yield_2","level":3,"title":"yield实现协程的不足","text":"<p>每次只能向直接调用者返回一个值.导致无法分离到一个单独的函数中.复用性差.</p>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#yield-from","level":2,"title":"yield from","text":"<ul> <li>Python3.3版本的PEP 380中添加了<code>**yield from**</code>语法，允许一个<code>**generator**</code>生成器将其部分操作委派给另一个生成器。其产生的主要动力在于使生成器能够很容易分为多个拥有send和throw方法的子生成器，像一个大函数可以分为多个子函数一样简单。Python的生成器是协程<code>coroutine</code>的一种形式，但它的局限性在于只能向它的直接调用者yield值。这意味着那些包含yield的代码不能想其他代码那样被分离出来放到一个单独的函数中。这也正是<code>**yield from**</code>要解决的。</li> <li>虽然<code>**yield from**</code>主要设计用来向子生成器委派操作任务，但<code>**yield from**</code>可以向任意的迭代器委派操作；</li> </ul> <p>yield只能返回一个元素,而yield from 可以返回一个生成器.</p> <p>在PEP 380 使用了一些yield from使用的专门术语：</p> <p>委派生成器：包含 yield from  表达式的生成器函数； <p>子生成器：从 yield from 表达式中  部分获取的生成器； <p>调用方：调用委派生成器的客户端代码；即上面的main生成器函数</p> <p></p> <p>委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把结果直接发回给调用方。子生成器返回之后，解释器会抛出StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复</p> <pre><code>yield from list #等效于 for item in list:\n                           yield item\n</code></pre>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#yield-from_1","level":3,"title":"yield from所实现的数据传输通道","text":"","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8Eyield%E5%88%B0yield%20from/#_3","level":2,"title":"核心要点总结","text":"<ol> <li> <p>协程是一种轻量级的并发编程方式，相比多线程具有更高的执行效率和更低的资源消耗。</p> </li> <li> <p>yield关键字可以让函数变成生成器，实现基本的协程功能，通过send()方法在生产者和消费者之间传递数据。</p> </li> <li> <p>yield from是yield的增强语法，能够委派操作给子生成器，解决了yield复用性差的问题。</p> </li> <li> <p>协程有四种状态：GEN_CREATED（等待执行）、GEN_RUNNING（正在执行）、GEN_SUSPENDED（暂停状态）和GEN_CLOSED（执行结束）。</p> </li> <li> <p>协程的主要优势包括：极高的执行效率、无需多线程锁机制以及可以结合多进程利用多核CPU。</p> </li> <li> <p>通过inspect.getgeneratorstate()函数可以查看协程的当前状态。</p> </li> </ol>","path":["Python","Python协程详解：从yield到yield from"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/","level":1,"title":"Python字典详解：dict、defaultdict与OrderedDict","text":"<p>Python中字典的基础就是哈希表。</p> <p>下面的图表展示了三种字典类型的特性和使用场景：</p> <pre><code>graph LR\n    A[Python字典类型] --&gt; B(dict)\n    A --&gt; C(defaultdict)\n    A --&gt; D(OrderedDict)\n\n    B --&gt; B1[基本字典类型]\n    B --&gt; B2[无序存储]\n    B --&gt; B3[访问不存在键抛出KeyError]\n\n    C --&gt; C1[带默认值的字典]\n    C --&gt; C2[访问不存在键返回默认值]\n    C --&gt; C3[避免KeyError异常]\n    C --&gt; C4[适用于计数和分组场景]\n\n    D --&gt; D1[有序字典]\n    D --&gt; D2[保持插入顺序]\n    D --&gt; D3[内存消耗是dict的两倍]\n    D --&gt; D4[适用于需要维护顺序的场景]</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#_1","level":2,"title":"字典的基本操作","text":"","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#1","level":3,"title":"1. 访问字典元素","text":"<pre><code>dic['key']        # 直接通过键访问字典元素，如果键不存在会抛出KeyError异常\ndic.get('key')    # 通过get方法访问字典元素，即使键不存在也不会抛出异常，而是返回None\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#2","level":3,"title":"2. 删除字典元素","text":"<pre><code>dic.pop('key')  # 修复语法错误：原为 dic.pop['key']\n# 使用pop方法删除指定键的元素，并返回该键对应的值\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#3","level":3,"title":"3. 增加字典元素","text":"<pre><code>dic['key'] = value  # 通过赋值的方式向字典中添加新的键值对\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#4","level":3,"title":"4. 遍历字典","text":"<pre><code># 遍历key\nfor key in dic.keys():  # 获取字典的所有键并遍历\n    pass\n\n# 遍历value\nfor value in dic.values():  # 获取字典的所有值并遍历\n    pass\n\n# 遍历项\nfor item in dic.items():  # 获取字典的所有键值对并遍历，每个项是一个元组(key, value)\n    pass\n\n# 遍历key和value\nfor key, value in dic.items():  # 同时获取字典的键和值进行遍历\n    pass\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#5","level":3,"title":"5. 其他常用操作","text":"<pre><code># in判断\n'key' in dic           # 判断指定键是否存在于字典中\n'value' in dic.values()  # 判断指定值是否存在于字典的值中\n\n# 更新字典\ndic.update({'key': 'value'})  # 修复：原为 dic.update('key')\n# 使用update方法将另一个字典的键值对添加到当前字典中\n\n# 浅拷贝\ndic2 = dic.copy()  # 创建字典的一个浅拷贝副本\n\n# 设置默认值\ndic.setdefault('key', default=None)\n# **setdefault方法**虽然可以设置默认值,但一次只能设置一个key的默认value,\n# 更好的解决方案是**defaultdict**\nstrings = ('puppy', 'kitten', 'puppy', 'puppy',\n           'weasel', 'puppy', 'kitten', 'puppy')\ncounts = {}\nfor kw in strings:\n    # 如果键kw不存在，则设置默认值0，然后加1；如果存在则直接加1\n    counts[kw] = counts.setdefault(kw, 0) + 1\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#_2","level":2,"title":"字典合并","text":"<p>在实际开发中，我们经常需要将两个或多个字典合并。以下是几种常见的字典合并方法：</p> <pre><code>a = {'a': 3, 'b': 4}  # 定义第一个字典\nb = {'c': 5}          # 定义第二个字典\n\n# 方法1：使用dict构造函数和关键字参数展开\n# 注意：这种方法只适用于字符串键且是有效的Python标识符\nresult1 = dict(a, **b)  # 将字典a和字典b合并为新字典\n\n# 方法2：使用update方法（会修改原字典，相同键会被覆盖）\na.update(b)  # 将字典b的内容更新到字典a中，直接修改字典a\nprint(a)  # {'a': 3, 'b': 4, 'c': 5}\n\n# 方法3：使用for循环逐个添加键值对\na = {'a': 3, 'b': 4}  # 重置a\nfor k, v in b.items():  # 遍历字典b的每个键值对\n    a[k] = v  # 将字典b的键值对添加到字典a中\nprint(a)  # {'a': 3, 'b': 4, 'c': 5}\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#_3","level":2,"title":"字典创建","text":"<p>创建字典有多种方式，以下是一些常用的方法：</p> <pre><code># 方法1：直接使用花括号\ndict1 = {'one': 1, 'two': 2, 'three': 3}  # 直接通过花括号创建字典\n\n# 方法2：使用dict构造函数和关键字参数\ndict2 = dict(one=1, two=2, three=3)  # 通过关键字参数创建字典\n\n# 方法3：使用zip函数组合两个列表\nlist1 = ['one', 'two', 'three']  # 定义键列表\nlist2 = [1, 2, 3]                # 定义值列表\ndict3 = dict(zip(list1, list2))  # 使用zip函数将两个列表组合成字典\n\n# 方法4：使用已有字典和关键字参数\ndict4 = dict({'one': 1, 'three': 3}, two=2)  # 基于现有字典并添加新的键值对\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#defaultdict","level":2,"title":"默认值字典（defaultdict）","text":"<p>在使用普通字典时，如果访问一个不存在的键，会抛出 KeyError 异常。为了避免这种情况，我们可以使用 defaultdict。</p> <p>defaultdict 的作用在于，当字典里的键不存在但被查找时，不是返回 KeyError，而是返回一个默认值。</p> <pre><code>from collections import defaultdict\n\n# 创建不同类型的defaultdict\na = defaultdict(int)      # 默认值为0，适用于计数场景\nb = defaultdict(str)      # 默认值为空字符串\nc = defaultdict(dict)     # 默认值为空字典\nd = defaultdict(set)      # 默认值为空集合\n\nprint(a[0])  # 访问不存在的键0，返回默认值0\nprint(b[1])  # 访问不存在的键1，返回默认值空字符串\nprint(c[2])  # 访问不存在的键2，返回默认值空字典{}\nprint(d[3])  # 访问不存在的键3，返回默认值空集合set()\n</code></pre> <p>从上面的例子可以看出，defaultdict 会对所有不存在的键返回相应的默认值。</p> <ol> <li>使用 list 参数创建列表字典</li> </ol> <pre><code>from collections import defaultdict\n\n# 将K-V对序列转换为列表字典\na = defaultdict(list)  # 创建一个默认值为空列表的defaultdict\ns = [('a', 1), ('a', 3), ('v', 3)]  # 定义键值对序列\nfor k, v in s:  # 遍历键值对序列\n    a[k].append(v)  # 将值v添加到键k对应的列表中\nprint(a)\n</code></pre> <p>输出： <pre><code>defaultdict(&lt;class 'list'&gt;, {'a': [1, 3], 'v': [3]})\n</code></pre></p> <ol> <li>使用 int 参数创建计数器</li> </ol> <pre><code>from collections import defaultdict\n\n# 用作计数器\na = defaultdict(int)  # 创建一个默认值为0的defaultdict，适合用作计数器\ns = 'apple'           # 定义字符串\nfor k in s:           # 遍历字符串中的每个字符\n    a[k] += 1         # 对每个字符出现次数进行累加计数\nprint(a)\n</code></pre> <p>输出： <pre><code>defaultdict(&lt;class 'int'&gt;, {'a': 1, 'p': 2, 'l': 1, 'e': 1})\n</code></pre></p> <ol> <li>使用 set 参数创建集合字典</li> </ol> <pre><code>from collections import defaultdict\n\n# 用作集合字典\ns = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]\n# 定义键值对序列，其中包含重复的键值对\nd = defaultdict(set)  # 创建一个默认值为空集合的defaultdict\nfor k, v in s:       # 遍历键值对序列\n    d[k].add(v)      # 将值v添加到键k对应的集合中，自动去重\nprint(d)\na = sorted(d.items())  # 对字典项进行排序\nprint(a)\n</code></pre> <p>输出： <pre><code>defaultdict(&lt;class 'set'&gt;, {'red': {1, 3}, 'blue': {2, 4}})\n[('blue', {2, 4}), ('red', {1, 3})]\n</code></pre></p> <ol> <li>使用自定义函数作为默认值工厂</li> </ol> <p>我们可以使用不带参数的可调用对象，它会返回该函数的返回结果作为默认值。</p> <pre><code>from collections import defaultdict\n\ndef default_func():\n    return '默认值'  # 自定义默认值函数，返回固定字符串\n\ndf = defaultdict(default_func)  # 使用自定义函数作为默认值工厂\nprint(df['32'])  # 访问不存在的键'32'，将调用default_func函数返回'默认值'\n</code></pre> <p>更简洁的方式是使用 lambda 函数来定义简单的默认值函数：</p> <pre><code>from collections import defaultdict\n\ndf = defaultdict(lambda: 0)      # 使用lambda函数定义默认值为0\nds = defaultdict(lambda: 'apple')  # 使用lambda函数定义默认值为'apple'\nprint(df['32'])  # 输出：0，访问不存在的键'32'，返回默认值0\nprint(ds['2'])   # 输出：apple，访问不存在的键'2'，返回默认值'apple'\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#ordereddict","level":2,"title":"有序字典（OrderedDict）","text":"<p>dict 和 defaultdict 都是无序的，而 OrderedDict 是有序的。</p> <p>在 OrderedDict 内部维护着一个根据键插入顺序排列的双向链表，每当有新元素插入时，会被放到链表的尾部。</p> <p>OrderedDict 的大小是普通 dict 的两倍，所以需要权衡顺序和额外的内存消耗。</p> <pre><code>from collections import OrderedDict\n\nd = OrderedDict()  # 创建一个有序字典\n\n# move_to_end 方法\nd.move_to_end('key')           # 将键为'key'的元素移到末尾\nd.move_to_end('key', last=False)  # 将键为'key'的元素移到开头\n\n# popitem 方法\nd.popitem(last=True)           # 删除并返回最后一个键值对\nd.popitem(last=False)          # 删除并返回第一个键值对\n\n# 排序操作\n# 按照 key 排序\nsorted_items = sorted(d.items(), key=lambda i: i[0])  # 按键进行排序\n\n# 按照 value 排序\nsorted_items = sorted(d.items(), key=lambda i: i[1])  # 按值进行排序\n</code></pre>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#dictdefaultdictordereddict","level":2,"title":"dict、defaultdict、OrderedDict 比较","text":"功能/方法 dict defaultdict OrderedDict 作用说明 d.copy √ 用于支持 copy.copy d.default_factory √ 在 missing 函数中被调用的函数，用来给未找到的元素初始化 d.missing √ 当 getitem 找不到对应键的时候，该方法会被调用 d.move_to_end(k, last=True) √ 把键为 k 的元素移动到最后或最前 d.reversed() √ 返回倒序的键的迭代器 d.popitem() √ √ √ dict 和 defaultdict 是随机移除，而 OrderedDict 是移除最先插入的元素","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3%EF%BC%9Adict%E3%80%81defaultdict%E4%B8%8EOrderedDict/#_4","level":2,"title":"核心要点总结","text":"<ol> <li> <p>哈希表原理：Python字典基于哈希表实现，提供了高效的键值对存储和查找功能。</p> </li> <li> <p>defaultdict的使用：相比普通字典，defaultdict可以在访问不存在的键时自动创建默认值，避免KeyError异常，特别适用于计数、分组等场景。</p> </li> <li> <p>OrderedDict特性：OrderedDict保持了键值对的插入顺序，在需要维护元素顺序的场景下非常有用，但内存消耗是普通字典的两倍。</p> </li> <li> <p>字典操作方法：掌握字典的基本操作如访问、增删、遍历、更新等方法，以及setdefault等高级用法，能有效提高代码效率。</p> </li> <li> <p>字典合并技巧：了解多种字典合并方法，包括dict构造函数、update方法和循环添加等方式，可以根据具体需求选择最适合的方法。</p> </li> <li> <p>字典创建方式：熟悉多种字典创建方式，包括直接定义、构造函数、zip函数组合等，能够灵活应对不同的创建需求。</p> </li> </ol> <p>参考资料： 理解 Python 语言中的 defaultdict-团子的小窝</p> <p>三种字典的比较-biu嘟</p>","path":["Python","Python字典详解：dict、defaultdict与OrderedDict"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/","level":1,"title":"Python容器、可迭代对象、迭代器与生成器详解","text":"<p>理一理可迭代对象,迭代器,生成器之间的联系.</p> <p></p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#_1","level":2,"title":"概念关系图","text":"<pre><code>graph LR\n    A[容器Container] --&gt; B[可迭代对象Iterable]\n    B --&gt; C[迭代器Iterator]\n    C --&gt; D[生成器Generator]\n\n    A -- \"存储在内存中\" --&gt; B\n    B -- \"实现__iter__方法\" --&gt; C\n    C -- \"实现__next__方法\" --&gt; D\n    D -- \"使用yield关键字\" --&gt; D</code></pre>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#container","level":2,"title":"容器Container","text":"<p>1.容器是一个存储多个元素的数据结构.</p> <p>2.容器中的元素可以通过迭代获取.</p> <p>3.所有容器中的元素被存放在内存中.</p> <p>4.常见的容器比如 list,tuple,dict,set,str.也都是可迭代对象(Iterable)</p> <pre><code>from collections import Iterable\na = ['test','test2']  # 创建一个包含两个字符串元素的列表\nfor i in a: # 通过for循环迭代获取列表中的每个元素\n  print(i)  # 打印当前元素\nisinstance(a,Iterable) # 检查列表a是否为可迭代对象，返回True\n</code></pre>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#iterable","level":2,"title":"可迭代对象Iterable","text":"<p>可迭代对象是可以通过被迭代获取的对象.</p> <p>内部定义了可返回迭代器的_iter_()方法.</p> <p>比如:</p> <pre><code>x = [1, 2, 3]  # 创建一个包含三个整数的列表\nfor elem in x:  # 遍历列表中的每个元素\n  print(elem)   # 打印当前元素\n</code></pre> <p>x列表是一个可迭代对象,在for循环中调用iter()方法变成迭代器,遍历x实际上是调用elem=next(x).</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#iterator","level":2,"title":"迭代器Iterator","text":"<p>迭代器是一个带状态的对象,该状态用于记录当前迭代所在位置,以方便下次迭代的时候获取正确的元素.</p> <p>Iterator实现了<code>__iter__</code>和<code>__next__</code>方法.</p> <p>迭代器不会一次性把所有的元素都加载到内存,而是在需要的时候才会生成返回结果.</p> <p>1.可迭代对象!=迭代器.</p> <p>2.迭代器带状态.</p> <p>3.迭代器不会直接加载到内存.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#generator","level":2,"title":"生成器generator","text":"<p>生成器是一种特殊的迭代器.</p> <p>生成器可以传入数据进行计算,并根据变量内容计算结果后返回.</p> <p>使用send方法传入数据.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#generator-func","level":3,"title":"生成器函数generator func","text":"<p>含有yield关键字的函数就是生成器函数.</p> <pre><code>def d():\n    print('第一次调用')\n    sum = 0\n    # 第一次c.send(None)只执行到 yield sum\n    # 再次进入时执行 value = yield sum,将yield 赋值给sum,然后赋值给value\n    value = yield sum\n    sum = value + sum\n    print('sum的值为:%d' %sum)\n    print('value%d' %value) # 输出value1\n    # c.send(1)只执行到yield sum, 再次进入时执行 value = 2\n    value = yield sum\n    print('value%d' %value) # 输出value2\n    yield sum\n\n\nc = d()  # 创建生成器对象，此时函数并未执行\nd = c.send(None)  # 启动生成器，执行到第一个yield，返回sum的值并赋值给d\nprint('生成器传出的值为%d' % d)\nd = c.send(1)  # 传入数值1，通过yield传递给value，继续执行到第二个yield\nprint('第二次调用返回值为%d' % d)\nd = c.send(2)  # 传入数值2，继续执行到第三个yield\nprint('第三次调用返回值为%d' % d)\n</code></pre> <p>可以看到,yield将sum的值传递给了<code>调用方</code>,将send()方法递进来的<code>1</code>传递给了<code>value</code>.</p> <p>保存了迭代器的状态.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#generator-expression","level":3,"title":"生成器表达式generator expression","text":"<p>生成器表达式是列表生成式的生成器版本.返回一个生成器对象.</p> <pre><code>from collections import Iterator\na = (x*x for x in range(10))  # 创建一个生成器表达式，计算0-9的平方\nprint(isinstance(a,Iterator))   # 检查a是否为迭代器对象，返回True\nfor x in a:                    # 遍历生成器中的每个值\n  print(x)                     # 打印当前值\n</code></pre>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#_2","level":3,"title":"生成器的优势","text":"<p>延迟加载:在处理长序列问题时,更加节省存储空间.</p> <p>比如打印一个斐波那契数列,原始方法如下:</p> <pre><code>def fab(max):\n    n, a, b = 0, 0, 1   # 初始化计数器n和斐波那契数列的前两个数a,b\n    L = []               # 创建空列表存储斐波那契数列\n    while n &lt; max:       # 当计数器小于最大值时继续循环\n        L.append(b)      # 将当前斐波那契数添加到列表中\n        a, b = b, a + b  # 计算下一个斐波那契数\n        n += 1           # 计数器加1\n    return L             # 返回完整的斐波那契数列\nprint(fab(20))          # 打印前20个斐波那契数\n</code></pre> <p>所有元素都存放在列表L里,空间开销较大.</p> <p>使用生成器的方法如下:</p> <pre><code>def fab(max):\n    n, a, b = 0, 0, 1     # 初始化计数器n和斐波那契数列的前两个数a,b\n    while n &lt; max:         # 当计数器小于最大值时继续循环\n        yield b            # 每次在这里中断, 把b的值传递给i, 同时保存中断时的状态\n        a, b = b, a + b    # 计算下一个斐波那契数\n        n += 1             # 计数器加1\nfor i in fab(20):          # 使用生成器遍历前20个斐波那契数\n    print(i)               # 打印当前斐波那契数\n</code></pre> <p>这种方法不需要额外的列表空间开销.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#send","level":3,"title":"send()方法是交互的","text":"<pre><code>def my_generator(n):\n    for i in range(n):     # 循环n次\n        yield i            # 依次产出0到n-1的数字\ng = my_generator(5)        # 创建生成器对象，可产出0-4的数字\nprint(next(g))             # 获取下一个值，输出0\nprint(next(g))             # 获取下一个值，输出1\nprint(g.send(100))         # 发送数据100，但仍然返回下一个值2\nprint(next(g))             # 获取下一个值，输出3\nprint(next(g))             # 获取下一个值，输出4\n</code></pre> <p>可以看到第7行的g.send()方法输出了本来next()方法应该输出2.</p> <p>1.send()的主要作用是当需要手动更改生成器里面的某一个值并且使用它，则发送进去一个数据保存到yield语句的返回值，以提供后续使用.</p> <p>2.send()的返回值就是那个本来应该被迭代出来的那个值。这样既可以保证能够传入新的值，原来的值也不会弄丢.</p> <p>总结</p> 对象 特点 功能 iterable 实现了<code>__iter__()</code>方法 返回一个iterator iterator 实现了<code>__iter__()</code>和<code>__next__()</code>方法.数据需要时才会存储到内存中 逐个传出数据 generator yield替换了<code>__next__()</code>方法,可以中断,保存了<code>状态</code>的迭代器 逐个传入/传出数据 container 元素都存储在内存中元素可以通过迭代获取","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3/#_3","level":2,"title":"核心要点总结","text":"<ol> <li> <p>容器(Container)：存储多个元素的数据结构，所有元素都被存放在内存中，常见的容器包括list、tuple、dict、set、str等。</p> </li> <li> <p>可迭代对象(Iterable)：可通过迭代获取的对象，内部定义了可返回迭代器的<code>__iter__()</code>方法。</p> </li> <li> <p>迭代器(Iterator)：带状态的对象，实现了<code>__iter__()</code>和<code>__next__()</code>方法，不会一次性加载所有元素到内存，在需要时才会生成返回结果。</p> </li> <li> <p>生成器(Generator)：一种特殊的迭代器，使用yield关键字，可以中断并保存状态，支持传入数据进行计算。</p> </li> <li> <p>生成器函数：包含yield关键字的函数，每次调用会返回一个生成器对象。</p> </li> <li> <p>生成器表达式：列表生成式的生成器版本，返回一个生成器对象，具有延迟加载的特性。</p> </li> <li> <p>send()方法：用于向生成器传入数据并获取下一个值，实现生成器与调用方的数据交互。                   |</p> </li> </ol>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/","level":1,"title":"Python虚拟环境演进历程","text":"","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#_1","level":2,"title":"全局安装阶段","text":"<p>在Python早期，开发者通常直接使用pip安装包，这种方式会将所有库安装到全局系统环境中。</p> <pre><code>pip install package_name\n</code></pre> <p>这种方法的主要问题是会导致库依赖冲突。当多个项目需要不同版本的同一个库时，全局安装无法满足这种需求，容易造成版本冲突，影响项目的稳定性和可维护性。</p> <p>此外，全局安装还存在以下不足：</p> <ol> <li>环境污染：所有项目共享同一个Python环境，容易造成不必要的依赖混乱</li> <li>版本控制困难：难以精确控制每个项目所需的依赖版本</li> <li>部署复杂：在不同的开发环境或生产环境中部署时，需要手动管理依赖关系</li> <li>安全风险：全局安装的包可能存在安全漏洞，影响整个系统的稳定性</li> </ol> <p>为了解决这些问题，Python社区开始探索更好的依赖管理方案，从而推动了虚拟环境技术的发展。</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#venv","level":2,"title":"venv虚拟环境阶段","text":"<p>随着Python的发展，官方在Python 3.3版本中引入了<code>venv</code>模块，用于创建轻量级的虚拟环境。这标志着Python依赖管理进入了一个新阶段。</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # Linux/Mac\n# 或\n.venv\\Scripts\\activate.bat  # Windows\n</code></pre> <p>虚拟环境通过修改Python的<code>sys.path</code>变量来实现环境隔离，这个变量存储着Python查找模块的路径列表。激活虚拟环境后，<code>sys.path</code>会被修改，优先从虚拟环境的目录中查找模块。</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#_2","level":3,"title":"依赖管理与环境复现","text":"<p>为了更好地管理项目依赖和实现环境复现，开发者开始使用<code>requirements.txt</code>文件：</p> <pre><code>pip freeze &gt; requirements.txt\n</code></pre> <p>该命令会将当前环境中所有已安装的包及其版本导出到文本文件中：</p> <pre><code>flask==3.1.1\nblinker==1.9.0\nclick==8.2.1\nitsdangerous==2.2.0\njinja2==3.1.6\nmarkupsafe==3.0.2\nwerkzeug==3.1.3\n</code></pre> <p>其他开发者可以通过以下命令快速重建相同的环境：</p> <pre><code>pip install -r requirements.txt\n</code></pre>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#pyprojecttoml","level":3,"title":"引入pyproject.toml","text":"<p>然而，使用<code>requirements.txt</code>的方式也存在问题。它会将直接依赖和间接依赖全部列出，导致依赖关系混乱。当某个依赖被卸载后，它所引入的间接依赖可能会继续保留在环境中，长期积累会产生冗余。</p> <p>为了解决这个问题，Python社区引入了<code>pyproject.toml</code>文件，将直接依赖明确列出：</p> <pre><code>[project]\nname = \"proj\"\nversion = \"0.1.0\"\ndependencies = [\n    \"Flask==3.1.1\"\n]\n</code></pre> <p>安装时可以直接使用：</p> <pre><code>pip install -e .\n</code></pre> <p>这种方式能够更清晰地管理项目的直接依赖，避免间接依赖的干扰。</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#_3","level":2,"title":"现代依赖管理工具阶段","text":"<p>尽管<code>venv</code>和<code>pyproject.toml</code>解决了部分问题，但在实际开发过程中仍存在一些不便之处。例如，当需要引入新的库时，开发者需要手动查找版本号并维护<code>pyproject.toml</code>文件。</p> <p>为了解决这些问题，社区推出了多种现代化的依赖管理工具，包括UV、Poetry和PDM。这些工具在底层依然使用<code>venv</code>和<code>pip</code>，但提供了更加友好的用户体验。</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#uv","level":3,"title":"UV","text":"<p>UV是由Ruff团队开发的新一代Python包管理器，以速度为主要优势。它的设计目标是替代pip和pip-tools，提供更快的依赖解析和安装体验。</p> <p>主要特性： 1. 极快的性能：使用Rust编写，安装速度比pip快10-100倍 2. 统一接口：整合了包安装、脚本执行、项目构建等功能 3. 兼容性强：保持与pip命令的兼容性，降低学习成本 4. 多功能集成：还可以管理Python解释器版本</p> <p>常见使用命令和场景：</p> <pre><code># 安装UV（通过pip）\npip install uv\n\n# 创建项目并初始化虚拟环境\nuv init my_project\ncd my_project\n\n# 添加依赖（自动更新pyproject.toml）\nuv add flask\nuv add pytest --group dev  # 添加开发依赖\n\n# 安装所有依赖\nuv sync\n\n# 仅安装生产依赖（排除开发依赖）\nuv sync --no-dev\n\n# 运行脚本（自动在虚拟环境中执行）\nuv run python main.py\n\n# 运行测试\nuv run pytest\n\n# 构建包\nuv build\n\n# 发布包\nuv publish\n\n# 管理Python版本\nuv python install 3.11\nuv python pin 3.11\n</code></pre> <p>适用场景： - 需要快速创建和管理Python项目的开发团队 - 对依赖安装速度有较高要求的CI/CD流水线 - 希望使用统一工具链管理整个Python开发生命周期的开发者</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#poetry","level":3,"title":"Poetry","text":"<p>Poetry是一个现代化的Python依赖管理工具，它简化了包管理和项目设置流程。主要特性包括：</p> <ol> <li>简化的依赖管理：通过<code>pyproject.toml</code>文件统一管理项目信息和依赖</li> <li>精确的依赖解析：能够处理复杂的依赖关系，避免版本冲突</li> <li>虚拟环境管理：自动创建和管理虚拟环境</li> <li>构建系统集成：支持打包和发布Python包</li> </ol> <p>常见使用命令和场景：</p> <pre><code># 安装Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# 初始化新项目\npoetry init\n\n# 添加依赖\npoetry add flask\npoetry add pytest --group dev\n\n# 安装依赖\npoetry install\npoetry install --no-dev  # 仅安装生产依赖\n\n# 更新依赖\npoetry update\n\n# 激活虚拟环境\npoetry shell\n\n# 运行命令\npoetry run python main.py\npoetry run pytest\n\n# 构建和发布\npoetry build\npoetry publish\n</code></pre> <p>适用场景： - 需要严格依赖版本控制的项目 - 计划发布Python包的开源项目维护者 - 喜欢声明式依赖管理的开发者</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#pdm","level":3,"title":"PDM","text":"<p>PDM（Python Development Master）是另一个现代化的Python包管理工具，遵循PEP 517和PEP 518标准。</p> <p>主要特性： 1. 标准化：严格遵循Python打包标准 2. 灵活性：支持多种工作流和项目结构 3. 高效性：提供快速的依赖解析和安装 4. 易用性：简洁直观的命令行界面</p> <p>常见使用命令和场景：</p> <pre><code># 安装PDM\npip install pdm\n\n# 初始化项目\npdm init\n\n# 添加依赖\npdm add flask\npdm add pytest --dev\n\n# 安装依赖\npdm install\npdm install --prod  # 仅安装生产依赖\n\n# 更新依赖\npdm update\n\n# 运行命令\npdm run python main.py\npdm run pytest\n\n# 构建包\npdm build\n\n# 发布包\npdm publish\n</code></pre> <p>适用场景： - 希望使用符合Python标准的工具的开发者 - 需要在多种不同环境中工作的项目 - 对依赖解析有特殊要求的复杂项目</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#_4","level":2,"title":"各阶段特点、优势与不足对比分析","text":"<p>通过对Python虚拟环境技术演进历程的梳理，我们可以总结各个阶段的特点、优势与不足：</p> 阶段 特点 优势 不足 全局安装 直接使用pip安装到系统环境 简单直接，无需额外配置 依赖冲突严重，环境易污染，版本管理困难 venv虚拟环境 使用标准库创建隔离环境 实现环境隔离，支持依赖导出 手动管理繁琐，间接依赖混乱，缺乏精确版本控制 现代工具(Poetry/UV/PDM) 集成化依赖管理解决方案 自动化程度高，精确依赖解析，良好用户体验 学习成本，工具锁定风险，生态系统成熟度差异","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#_5","level":3,"title":"详细分析","text":"<ol> <li>全局安装阶段：</li> <li>特点：最原始的包管理方式，所有项目共享同一环境</li> <li>优势：操作简单，无需额外工具</li> <li> <p>不足：严重的依赖冲突问题，难以实现环境复现</p> </li> <li> <p>venv虚拟环境阶段：</p> </li> <li>特点：通过标准库实现环境隔离，配合requirements.txt管理依赖</li> <li>优势：有效解决环境隔离问题，成为Python项目开发的标准实践</li> <li> <p>不足：依赖管理仍需手动操作，间接依赖管理不精确</p> </li> <li> <p>现代依赖管理工具阶段：</p> </li> <li>特点：集成化解决方案，自动化依赖管理，精确版本控制</li> <li>优势：提升开发效率，改善用户体验，更好处理复杂依赖关系</li> <li>不足：需要学习新工具，可能存在生态系统兼容性问题</li> </ol>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%BC%94%E8%BF%9B%E5%8E%86%E7%A8%8B/#_6","level":2,"title":"总结","text":"<p>Python虚拟环境技术的演进反映了开发者对更高效、更可靠开发工具的不断追求。从最初的全局安装方式到现代的集成化依赖管理工具，每一次进步都解决了前一阶段存在的核心问题：</p> <ol> <li>环境隔离：通过venv等工具实现项目间的环境隔离，避免依赖冲突</li> <li>依赖管理：从简单的requirements.txt到精确的依赖解析和版本控制</li> <li>用户体验：自动化操作减少手动干预，提升开发效率</li> </ol> <p>随着技术的不断发展，Python的依赖管理生态系统也在持续完善。开发者应根据项目需求和个人偏好选择合适的工具，在保证开发效率的同时，确保项目的稳定性和可维护性。</p> <p>未来，我们可以预见Python依赖管理工具将继续朝着更智能、更高效的方向发展，为开发者提供更好的编程体验.</p>","path":["Python","Python虚拟环境演进历程"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/","level":1,"title":"Python进阶-数据结构与算法进阶训练","text":"<p>训练数据筛选,排序,查找,统计,记录等方面的处理能力.</p>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#21","level":2,"title":"2.1 如何在列表,字典,集合中根据条件筛选数据","text":"<p>在实际开发中，我们经常需要根据特定条件从数据结构中筛选数据。Python提供了多种高效的方法来实现这一点。</p> <pre><code>from random import randint\n\n# 原始数据\na = [1, 2, 3, 4, 5, -6, 6, 7, 8, -2, -4]\n\n# 方法1: 使用filter函数\n# filter函数接受一个函数和一个可迭代对象，返回满足条件的元素\nb = list(filter(lambda x: x &gt; 0, a))\nprint(\"使用filter筛选正数:\", b)\n\n# 方法2: 使用列表推导式（推荐）\n# 列表推导式通常比filter更高效，且代码更易读\nc = [i for i in a if i &gt; 0]\nprint(\"使用列表推导式筛选正数:\", c)\n\n# 字典推导式示例\n# 生成一个学生成绩字典\nd = {x: randint(60, 100) for x in range(1, 6)}\nprint(\"学生成绩字典:\", d)\n\n# 筛选出成绩大于90的学生\ne = {k: v for k, v in d.items() if v &gt; 90}\nprint(\"成绩大于90的学生:\", e)\n\n# 集合推导式示例\n# 将列表转换为集合并筛选能被3整除的数\nf = set(a)\n# 注意：原代码中的错误已修正，应该是 x % 3 == 0 而不是 a % 3 == 0\ng = {x for x in f if x % 3 == 0}\nprint(\"能被3整除的数:\", g)\n</code></pre> <p>性能优化提示： - 列表推导式通常比filter函数更快，因为它在C语言层面进行了优化 - 对于大数据集，考虑使用生成器表达式以节省内存</p>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#22","level":2,"title":"2.2 如何为元组中的每个元素命名,提高程序可读性","text":"<p>在处理元组数据时，使用索引访问元素会降低代码可读性。我们可以通过以下方法为元组元素命名：</p> <pre><code># 实际案例：学生信息系统中数据为固定格式:(名字,年龄,性别,邮箱...)\n# 为了减少存储开销,对每个学生信息用元组表示:\nstudent_data = ('Jim', 16, 'male', 'jim@qq.com')\n\n# 方案1: 定义数值常量（不推荐）\n# 这种方法容易出错且不易维护\nNAME_IDX = 0\nAGE_IDX = 1\nSEX_IDX = 2\nEMAIL_IDX = 3\n\nprint(\"方案1 - 使用索引常量:\")\nprint(f\"姓名: {student_data[NAME_IDX]}, 年龄: {student_data[AGE_IDX]}\")\n\n# 方案2: 使用collections.namedtuple（推荐）\n# namedtuple是tuple的子类，为每个位置分配名称，提高代码可读性\nfrom collections import namedtuple\n\n# 创建一个Student类，具有name, age, sex, email四个字段\nStudent = namedtuple('Student', ['name', 'age', 'sex', 'email'])\n\n# 创建Student实例\ns = Student('Jim', 16, 'male', 'jim@qq.com')\nprint(\"\\n方案2 - 使用namedtuple:\")\nprint(f\"学生信息: {s}\")\nprint(f\"姓名: {s.name}, 邮箱: {s.email}\")\n# 验证s确实是tuple的子类\nprint(f\"s是tuple的子类: {isinstance(s, tuple)}\")\n\n# namedtuple的优势：\n# 1. 不可变性：与tuple一样，namedtuple创建后不可修改\n# 2. 内存效率：比定义完整类更节省内存\n# 3. 可读性：通过字段名访问元素，代码更清晰\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#23","level":2,"title":"2.3 如何统计序列中元素的出现频度","text":"<p>统计元素出现频度是数据分析中的常见需求。Python的collections.Counter提供了高效的解决方案。</p> <pre><code>from collections import Counter\nfrom random import randint\n\n# 示例1: 统计随机序列中元素的出现频度\ndata = [randint(1, 20) for x in range(20)]\nprint(\"随机数据:\", data)\n\n# 使用Counter统计频度\nc = Counter(data)\nprint(\"元素频度统计:\", c)\n\n# 获取出现频度最高的3个元素\nprint(\"出现频度最高的3个元素:\", c.most_common(3))\n\n# 示例2: 统计文本中单词的出现频度\ntext = \"Python is great Python is powerful Python is easy to learn\"\nwords = text.split()\nword_counter = Counter(words)\nprint(\"\\n单词频度统计:\", word_counter)\nprint(\"最常见的3个单词:\", word_counter.most_common(3))\n\n# Counter的其他有用方法\nprint(\"所有元素(展开):\", list(c.elements()))  # 展开所有元素\nprint(\"总元素数:\", sum(c.values()))  # 计算总元素数\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#24","level":2,"title":"2.4 如何根据字典中值的大小,对字典中的项排序","text":"<p>在处理字典数据时，经常需要根据值的大小进行排序。</p> <pre><code>from random import randint\n\n# 某班成绩以字典形式存储\nd = {x: randint(60, 100) for x in 'abcdefghij'}\nprint(\"学生成绩:\", d)\n\n# 方法1: 利用zip将字典数据转化成元组进行排序\n# zip函数将两个序列组合成元组序列\nsorted_scores_zip = sorted(zip(d.values(), d.keys()))\nprint(\"\\n方法1 - 使用zip排序(成绩升序):\", sorted_scores_zip)\n\n# 方法2: 传递sorted函数的key参数（推荐）\n# 使用lambda函数指定按值排序\nsorted_scores_key = sorted(d.items(), key=lambda x: x[1])\nprint(\"方法2 - 使用key参数排序(成绩升序):\", sorted_scores_key)\n\n# 降序排列\nsorted_scores_desc = sorted(d.items(), key=lambda x: x[1], reverse=True)\nprint(\"按成绩降序排列:\", sorted_scores_desc)\n\n# 按键排序\nsorted_by_keys = sorted(d.items(), key=lambda x: x[0])\nprint(\"按键排序:\", sorted_by_keys)\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#25-key","level":2,"title":"2.5 如何快速找到多个字典中的公共键(key)?","text":"<p>在处理多个字典时，有时需要找出它们的公共键。</p> <pre><code>from random import randint, sample\nfrom functools import reduce\n\n# 模拟三轮球员进球统计\nplayers = 'abcdefghijklmnopqrstuvwxyz'\ns1 = {x: randint(1, 4) for x in sample(players, randint(3, 6))}\ns2 = {x: randint(1, 4) for x in sample(players, randint(3, 6))}\ns3 = {x: randint(1, 4) for x in sample(players, randint(3, 6))}\n\nprint(\"第一轮进球统计:\", s1)\nprint(\"第二轮进球统计:\", s2)\nprint(\"第三轮进球统计:\", s3)\n\n# 方法1: 使用集合的交集操作\n# dict.keys()返回字典键的视图，可以转换为集合\ncommon_keys = set(s1.keys()) &amp; set(s2.keys()) &amp; set(s3.keys())\nprint(\"\\n方法1 - 使用集合交集找到公共键:\", common_keys)\n\n# 方法2: 使用reduce函数（更优雅）\n# reduce函数对序列中的元素进行累积操作\ncommon_keys_reduce = reduce(lambda a, b: a &amp; b, map(dict.keys, [s1, s2, s3]))\nprint(\"方法2 - 使用reduce找到公共键:\", common_keys_reduce)\n\n# 方法3: 使用集合的intersection方法\ncommon_keys_intersection = set(s1.keys()).intersection(s2.keys(), s3.keys())\nprint(\"方法3 - 使用intersection方法:\", common_keys_intersection)\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#26","level":2,"title":"2.6 如何让字典保持有序","text":"<p>在某些场景下，我们需要字典保持插入顺序。</p> <pre><code># Python 3.7+中，普通字典已经保持插入顺序\n# 但在需要明确控制或在旧版本Python中，可以使用OrderedDict\n\nfrom collections import OrderedDict\nfrom random import randint\n\n# 使用OrderedDict保持插入顺序\nd = OrderedDict()\nd['Jim'] = (1, 35)   # 第1名，用时35分钟\nd['Leo'] = (2, 34)   # 第2名，用时34分钟\nd['David'] = (3, 40) # 第3名，用时40分钟\n\nprint(\"OrderedDict中的选手成绩:\")\nfor k in d:\n    print(f\"  {k}: {d[k]}\")\n\nprint(\"OrderedDict内容:\", d)\n\n# 普通字典在Python 3.7+中也保持顺序\nnormal_dict = {}\nnormal_dict['Jim'] = (1, 35)\nnormal_dict['Leo'] = (2, 34)\nnormal_dict['David'] = (3, 40)\n\nprint(\"\\n普通字典中的选手成绩:\")\nfor k in normal_dict:\n    print(f\"  {k}: {normal_dict[k]}\")\n\n# OrderedDict的特殊方法\nd.move_to_end('Jim')  # 将Jim移到末尾\nprint(\"\\n将Jim移到末尾后:\", d)\n\n# popitem方法可以指定是否从末尾弹出\nlast_item = d.popitem(last=True)   # 弹出最后一个\nfirst_item = d.popitem(last=False) # 弹出第一个\nprint(f\"弹出的最后一项: {last_item}\")\nprint(f\"弹出的第一项: {first_item}\")\nprint(\"剩余项:\", d)\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#27-n","level":2,"title":"2.7 如何实现用户的历史记录功能(最多 n 条)?","text":"<p>在交互式程序中，保存用户历史记录是常见的需求。</p> <pre><code>from random import randint\nfrom collections import deque\n\n# 生成一个随机数作为答案\nN = randint(0, 100)\nprint(\"欢迎来到猜数字游戏！我已经想好了一个0-100之间的数字。\")\n\n# 使用deque实现固定长度的历史记录队列\n# maxlen参数指定最大长度，超出时自动删除最早记录\nhistory = deque([], 5)\n\ndef guess(k):\n    \"\"\"判断猜测结果\"\"\"\n    if k == N:\n        print('恭喜你，猜对了！')\n        return True\n    elif k &lt; N:\n        print('太小了，请再试试')\n    else:\n        print('太大了，请再试试')\n    return False\n\n# 游戏主循环\n# 注意：在实际环境中运行时取消注释以下代码\n\"\"\"\nwhile True:\n    line = input('请输入你猜的数字 (输入h查看历史记录, q退出): ')\n\n    # 处理特殊命令\n    if line == 'h':\n        print(f'历史记录 (最近{len(history)}条): {list(history)}')\n        continue\n    elif line == 'q':\n        print('游戏结束')\n        break\n\n    # 验证输入是否为数字\n    if line.isdigit():\n        k = int(line)\n        # 添加到历史记录\n        history.append(k)\n\n        # 判断猜测结果\n        if guess(k):\n            print(f'答案就是 {N}')\n            break\n    else:\n        print('请输入一个有效的数字')\n\"\"\"\n\n# deque的优势：\n# 1. 双端操作：可以从两端高效地添加和删除元素\n# 2. 固定长度：通过maxlen参数自动维护长度\n# 3. 性能优异：在两端操作的时间复杂度为O(1)\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#_1","level":2,"title":"新增章节：性能优化与时间复杂度分析","text":"<p>在实际开发中，了解数据结构和算法的时间复杂度对于编写高效代码至关重要。</p>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#_2","level":3,"title":"常见操作的时间复杂度","text":"<pre><code># 列表操作的时间复杂度\n# 创建一个大列表用于测试\nlarge_list = list(range(10000))\n\n# O(1) - 常数时间操作\n# 访问特定索引的元素\nelement = large_list[5000]  # O(1)\n\n# O(n) - 线性时间操作\n# 在列表末尾添加元素\nlarge_list.append(9999)  # O(1) 平均情况\n\n# 在列表开头插入元素（低效）\n# large_list.insert(0, 0)  # O(n) - 需要移动所有后续元素\n\n# O(n) - 查找元素\nif 5000 in large_list:  # O(n) - 需要遍历列表\n    pass\n\n# 字典操作的时间复杂度（平均情况）\nlarge_dict = {i: i**2 for i in range(10000)}\n\n# O(1) - 常数时间操作\nvalue = large_dict[5000]  # O(1) 平均情况\nlarge_dict[10000] = 100000000  # O(1) 平均情况\n\n# 集合操作的时间复杂度（平均情况）\nlarge_set = set(range(10000))\n\n# O(1) - 常数时间操作\nlarge_set.add(10000)  # O(1) 平均情况\nif 5000 in large_set:  # O(1) 平均情况\n    pass\n\n# deque操作的时间复杂度\nfrom collections import deque\ndq = deque(range(10000))\n\n# O(1) - 两端操作\ndq.appendleft(0)  # O(1) - 左端添加\ndq.append(10000)  # O(1) - 右端添加\ndq.popleft()      # O(1) - 左端删除\ndq.pop()          # O(1) - 右端删除\n\n# O(n) - 中间操作\n# dq.insert(5000, 999)  # O(n) - 在中间插入\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#_3","level":3,"title":"性能优化技巧","text":"<pre><code>import time\nfrom collections import deque\n\n# 技巧1: 选择合适的数据结构\n# 场景：需要频繁在两端添加/删除元素\n\n# 使用列表（低效）\ndef list_performance_test():\n    lst = []\n    start = time.time()\n    for i in range(10000):\n        lst.insert(0, i)  # 在开头插入，O(n)操作\n    end = time.time()\n    return end - start\n\n# 使用deque（高效）\ndef deque_performance_test():\n    dq = deque()\n    start = time.time()\n    for i in range(10000):\n        dq.appendleft(i)  # 在左端添加，O(1)操作\n    end = time.time()\n    return end - start\n\n# 技巧2: 利用推导式提高效率\n# 传统方法\ndef traditional_method():\n    result = []\n    for i in range(1000):\n        if i % 2 == 0:\n            result.append(i * 2)\n    return result\n\n# 推导式方法（更高效且简洁）\ndef comprehension_method():\n    return [i * 2 for i in range(1000) if i % 2 == 0]\n\n# 技巧3: 使用适当的内置函数\nfrom collections import Counter\n\n# 统计元素频度的传统方法\ndef traditional_count(items):\n    counts = {}\n    for item in items:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return counts\n\n# 使用Counter（更高效）\ndef counter_method(items):\n    return Counter(items)\n\n# 技巧4: 避免重复计算\ndata = list(range(10000))\n\n# 低效方法：在循环中重复计算\ndef inefficient_calculation():\n    result = []\n    for i in range(1000):\n        # len(data)在每次迭代中都被调用\n        if i &lt; len(data) / 2:\n            result.append(i)\n    return result\n\n# 高效方法：提前计算\ndef efficient_calculation():\n    result = []\n    half_length = len(data) / 2  # 提前计算\n    for i in range(1000):\n        if i &lt; half_length:\n            result.append(i)\n    return result\n</code></pre>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/Python%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83/#_4","level":2,"title":"总结","text":"<p>通过本文的学习，你应该掌握了以下关键技能：</p> <ol> <li>数据筛选技巧：使用列表推导式、filter等方法高效筛选数据</li> <li>提高代码可读性：使用namedtuple为元组元素命名</li> <li>频度统计：利用Counter进行高效的元素频度统计</li> <li>字典排序：掌握多种字典排序方法</li> <li>集合操作：使用集合运算找出多个字典的公共键</li> <li>保持顺序：使用OrderedDict或了解Python 3.7+字典的有序特性</li> <li>历史记录：使用deque实现固定长度的历史记录功能</li> <li>性能优化：理解时间复杂度，选择合适的数据结构</li> </ol> <p>关键要点： - 列表推导式通常比传统循环更高效且更易读 - namedtuple是在保持tuple内存效率的同时提高代码可读性的好方法 - Counter是进行频度统计的最佳工具 - deque在需要频繁两端操作的场景下比list更高效 - 了解不同操作的时间复杂度有助于选择合适的数据结构</p>","path":["Python","Python进阶-数据结构与算法进阶训练"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/","level":1,"title":"Python爬虫中的SSL证书验证问题及解决方案","text":"","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_1","level":2,"title":"问题描述","text":"<p>在使用Python进行网络爬虫开发时，经常会遇到SSL证书验证失败的错误：</p> <pre><code>urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed\n</code></pre> <p>这个错误通常发生在尝试访问HTTPS网站时，Python无法验证服务器的SSL证书。</p>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_2","level":2,"title":"原因分析","text":"<p>Python从2.7.9版本开始引入了一个重要的安全特性：当使用<code>urllib.urlopen</code>打开HTTPS链接时，会自动验证SSL证书。如果出现以下情况，就会抛出证书验证失败的错误：</p> <ol> <li>目标网站使用自签名证书</li> <li>证书已过期</li> <li>证书颁发机构不被信任</li> <li>系统时间不正确导致证书验证失败</li> <li>证书链不完整</li> </ol>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_3","level":2,"title":"解决方案","text":"<p>针对SSL证书验证问题，我们提供以下几种解决方案，按照安全性和推荐程度排序：</p>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#ca","level":3,"title":"方案一：更新CA证书（推荐）","text":"<p>确保系统拥有最新的受信任CA证书是解决SSL验证问题的最佳做法：</p> <pre><code># 使用certifi包更新CA证书\n# 首先安装certifi包\n# pip install --upgrade certifi\n\nimport urllib.request\nimport ssl\nimport certifi\n\n# 创建使用certifi CA bundle的SSL上下文\nssl_context = ssl.create_default_context(cafile=certifi.where())\nresponse = urllib.request.urlopen('https://example.com', context=ssl_context)\nprint(response.read().decode('utf-8'))\n</code></pre> <p>对于使用requests库的情况： <pre><code>import requests\nimport certifi\n\n# 明确指定使用certifi的CA bundle\nresponse = requests.get(\"https://example.com\", verify=certifi.where())\nprint(response.text)\n</code></pre></p>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#ca_1","level":3,"title":"方案二：手动指定CA证书","text":"<p>如果是自签名证书或者企业内部CA签发的证书，可以手动指定证书路径：</p> <pre><code>import urllib.request\nimport ssl\n\n# 指定自定义CA证书路径\nca_bundle_path = '/path/to/your/certificate.pem'\nssl_context = ssl.create_default_context(cafile=ca_bundle_path)\nresponse = urllib.request.urlopen('https://example.com', context=ssl_context)\nprint(response.read().decode('utf-8'))\n</code></pre>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#requests","level":3,"title":"方案三：使用requests库（推荐用于爬虫开发）","text":"<p>requests库提供了更简洁的API来处理HTTP请求，并且在SSL处理方面更加友好：</p> <pre><code>import requests\n\n# 推荐：使用默认的证书验证（最安全）\ntry:\n    response = requests.get(\"https://example.com\")\n    print(response.text)\nexcept requests.exceptions.SSLError as e:\n    print(f\"SSL验证失败: {e}\")\n\n# 特殊情况下：指定自定义证书路径\n# response = requests.get(\"https://example.com\", verify=\"/path/to/certificate.pem\")\n</code></pre>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#ssl","level":3,"title":"方案四：创建未验证的SSL上下文（仅限开发/测试环境）","text":"<p>在某些特殊情况下（如开发或测试环境），可以临时禁用SSL验证：</p> <pre><code>import urllib.request\nimport ssl\n\n# 创建未验证的SSL上下文（仅限测试环境）\ncontext = ssl._create_unverified_context()\nresponse = urllib.request.urlopen(\"https://example.com\", context=context)\nprint(response.read().decode('utf-8'))\n</code></pre> <p>对于requests库： <pre><code>import requests\nimport urllib3\n\n# 禁用SSL警告\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n# 禁用SSL验证（仅限测试环境）\nresponse = requests.get(\"https://example.com\", verify=False)\nprint(response.text)\n</code></pre></p>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_4","level":2,"title":"最佳实践和安全建议","text":"<ol> <li> <p>优先使用方案一和方案二：保持SSL验证启用是保障通信安全的最佳做法</p> </li> <li> <p>避免全局禁用SSL验证：虽然方便，但会带来严重的安全风险</p> </li> <li> <p>使用requests库：相比urllib，requests提供了更简洁和安全的API</p> </li> <li> <p>正确的异常处理：始终捕获和处理SSL相关的异常</p> </li> <li> <p>定期更新证书：保持系统的CA证书为最新状态</p> </li> <li> <p>检查系统时间：确保系统时间准确，避免因时间不同步导致的验证失败</p> </li> </ol>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/python%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98,%20SSL%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_5","level":2,"title":"总结","text":"<p>SSL证书验证失败是爬虫开发中常见的问题，虽然可以通过禁用验证来快速解决问题，但这会带来安全风险。建议优先采用更新证书、使用可信CA等安全方式来解决。只有在开发和测试环境中才可以考虑临时禁用SSL验证。</p>","path":["Python","Python爬虫中的SSL证书验证问题及解决方案"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/","level":1,"title":"list","text":"<p>title: Python 一些数据类型辨析</p> <p>date: 2017/05/22 15:37:47</p> <p>tags: Python</p> <p>categories: Python</p> <p>list,tuple,dict,set 四种数据类型的定义和异同.</p>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/#list","level":1,"title":"list","text":"<p>list 是一种有序的集合,可以随时添加和删除其中的元素.</p> <pre><code>    #声明\n    classmates = ['Mi','Bo','Tr']\n    #长度\n    len(classmates)\n    #索引\n    classmates[0]\n    ##倒数第一个索引\n    classmates[-1]\n    #追加\n    classmates.append('Ad')\n    #插入\n    classmates.insert(1,'Ja')\n    #删除末尾\n    classmates.pop()\n    ##删除指定位置\n    classmates.pop(1)\n    ##list的元素可以为其他的数据结构\n    L=['Ad',123,['ad','ds']]\n</code></pre>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/#tuple","level":1,"title":"tuple","text":"<p>tuple是不可修改的 list.一旦初始化后,就不能修改.</p> <p>因为不可修改,所以代码更为安全.</p> <pre><code>#声明\nclassmates = ('Mi','Bo','Tr')\n#因为括号()既可以表示 tuple, 又可以表示数学公式中的小括号.\n#故 Python 规定.只有1个元素的tuple 定义时必须加一个**,**,来消除歧义\nt=(1)\nt=(1,)\n</code></pre> <p>另外,因为特殊的结构,还存在一种\"可变\"的tuple.</p> <pre><code>#\"可变\"的 tuple\nt = (\"Ad\",123,['sad','asda'])\n</code></pre> <p>因为, tuple 内含的 list 是可变的,而 tuple 本身的指向和结构并没有发生改变.</p>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/#dict","level":1,"title":"dict","text":"<p>dict即为 dictionary, 在其他语言中也称为 map. 使用键-值(key-value)存储,查找速度极快.</p> <pre><code>#声明\nd = {'Mi':95,'Bo':85,'Tr':75}   \n</code></pre>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/#dict-list","level":2,"title":"dict 和 list 查找速度对比","text":"<p>list:</p> <p>把字典从第一页向后翻,直到查找到.</p> <p>所以 list 中查找元素, list 越大,查找越慢</p> <p>dict:</p> <p>给定一个 key 值,来计算出 value 的存放位置.</p> <p>比如\" Mi\",dict 在内部进行计算出 Mi对应存放 value 的\"页码\",即可直接取出 value.</p> <pre><code>#初始化后赋值\nd['Mi']=97\n#Key 不存在会报错\n##判断 key 是否存在\n'Mi'in d\n##通过 get 方法,如果 key 不存在,返回指定 value\nd.get('Mi',-1)\n#删除一个 key\nd.pop('Bo')\n</code></pre> <p>dict 是一种空间换时间的方法.</p> <p>dict 的 key 值是不可变对象</p> <p>因为 key 值决定了 value 的存储位置,如果 key 值变化,则整个 dict 就陷入了混乱.</p> <p>list 是可变的,故 list 不能为 key.</p>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/#set","level":1,"title":"set","text":"<p>set 是无序无重复的元素集合</p> <p>创建一个 set, 需要提供一个 list 作为输入集合</p> <pre><code>#声明\n&gt;&gt;&gt;s = set([1,2,3,3])\n#重复元素会被自动过滤\n&gt;&gt;&gt;s\n{1,2,3}\n#添加元素\ns.add(4)\n#删除元素\ns.remove(3)\n#可以做 交集,并集等操作\n&gt;&gt;&gt; s1 = set([1, 2, 3])\n&gt;&gt;&gt; s2 = set([2, 3, 4])\n&gt;&gt;&gt; s1 &amp; s2\n{2, 3}\n&gt;&gt;&gt; s1 | s2\n{1, 2, 3, 4}\n</code></pre>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%204%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94/#_1","level":1,"title":"小结","text":"<p>list是有序可变,中括号</p> <pre><code>list = ['ad',123,False]\n</code></pre> <p>tuple 是有序不可变,小括号</p> <pre><code>tuple = ('ada',1231,list,['dsa','dasda'])\n</code></pre> <p>dict 是无序, key-value ,中括号</p> <pre><code>dict = {'Ad':96,'Mi':97}\n</code></pre> <p>set 是无序,无重复,set(list)</p> <pre><code>s = set(['ads','dasd',123])\n</code></pre>","path":["Python","list"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","level":1,"title":"默认参数","text":"<p>title: Python函数参数详解：默认参数、可变参数与关键字参数的完整指南</p> <p>data: 2017/05/22 17:32:14</p> <p>tags: Python</p> <p>categories: Python</p> <p>默认函数,可变函数等一些关于函数定义方面的问题.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_1","level":1,"title":"默认参数","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_2","level":2,"title":"默认参数定义","text":"<pre><code># 先定义一个简单的平方函数，计算x的平方\ndef power(x):\n    return x*x\n\n&gt;&gt;&gt;power(5)  # 调用函数计算5的平方\n25\n\n# 扩展这个函数，使其可以计算x的n次方\n# x: 底数\n# n: 指数\ndef power(x,n):\n    s = 1  # 初始化结果变量为1\n    # 循环n次，每次将s乘以x\n    while n &gt; 0:\n        n = n - 1  # 指数减1\n        s = s * x  # 结果乘以底数\n    return s  # 返回最终结果\n\n&gt;&gt;&gt;power(5,3)  # 调用函数计算5的3次方\n125\n</code></pre> <p>但是这时候再调用第一个函数,则会报错.</p> <p></p> <p>即,调用函数 power()缺少了一个位置参数 n.</p> <p>这时候就需要使用默认参数了</p> <pre><code># 使用默认参数定义函数，n的默认值为2\n# x: 底数（必选参数）\n# n: 指数（可选参数，默认值为2）\ndef power(x,n=2):\n    s = 1  # 初始化结果变量为1\n    # 循环n次，每次将s乘以x\n    while n &gt; 0:\n        n = n - 1  # 指数减1\n        s = s * x  # 结果乘以底数\n    return s  # 返回最终结果\n\n#如果需要使用 n不等于2的情况,则需要明确传入 n 值.\n#必选参数在前,默认参数在后,否则可能会报错.\n#当函数有多个函数时,把变化比较大的参数放在前面,变化比较小的放后面.\n#变化小的参数可以作为默认参数,这样可以降低调用的难度以及优化代码\n</code></pre> <p>多个默认参数,有时按照顺序提供默认参数,有时可以不按顺序提供默认参数</p> <pre><code>#顺序传参方式调用函数\nenroll('Bo','M',7)\n#关键字参数方式调用函数，提高代码可读性\nenroll('Ad','M',city='Tianjin')\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_3","level":2,"title":"默认参数坑","text":"<pre><code># 错误示例：使用可变对象作为默认参数\n# L: 列表参数，默认值为空列表（这里是有问题的！）\ndef add_end(L=[]):\n    L.append('END')  # 向列表末尾添加'END'元素\n    return L  # 返回修改后的列表\n\n&gt;&gt;&gt; add_end()  # 第一次调用\n['END']\n&gt;&gt;&gt; add_end()  # 第二次调用，结果不是预期的['END']而是['END', 'END']\n['END', 'END']\n</code></pre> <p>函数定义的是在某个列后加入一个 'END', 但是函数好像每次都记住了上次添加了' END'后的 list.</p> <p>原因如下:</p> <p>Python函数在定义的时候,默认函数L的值就被确定了,因为 默认函数 L 也是一个变量,它指向对象[],每次调用该函数时,如果改变了 L 的内容,则下次调用时,默认参数的内容就发生了变化,不再是默认的定义.</p> <p>故,需要特别注意!!</p> <p>默认参数必须指向不变对象!!</p> <pre><code>可变对象:list,dict,set\n不变对象: str,None,tuple\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_4","level":1,"title":"可变参数","text":"<p>可变参数是指传入的参数个数是可变的.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#list","level":2,"title":"list法","text":"<pre><code># 可以通过传入一个 list 作为函数的参数,从而实现参数个数可变.\n# numbers: 包含数字的列表\ndef calc(numbers):\n    sum = 0  # 初始化总和为0\n    # 遍历列表中的每个数字，计算平方和\n    for n in numbers:\n        sum = sum + n * n  # 累加每个数字的平方\n    return sum  # 返回计算结果\n# 但是必须先填入一个 list 或 tuple\n&gt;&gt;&gt;calc([1,2,3])  # 计算1²+2²+3²=1+4+9=14\n14\n</code></pre> <p>每次必须传入一个 list 或者 tuple, 太繁琐.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_5","level":2,"title":"加*","text":"<p>所以一般将函数的参数改为可变参数</p> <pre><code># 使用可变参数定义函数，可以接收任意数量的位置参数\n# *numbers: 可变参数，接收任意数量的位置参数，函数内部作为元组处理\ndef calc(*numbers):\n    sum = 0  # 初始化总和为0\n    # 遍历所有传入的参数，计算平方和\n    for n in numbers:\n        sum = sum + n * n  # 累加每个数字的平方\n    return sum  # 返回计算结果\n</code></pre> <p>在参数前加一个*号.</p> <p>在内部流程中,参数 numbers 接收到的是一个tuple.</p> <pre><code>&gt;&gt;&gt;calc(1,2)  # 直接传入两个参数1和2，计算1²+2²=1+4=5\n5\n</code></pre> <p>如果要传入一个 list 或 tuple, 则可以选择在 list 或 tuple 前加一个*号,把 list 或 tuple的元素变成可变参数传入:</p> <pre><code>&gt;&gt;&gt;nums=[1,2,3]  # 定义一个包含数字的列表\n&gt;&gt;&gt;calc(*nums)  # 使用*解包列表，将列表元素作为单独参数传入函数\n14\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_6","level":1,"title":"关键字参数","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_7","level":2,"title":"关键字参数的设置","text":"<p>可变参数允许传入任意个数参数,自动组装成一个 tuple.</p> <p>关键字参数允许传入任意个数含参数名的参数,自动组装成一个 dict.</p> <pre><code># 定义带有关键字参数的函数\n# name: 姓名（必选参数）\n# age: 年龄（必选参数）\n# **kw: 关键字参数，接收任意数量的键值对参数，函数内部作为字典处理\ndef person(name,age,**kw):\n    print(name,age,kw)  # 打印姓名、年龄和其他关键字参数\n\n&gt;&gt;&gt;person('Bo',5,city='Beijing')  # 传入姓名、年龄和城市信息\nBo 5 {'city': 'Beijing'}\n</code></pre> <p>在 person 函数里,我们能保证收到两个必须参数name和age,如果调用者需要提供更多信息,我们也可以收到这些信息,而且这些信息可以是任意的.</p> <p>也可以先做一个 dict 来存储这些额外的信息,</p> <pre><code>&gt;&gt;&gt;extra={'city':'Beijing','job':'Engineer','location':'changping'}  # 定义一个包含额外信息的字典\n##可以对个别 key 值调用\n&gt;&gt;&gt;person('Ja',24,city=extra['city'])  # 只传入city信息\n##也可以一次性全部调用\n&gt;&gt;&gt;person('Ja',23,**extra)  # 使用**解包字典，将字典的所有键值对作为关键字参数传入\n</code></pre> <p>** extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 ** kw 参数, kw 获得一个 dict, 这里并不是指针改变,而是拷贝,所以 kw 的后续改动并不会影响到函数外的 extra.</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_8","level":2,"title":"命名关键字参数","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_9","level":3,"title":"关键字参数检查","text":"<p>因为在传入时并没有规定参数的格式,所以传入的信息会比较杂乱,</p> <p>有时希望检查某些参数是否输入:</p> <pre><code># 对关键字参数进行检查的函数\n# name: 姓名（必选参数）\n# age: 年龄（必选参数）\n# **kw: 关键字参数\ndef person(name,age,**kw):\n    # 检查是否传入了city参数\n    if 'city' in kw:\n        pass  # 实际应用中可以在这里处理city参数\n    # 检查是否传入了job参数\n    if 'job' in kw:\n        pass  # 实际应用中可以在这里处理job参数\n    print('name:',name,'age:',age,'other:',kw)  # 打印所有参数\n</code></pre> <p>但传入的信息还是很杂乱,</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_10","level":3,"title":"关键字参数限制","text":"<p>有时希望限制关键字参数的名字:</p> <pre><code># 使用命名关键字参数限制参数名称\n# name: 姓名（位置参数）\n# age: 年龄（位置参数）\n# city: 城市（命名关键字参数）\n# job: 工作（命名关键字参数）\ndef person(name,age,*,city,job):\n    print(name,age,city,job)  # 打印所有参数\n</code></pre> <p>*后面的参数都将被视为命名关键字参数.**</p> <p>如果有了一个可变参数,则可变参数后面的参数默认为命名关键字参数</p> <pre><code># 混合使用可变参数和命名关键字参数\n# name: 姓名（位置参数）\n# age: 年龄（位置参数）\n# *args: 可变参数，接收额外的位置参数\n# city: 城市（命名关键字参数）\n# job: 工作（命名关键字参数）\ndef person(name,age,*args,city,job):\n    print(name,age,args,city,job)  # 打印所有参数\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_11","level":3,"title":"关键字参数的一些问题","text":"<ul> <li>命名关键字参数必须传入参数名.</li> </ul> <p>(因为它本质上是一个 dict, 与 key有关,与位置无关)</p> <ul> <li>命名关键字可以设置缺省值</li> </ul> <pre><code># 命名关键字参数可以设置默认值\n# name: 姓名（位置参数）\n# age: 年龄（位置参数）\n# city: 城市（命名关键字参数，默认值为'Beijing'）\n# job: 工作（命名关键字参数）\ndef person(name,age,*,city='Beijing',job):\n</code></pre> <ul> <li>注意区分位置参数和命名关键字参数,命名关键字参数实质是传入了一个 dict, 与位置无关.</li> </ul>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_12","level":1,"title":"参数组合","text":"","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_13","level":2,"title":"参数顺序","text":"<p>参数定义是一定要按照以下顺序</p> <p>必选参数,默认参数,可变参数,命名关键字参数,关键字参数</p> <p>比如</p> <pre><code># 参数组合示例1：包含所有类型的参数\n# a, b: 位置参数\n# c: 默认参数（默认值为0）\n# *args: 可变参数\n# **kw: 关键字参数\ndef f1(a,b,c=0,*args,**kw):\n\n# 参数组合示例2：包含命名关键字参数\n# a, b: 位置参数\n# c: 默认参数（默认值为0）\n# d: 命名关键字参数\n# **kw: 关键字参数\ndef f2(a,b,c=0,*,d,**kw):\n</code></pre> <pre><code>&gt;&gt;&gt; f1(1, 2)  # 只传入必选参数\na = 1 b = 2 c = 0 args = () kw = {}\n&gt;&gt;&gt; f1(1, 2, c=3)  # 传入必选参数和默认参数\na = 1 b = 2 c = 3 args = () kw = {}\n&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')  # 传入必选参数、默认参数和可变参数\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)  # 传入所有类型的参数\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n&gt;&gt;&gt; f2(1, 2, d=99, ext=None)  # 调用第二个函数\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#listtuple-dict","level":2,"title":"通过list,tuple 和 dict 传入","text":"<pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)  # 定义一个元组\n&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}  # 定义一个字典\n&gt;&gt;&gt; f1(*args, **kw)  # 使用*和**解包元组和字典作为参数传入\na = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n&gt;&gt;&gt; args = (1, 2, 3)  # 定义另一个元组\n&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}  # 定义另一个字典\n&gt;&gt;&gt; f2(*args, **kw)  # 使用*和**解包元组和字典作为参数传入\na = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}\n</code></pre>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_14","level":1,"title":"总结","text":"<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p> <p>默认参数必须指向不变对象，如果是可变对象，程序运行时会有逻辑错误！</p> <p>要注意定义可变参数和关键字参数的语法：</p> <p><code>*args</code>是可变参数，args接收的是一个tuple；</p> <p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p> <p>以及调用函数时如何传入可变参数和关键字参数的语法：</p> <p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p> <p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p> <p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。这是Python参数传递的最佳实践。</p> <p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p> <p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20Python%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#_15","level":1,"title":"核心要点总结","text":"<ol> <li> <p>默认参数必须指向不变对象：使用可变对象作为默认参数会导致意外的行为，因为默认参数在函数定义时只被计算一次。</p> </li> <li> <p>可变参数的使用：通过在参数前添加<code>*</code>号，可以接收任意数量的位置参数，函数内部将其作为一个tuple处理。</p> </li> <li> <p>关键字参数的灵活性：使用<code>**kw</code>可以接收任意数量的键值对参数，函数内部将其作为一个dict处理。</p> </li> <li> <p>命名关键字参数的限制作用：通过<code>*</code>分隔符或在可变参数后定义参数，可以限制调用者只能传入指定名称的参数。</p> </li> <li> <p>参数定义顺序的重要性：参数必须按照必选参数,默认参数,可变参数,命名关键字参数,关键字参数的顺序定义。</p> </li> <li> <p>参数传递的最佳实践：使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，便于代码的可读性和一致性。</p> </li> </ol>","path":["Python","默认参数"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/","level":1,"title":"创建 generator","text":"<p>title: Python生成器详解与应用</p> <p>data: 2017/05/24 15:35:43</p> <p>tags: Python</p> <p>categories: Python</p> <p>生成器可以动态的生成后续的元素,</p> <p>是一种基于某种算法推算出来的, 因为在需要时才生成,故使用生成器可以节省大量的空间.</p> <p>在 Python 中,这种一边循环一边计算的机制,称为生成器: generator.</p>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#generator","level":1,"title":"创建 generator","text":"","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#_1","level":2,"title":"[]改()","text":"<p>只要将一个列表生成式的<code>[]</code>改成<code>()</code>,就创建了一个 generator:</p> <pre><code>&gt;&gt;&gt;L=[x*x for x in range(10)]  # 创建一个列表推导式，生成0到9的平方数列表\n&gt;&gt;&gt;L\n[0,1,4,9,16,25,36,49,64,81]\n&gt;&gt;&gt;g=(x*x for x in range(10))  # 将列表推导式的方括号改为圆括号，创建生成器\n&gt;&gt;&gt;g\n&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;\n</code></pre> <p>L 是 一个 list, g 是 一个 generator.</p> <p>通过 next()函数,可以获得 generator 的下一个返回值.</p> <p>即,按照设定的算法生成了后续序列</p> <p>一般来说,是使用 for 循环来迭代 generator.</p> <pre><code>&gt;&gt;&gt;g=(x*x for x in range(10))  # 创建一个生成器对象\n&gt;&gt;&gt;for n in g:  # 使用for循环迭代生成器\n       print(n)  # 逐个打印生成器产生的值\n</code></pre>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#yield","level":2,"title":"yield","text":"<p>有些函数也可以通过算法实现自增,</p> <p>但是这种函数只是有了'自我生成算法',还缺少一个非常重要的标志'yield'.</p> <p>yield 取代 return, 为函数返回值.</p> <p>如果一个函数定义包含关键字 yield, 那么这个函数就不再是一个普通的函数,而是一个 generator.</p>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#yield-return","level":2,"title":"yield 与 return 的区别","text":"<p>当一个生成器函数调用 yield, 生成器函数的'状态'会被冻结,所有的变量的值会被保留下来,下一行要执行的代码的位置也会被记录,知道再次调用 next().一旦 next() 再次被调用,生成器函数会从它上次离开的地方开始.</p> <p>下面通过一个简单的流程图来展示生成器函数的工作原理：</p> <pre><code>graph TD\n    A[调用生成器函数] --&gt; B[执行到yield语句]\n    B --&gt; C[产出值并冻结状态]\n    C --&gt; D[下次调用next()]\n    D --&gt; E[从上次停止位置继续执行]\n    E --&gt; F{是否还有yield语句?}\n    F --&gt;|是| B\n    F --&gt;|否| G[函数结束抛出StopIteration]</code></pre>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#_2","level":1,"title":"总结","text":"<ul> <li>generator 是用来产生一系列的值的.</li> <li>yield 向 generator 函数返回结果</li> <li>yield 唯一做的另一件事就是保存一个 generator 的状态</li> <li>generator 是特殊类型的迭代器</li> <li>可以通过 next()来获取 generator 的下一个值</li> <li>可以通过隐私调用 next()来忽略某些值.</li> </ul>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#_3","level":1,"title":"例子","text":"<p>杨辉三角问题</p> <ol> <li> <p>每个数等于它上方两数之和。</p> </li> <li> <p>每行数字左右对称，由1开始逐渐变大</p> </li> </ol> <p>下面是我的代码:</p> <pre><code>def triangles():\n    if n==0:  # 处理第一行，只有一个元素1\n        L2=[1]\n        yield L2  # 产出第一行\n    if n==1:  # 处理第二行，有两个元素1\n        L2=[1,1]\n        yield L2  # 产出第二行\n    while n&gt;1:  # 处理后续行\n        L=L2.copy()  # 复制上一行数据，避免引用问题\n        i = 0\n        while i &lt; n-1:  # 计算中间的数值\n            L2[i+1]=L[i]+L[i+1]  # 当前位置的值等于上一行相邻两数之和\n            i=i+1\n        L2.append(1)  # 每行末尾添加1\n        yield L2  # 产出当前行\n\n\nn = 0\nfor t in triangles():  # 迭代生成器函数\n    print(t)  # 打印每一行\n    n = n + 1\n    if n == 10:  # 控制只输出前10行\n        break\n</code></pre> <p>在代码中,还有一个值得注意的地方.</p> <p><code>L=L2</code>是软复制,仅仅是指针指向.</p> <p>如果不希望两个 list 之间的变动相互干扰,就需要使用 <code>L.copy()</code>方法来实现硬复制.</p> <p>另外,我的代码表现出很浓的 C 风格.</p> <p>以下是看到的其他同学的实践方法,值得学习:</p> <pre><code>def triangles():\n    L = [1]  # 初始化第一行\n    while True:  # 无限循环，持续生成下一行\n        yield L  # 产出当前行\n        L.append(0)  # 在列表末尾添加0，便于计算\n        # 通过列表推导式生成下一行：每个元素等于当前位置和前一个位置元素之和\n        L = [L[i - 1] + L[i] for i in range(len(L))]\n</code></pre> <p>还有另一种写法:</p> <pre><code>def triangles():\n    ret = [1]  # 初始化第一行\n    while True:  # 无限循环，持续生成下一行\n        yield ret  # 产出当前行\n        for i in range(1, len(ret)):  # 从第二个元素开始计算\n            ret[i] = pre[i] + pre[i - 1]  # 当前位置值等于上一行相邻两数之和\n        ret.append(1)  # 行尾添加1\n        pre = ret[:]  # 复制当前行作为下一次计算的基准\n</code></pre> <p>​</p>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/title%EF%80%A2%20%E7%94%9F%E6%88%90%E5%99%A8/#_4","level":1,"title":"核心要点总结","text":"<ul> <li>生成器(generator)是一种惰性计算机制，按需生成数据，节省内存空间</li> <li>yield关键字是生成器函数的核心标识，用于产出值并保存函数状态</li> <li>生成器是特殊的迭代器，支持next()函数逐个获取值</li> <li>通过列表推导式将方括号<code>[]</code>改为圆括号<code>()</code>可创建简单的生成器对象</li> <li>yield与return的区别在于，yield不会终止函数执行，而是暂停并保存状态</li> <li>生成器函数在每次调用next()时从上次暂停的位置继续执行</li> <li>使用for循环迭代生成器是最佳实践，避免手动调用next()</li> <li>生成器适用于处理大量数据或无限序列的场景，提高程序性能</li> </ul>","path":["Python","创建 generator"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/","level":1,"title":"一些需要注意的地方","text":"","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#1sqlalchemyfilterfilter_by","level":2,"title":"1.sqlalchemy中的filter(),filter_by()有什么区别","text":"<pre><code>db.session.query.filter(Wish.launched == False)\ndb.session.query.filter_by(uid=uid, launched=False)\n# 一个是关键字参数, 一个是条件表达式\n</code></pre>","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#2","level":2,"title":"2. 继承第三方库的某个类","text":"<pre><code>class Query(BaseQuery):\n    def filter_by(self, **kwargs):\n      # kwargs是字典\n        if 'status' not in kwargs.keys():\n            kwargs['status'] = 1\n            # 重写完成后,继承基类\n        return super(Query,self).filter_by(**kwargs)\n\n# 在SQLAlchemy中留了继承基类的接口  \ndb = SQLAlchemy(query_class=Query)\n</code></pre>","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#3sqlsql_mode","level":2,"title":"3.链式调用触发sql严格模式(sql_mode)","text":"<pre><code>   @classmethod\n    def recent(cls):\n        # 链式调用\n        recent_gift = Gift.query.filter_by(launched=False).group_by(\n            Gift.isbn).order_by(Gift.create_time).limit(\n            current_app.config['RECENT_BOOK_COUNT']).distinct()\n        return recent_gift\n</code></pre> <p>需要一下方法解锁严格模式.</p> <pre><code>SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));   \n</code></pre>","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#4viewmodel","level":2,"title":"4.原始数据→视图数据,需要通过视图模型(viewmodel)","text":"","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#5sessionquery","level":2,"title":"5.session.query查询","text":"<pre><code>   @classmethod\n    def get_wish_count(cls, isbn_list):\n        # 根据传入的一组isbn,到Wish表中检索出某个的礼物,并计算出某个礼物的心愿数量\n        # db.session\n        # mysql in查询\n        db.session.query(func.count(Wish.id), Wish.isbn).filter(\n                                        Wish.launched == False,\n                                        Wish.isbn.in_(isbn_list),\n                                        Wish.status == 1).group_by(Wish.isbn).all()\n</code></pre> <p>这种写法非常Python,要看多学多写.</p> <p>db.session.query(根据检索条件返回的数据)</p>","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#6","level":2,"title":"6.避免循环导入","text":"<p>当我们import一个文件时，python会首先去查找这个文件之前是否被import过，如果这个文件之前有被import过，就不会重新再import一次。所以如果A模块 代码里import了B模块，并且B模块里又import了A模块，python的执行顺序会变成这样：开始执行模块A当A执行到import B的地方，则停止执行A模块后面的代码，转而开始执行B模块的代码当B模块从头执行到import A的地方时，python此时并不会回过头去接着执行A剩余的代码，而且将A模块在中断前已经初始化的属性全加载到B模块中</p> <p>1.在函数内部使用import,俗称 延迟导入.会影响性能.</p> <pre><code>def func():\n  from time import sleep\n</code></pre> <p>2.将引起循环导入的变量放到导入模块import代码前.</p> <pre><code>src.user = None\nfrom core import src\n</code></pre>","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/#7keyboardinterrupt","level":2,"title":"7.捕获KeyboardInterrupt异常","text":"<p>运行命令行程序期间,如果用户想终止程序,一般都会才用ctrl-c来终止程序运行,程序会抛出KeyboardInterrupt异常.</p> <p>可以通过这一机制来实现我们想要的功能.</p> <pre><code>import time\nprint('按下回车开始')\ntry:\n    input('')\n    starttime = time.time()\n    print('开始')\n    while True:\n        print('计时',round(time.time()-starttime))\n        time.sleep(1)\nexcept KeyboardInterrupt:\n    print('结束')\n    print('总计耗时间:',round(time.time()-starttime))\n</code></pre> <p>通过抛出异常来终止while循环,从而实现计时器功能.</p>","path":["Python","一些需要注意的地方"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/","level":1,"title":"SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作","text":"<p>在数据库设计中，一对多关系是一种常见的关系类型。在这种关系中，\"一\"的一方可以关联到\"多\"的一方的多个记录，但\"多\"的一方只能关联到\"一\"的一方的一个记录。</p> <p>例如，在城市和国家的模型中，一个国家可以有多个城市，但一个城市只能属于一个国家。在这种情况下，国家是\"一\"的一方，城市是\"多\"的一方。</p> <p>在\"一\"类中添加一个关系属性作为集合属性。当调用这个属性时返回所有相关的对象。</p> <p>比如城市和国家模型。</p> <pre><code># 定义City模型类，继承自db.Model\n# 这个类映射到数据库中的city表\n# 每个城市都属于一个国家，通过外键nation_id关联\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一条记录\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示城市名称在数据库中不能重复\n    name = db.Column(db.String(50), unique=True)\n\n# 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\n# 每个国家可以拥有多个城市\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n</code></pre> <p>需要实现一个国家对应多个城市。</p>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#_1","level":4,"title":"建立一对多关系","text":"<p>第一步: </p> <p>在\"多\"的一侧创建外键。</p> <pre><code># 定义City模型类，继承自db.Model\n# 这个类映射到数据库中的city表\n# 每个城市都属于一个国家，通过外键nation_id关联\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一条记录\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示城市名称在数据库中不能重复\n    name = db.Column(db.String(50), unique=True)\n    # 外键指向nation表的id字段\n    # db.ForeignKey('nation.id')指定外键约束，关联到nation表的id字段\n    # 通过这个外键，建立了城市到国家的多对一关系\n    nation_id = db.Column(db.Integer, db.ForeignKey('nation.id'))\n    # 需要注意的是nation.id,表名是小写(因为SQLAlchemy生成的表默认为类名称的小写形式)\n</code></pre> <p>第二步:</p> <p>在\"一\"的一侧定义关系属性。(集合关系属性,列表)</p> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\n# 每个国家可以拥有多个城市\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 定义一对多关系，一个国家可以有多个城市\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # 通过cities属性可以访问该国家的所有城市\n    cities = db.relationship('City', backref='nation')\n</code></pre>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#nationcitiessqlalchemycitynation_idcitynation_idnationid","level":1,"title":"当关系属性<code>nation.cities</code>被调用时,SQLAlchemy会找到<code>city表</code>的外键字段(<code>nation_id</code>)。然后查询<code>city表</code>中<code>nation_id</code>为当前主键值(<code>nation.id</code>)的记录,返回包含这些记录的列表。","text":"<p>需要注意的是,使用关系函数定义的集合关系属性不是数据库字段,而是一个查询函数。所以返回值并不固定,而是根据查询结果动态变化。</p>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#relationship","level":4,"title":"relationship函数常用参数说明","text":"<p><code>relationship</code>函数有许多参数可以用来定制关系的行为，以下是几个常用的参数：</p> <ol> <li><code>backref</code>参数：在一对多关系中，可以在\"一\"的一侧使用<code>backref</code>参数自动在\"多\"的一侧创建反向引用。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用backref参数创建双向关系\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # 通过cities属性可以访问该国家的所有城市\n    cities = db.relationship('City', backref='nation')\n</code></pre> <p>这样，在<code>City</code>模型中就自动有了一个<code>nation</code>属性，可以直接访问该城市的所属国家。</p> <ol> <li><code>lazy</code>参数：控制关联对象的加载方式。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用lazy参数控制加载方式\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # lazy='select'指定加载方式为select模式（默认）\n    # select模式会在访问cities属性时发出新的SELECT语句加载数据\n    cities = db.relationship('City', backref='nation', lazy='select')\n</code></pre> <ol> <li><code>cascade</code>参数：控制级联操作行为。</li> </ol> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    # 主键用于唯一标识每一个国家\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    # unique=True表示国家名称在数据库中不能重复\n    nation_name = db.Column(db.String(50), unique=True)\n    # 使用cascade参数控制级联操作\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # cascade='all, delete-orphan'指定级联操作为全部操作，并删除孤儿对象\n    # 当删除国家时，所有关联的城市也会被删除\n    # 当城市不再关联到任何国家时，城市记录也会被删除\n    cities = db.relationship('City', backref='nation', cascade='all, delete-orphan')\n</code></pre>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#_2","level":4,"title":"创建和使用对象","text":"<p>创建国家和城市对象：</p> <pre><code># 创建国家对象，nation_name属性设置为'中国'\n# 这会创建一个新的Nation实例，但尚未保存到数据库\nchina = Nation(nation_name='中国')\n# 创建国家对象，nation_name属性设置为'美国'\n# 这会创建另一个Nation实例，同样尚未保存到数据库\nusa = Nation(nation_name='美国')\n\n# 将china对象添加到数据库会话中\n# db.session.add()将对象标记为待插入状态\n# 此时对象还未真正写入数据库\n# 只有在commit()之后才会真正保存到数据库\ndb.session.add(china)\n# 将usa对象添加到数据库会话中\ndb.session.add(usa)\n# 提交会话，将国家对象保存到数据库\n# db.session.commit()会执行所有待处理的数据库操作\ndb.session.commit()\n\n# 创建城市对象，name属性设置为'北京'，通过nation参数直接关联到china对象\n# 在创建时直接建立与国家的关联关系\nbeijing = City(name='北京', nation=china)\n# 创建城市对象，name属性设置为'上海'，通过nation参数直接关联到china对象\nshanghai = City(name='上海', nation=china)\n# 创建城市对象，name属性设置为'纽约'，通过nation参数直接关联到usa对象\nnew_york = City(name='纽约', nation=usa)\n\n# 将beijing对象添加到数据库会话中\ndb.session.add(beijing)\n# 将shanghai对象添加到数据库会话中\ndb.session.add(shanghai)\n# 将new_york对象添加到数据库会话中\ndb.session.add(new_york)\n# 提交会话，将城市对象保存到数据库\ndb.session.commit()\n</code></pre>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#_3","level":4,"title":"查询关系数据","text":"<p>通过关系属性查询数据：</p> <pre><code># 通过Nation模型查询nation_name为'中国'的国家对象，返回第一个匹配的结果\n# filter_by()方法用于筛选符合条件的记录\n# first()方法返回查询结果的第一条记录，如果没有则返回None\nchina = Nation.query.filter_by(nation_name='中国').first()\n# 打印国家名称\nprint(f\"{china.nation_name}的城市有:\")\n# 遍历china对象的cities关系属性，获取所有关联的城市对象\n# cities是由relationship定义的关系属性，返回一个城市对象列表\nfor city in china.cities:\n    # 打印城市名称\n    print(f\"- {city.name}\")\n\n# 通过City模型查询name为'北京'的城市对象，返回第一个匹配的结果\nbeijing = City.query.filter_by(name='北京').first()\n# 通过beijing对象的nation属性（由backref自动创建）获取关联的国家对象，并打印信息\n# nation属性是由backref='nation'自动创建的反向引用属性\nprint(f\"{beijing.name}属于{beijing.nation.nation_name}\")\n</code></pre>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#_4","level":4,"title":"建立关系","text":"<p>1.直接通过外键字段赋值。</p> <pre><code># 直接为city对象的nation_id外键字段赋值，关联到ID为1的国家\n# 这是最直接的方式，通过设置外键字段的值来建立关系\ncity.nation_id = 1\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre> <p>2.通过关系属性添加</p> <pre><code># 通过nation对象的cities关系属性添加beijing城市对象到城市列表中\n# append()方法会将beijing对象添加到关联的城市列表中\n# 同时会自动设置beijing对象的nation_id外键字段\nnation.cities.append(beijing)\n# beijing为City对象\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre> <p>3.直接将一个对象列表赋值给关系属性</p> <pre><code># 直接将包含beijing和shanghai对象的列表赋值给nation对象的cities关系属性\n# 这种方式会替换原有的所有关联关系\n# 如果原来有关联的城市，会被移除；如果beijing或shanghai原来关联到其他国家，也会被断开\nnation.cities = [beijing, shanghai]\n# beijing和shanghai均为对象\n# 提交会话，保存更改到数据库\ndb.session.commit()\n</code></pre>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#_5","level":4,"title":"建立双向关系","text":"<p>通过在<code>relationship</code>中使用<code>backref</code>参数，我们已经建立了双向关系：</p> <pre><code># 定义Nation模型类，继承自db.Model\n# 这个类映射到数据库中的nation表\nclass Nation(db.Model):\n    \"\"\"国家模型\"\"\"\n    # 指定表名为'nation'\n    __tablename__ = 'nation'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义nation_name字段，字符串类型，最大长度50，设置唯一约束\n    nation_name = db.Column(db.String(50), unique=True)\n    # 定义一对多关系，backref参数自动在City模型中创建nation属性\n    # 'City'指定关联的模型类\n    # backref='nation'在City模型中自动创建nation属性，实现反向引用\n    # 通过cities属性可以访问该国家的所有城市\ncities = db.relationship('City', backref='nation')\n\n# 定义City模型类，继承自db.Model\n# 这个类映射到数据库中的city表\nclass City(db.Model):\n    \"\"\"城市模型\"\"\"\n    # 指定表名为'city'\n    __tablename__ = 'city'\n    # 定义id字段，整数类型，设为主键\n    id = db.Column(db.Integer, primary_key=True)\n    # 定义name字段，字符串类型，最大长度50，设置唯一约束\n    name = db.Column(db.String(50), unique=True)\n    # 外键指向nation表的id字段\n    # db.ForeignKey('nation.id')指定外键约束，关联到nation表的id字段\n    # 通过这个外键，建立了城市到国家的多对一关系\n    nation_id = db.Column(db.Integer, db.ForeignKey('nation.id'))\n</code></pre> <p>这样就建立了双向关系： - 通过<code>nation.cities</code>可以获取该国家的所有城市 - 通过<code>city.nation</code>可以获取该城市所属的国家</p> <p>下面是一对多关系操作的流程图：</p> <pre><code>graph LR\n    A[定义模型类] --&gt; B{是否包含外键}\n    B --&gt;|是| C[多的一方]\n    B --&gt;|否| D[一的一方]\n    C --&gt; E[添加nation_id外键字段]\n    D --&gt; F[添加relationship关系属性]\n    E --&gt; G[创建对象实例]\n    F --&gt; G\n    G --&gt; H{如何建立关系}\n    H --&gt; I[直接赋值外键]\n    H --&gt; J[通过关系属性append]\n    H --&gt; K[直接赋值对象列表]\n    I --&gt; L[查询数据]\n    J --&gt; L\n    K --&gt; L\n    L --&gt; M[通过cities访问城市]\n    L --&gt; N[通过nation访问国家]</code></pre> <p>使用示例：</p> <pre><code># 通过Nation模型查询nation_name为'中国'的国家对象，返回第一个匹配的结果\n# filter_by()方法用于筛选符合条件的记录\n# first()方法返回查询结果的第一条记录，如果没有则返回None\nchina = Nation.query.filter_by(nation_name='中国').first()\n# 打印国家名称\nprint(f\"{china.nation_name}的城市有:\")\n# 遍历china对象的cities关系属性，获取所有关联的城市对象\n# cities是由relationship定义的关系属性，返回一个城市对象列表\nfor city in china.cities:\n    # 打印城市名称\n    print(f\"- {city.name}\")\n\n# 通过City模型查询name为'北京'的城市对象，返回第一个匹配的结果\nbeijing = City.query.filter_by(name='北京').first()\n# 通过beijing对象的nation属性（由backref自动创建）获取关联的国家对象，并打印信息\n# nation属性是由backref='nation'自动创建的反向引用属性\nprint(f\"{beijing.name}属于{beijing.nation.nation_name}\")\n</code></pre>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E4%B8%80%E5%AF%B9%E5%A4%9A/#_6","level":2,"title":"核心要点总结","text":"<ul> <li>一对多关系：\"一\"的一方可以关联\"多\"的一方的多个记录，\"多\"的一方只能关联\"一\"的一方的一个记录</li> <li>外键：在\"多\"的一侧创建，指向\"一\"的一侧的主键，建立数据关联</li> <li>relationship函数：在\"一\"的一侧定义，用于建立对象间的关系，非数据库字段</li> <li>backref参数：最佳实践，自动在\"多\"的一侧创建反向引用，实现双向关系</li> <li>lazy参数：最佳实践，控制关联对象加载方式，优化查询性能</li> <li>cascade参数：最佳实践，控制级联操作行为，确保数据一致性</li> </ul>","path":["Python","SQLAlchemy一对多关系完整指南：模型定义、关系建立与数据操作"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/","level":1,"title":"Python 列表推导式详解","text":"<p>在数学中有一个集合推导式的概念，Python中的列表推导式（List Comprehensions）正是借鉴了这一思想，提供了一种简洁高效的创建列表的方式。</p>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#map","level":2,"title":"使用map函数创建列表","text":"<p>传统上，我们可以使用<code>map()</code>函数配合<code>lambda</code>表达式来对序列中的每个元素进行变换：</p> <pre><code># 定义一个包含数字1到8的列表\na = [1,2,3,4,5,6,7,8]\n# 使用map函数和lambda表达式计算每个元素的立方\nr = list(map(lambda x : x*x*x,a))\n# 输出结果：[1, 8, 27, 64, 125, 216, 343, 512]\nprint(r)\n</code></pre>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_1","level":2,"title":"使用列表推导式创建列表","text":"<p>列表推导式提供了一种更加简洁直观的方式来创建列表：</p> <pre><code># 定义一个包含数字1到8的列表\na = [1,2,3,4,5,6,7,8]\n# 使用列表推导式计算每个元素的立方\nb = [i**3 for i in a]\n# 输出结果：[1, 8, 27, 64, 125, 216, 343, 512]\nprint(b)\n</code></pre> <p>可以看到,列表推导式更为简洁.</p>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_2","level":2,"title":"带条件判断的列表推导式","text":"<p>列表推导式还可以加入条件判断，只选择满足条件的元素：</p> <pre><code># 定义一个包含数字1到8的列表\na = [1,2,3,4,5,6,7,8]\n# 使用列表推导式计算每个元素的立方，但只选择原数字大于等于5的元素\nb = [i**3 for i in a if i &gt;=5]\n# 输出结果：[125, 216, 343, 512]\nprint(b)\n</code></pre> <p>如果用 map 函数的话,还需要结合 filter 来过滤.</p>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_3","level":2,"title":"其他推导式","text":"<p>除了列表推导式，Python还支持集合推导式和字典推导式：</p> <pre><code># 定义一个学生年龄字典\nstudents = {\n    'm':18,\n    'y':20,\n    't':15\n}\n\n# 列表推导式：提取字典的所有键\nb = [key for key,value in students.items()]\n# 输出结果：['m', 'y', 't']\nprint(b)\n\n# 字典推导式：交换字典的键和值\nb = {value:key for key,value in students.items()}\n# 输出结果：{18: 'm', 20: 'y', 15: 't'}\nprint(b)\n</code></pre>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_4","level":2,"title":"列表推导式的使用场景","text":"<p>列表推导式在以下场景中特别有用：</p> <ol> <li>数据转换：对序列中的每个元素进行相同的变换操作</li> <li>条件过滤：从序列中筛选出满足特定条件的元素</li> <li>组合生成：生成多个序列的组合（笛卡尔积）</li> </ol>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_5","level":2,"title":"列表推导式的优势","text":"<ol> <li>简洁性：相比传统循环，代码更简洁易读</li> <li>性能：在大多数情况下，列表推导式比等价的循环更快</li> <li>Pythonic：符合Python的编程风格和哲学</li> </ol>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_6","level":2,"title":"注意事项","text":"<ol> <li>可读性：过于复杂的列表推导式会降低代码可读性，建议拆分为多行或使用传统循环</li> <li>内存使用：列表推导式会一次性生成所有元素，对于大数据集可能占用较多内存</li> <li>适用范围：仅适用于创建列表，对于其他需求可考虑生成器表达式</li> </ol>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/#_7","level":2,"title":"总结","text":"<p>列表推导式是Python中一种强大而优雅的特性，它不仅使代码更加简洁易读，还能提高执行效率。掌握列表推导式的使用方法，能够让我们在数据处理和转换时更加得心应手。但同时也需要注意保持代码的可读性，避免过度复杂的推导式。</p>","path":["Python","Python 列表推导式详解"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/","level":1,"title":"哈希冲突","text":"<p>Python中的字典底层依靠哈希表实现，在CPython中主要使用伪随机探测（pseudo-random probing）的开放寻址法来解决冲突。</p> <p>哈希表是一种key-value类型的数据结构，通过哈希函数将键映射到数组的特定位置来存储对应的值。哈希函数的作用就是建立键与数组索引之间的映射关系。</p> <p>Python字典要求保持一定的稀疏性以减少哈希冲突，负载因子通常控制在⅔左右。当增加元素导致容量不足时，会触发扩容机制，重新分配更大的内存空间并重新哈希所有元素，这可能导致键的排列顺序发生变化。因此在遍历字典时不能同时进行添加和删除操作。</p> <p>由于字典需要预留空白空间来降低冲突概率，所以在内存中的开销相对较大，这是典型的以空间换时间的设计思想。</p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#_1","level":3,"title":"哈希冲突","text":"<p>由于数据的多样性是无限的，而哈希表的存储空间是有限的，不同的键经过哈希函数计算后可能得到相同的索引位置，这种现象被称为哈希冲突（Hash Collision）。</p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#_2","level":3,"title":"哈希冲突的解决方法","text":"","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#1-open-addressing","level":4,"title":"1. 开放寻址法（Open Addressing）","text":"<p>从发生冲突的位置开始，按照某种探测规则在哈希表中寻找下一个空闲位置，将发生冲突的元素存入该位置。</p> <p>常见的探测方法包括： - 线性探测法（Linear Probing）：按固定步长依次查找下一个位置 - 平方探测法（Quadratic Probing）：按平方数步长查找下一个位置 - 双散列函数探测法（Double Hashing）：使用第二个哈希函数计算步长</p> <p>开放寻址法的缺点在于不能真正删除元素，只能做特殊标记表示删除状态，否则会导致后续查找失败。只有在需要插入新元素时才能覆盖已标记删除的位置。</p> <p>例如：现有元素1,2,3,4依次存储，若要删除3，不能直接清除其位置，而应标记为已删除。当需要插入5时，才可以覆盖原来3的位置，形成1,2,5,4的存储状态。</p> <p>Python示例： <pre><code>class OpenAddressingHashTable:\n    def __init__(self, size):\n        \"\"\"初始化哈希表\"\"\"\n        self.size = size\n        # 使用None表示空位，用特殊标记表示已删除\n        self.table = [None] * size\n        # 创建一个特殊对象用于标记删除的元素\n        self.deleted = object()\n\n    def hash_func(self, key):\n        \"\"\"哈希函数：将键映射到数组索引\"\"\"\n        return hash(key) % self.size\n\n    def insert(self, key, value):\n        \"\"\"插入键值对\"\"\"\n        index = self.hash_func(key)\n        # 线性探测：如果位置被占用且不是已删除状态，则继续查找下一个位置\n        while self.table[index] is not None and self.table[index] != self.deleted:\n            index = (index + 1) % self.size  # 循环到下一个位置\n        # 找到空位或已删除位置，插入新元素\n        self.table[index] = (key, value)\n\n    def search(self, key):\n        \"\"\"查找指定键的值\"\"\"\n        index = self.hash_func(key)\n        # 查找时跳过已删除的元素\n        while self.table[index] is not None:\n            # 如果不是已删除标记且键匹配，则返回对应的值\n            if self.table[index] != self.deleted and self.table[index][0] == key:\n                return self.table[index][1]\n            index = (index + 1) % self.size  # 继续探测下一个位置\n        return None  # 未找到\n\n    def delete(self, key):\n        \"\"\"删除指定键的元素（标记删除）\"\"\"\n        index = self.hash_func(key)\n        while self.table[index] is not None:\n            # 如果不是已删除标记且键匹配，则标记为已删除\n            if self.table[index] != self.deleted and self.table[index][0] == key:\n                self.table[index] = self.deleted\n                return True\n            index = (index + 1) % self.size\n        return False  # 未找到要删除的元素\n</code></pre></p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#2-chaining","level":4,"title":"2. 拉链法（Chaining）","text":"<p>将具有相同哈希值的元素组织成链表结构，并将链表的头指针存储在哈希表对应位置。增删改查操作主要在同义词链表中进行。</p> <p>这种方法的优点是可以真正删除元素，且不会产生聚集现象，但需要额外的空间存储指针。</p> <p>Python示例： <pre><code>class ChainingHashTable:\n    def __init__(self, size):\n        \"\"\"初始化哈希表\"\"\"\n        self.size = size\n        # 每个槽位存储一个链表（这里用列表模拟链表）\n        self.table = [[] for _ in range(size)]\n\n    def hash_func(self, key):\n        \"\"\"哈希函数：将键映射到数组索引\"\"\"\n        return hash(key) % self.size\n\n    def insert(self, key, value):\n        \"\"\"插入键值对\"\"\"\n        index = self.hash_func(key)\n        bucket = self.table[index]  # 获取对应槽位的链表\n        # 检查键是否已存在，存在则更新值\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)  # 更新已存在的键值对\n                return\n        # 键不存在，添加新的键值对到链表末尾\n        bucket.append((key, value))\n\n    def search(self, key):\n        \"\"\"查找指定键的值\"\"\"\n        index = self.hash_func(key)\n        bucket = self.table[index]  # 获取对应槽位的链表\n        # 遍历链表查找键\n        for k, v in bucket:\n            if k == key:\n                return v  # 找到则返回值\n        return None  # 未找到\n\n    def delete(self, key):\n        \"\"\"删除指定键的元素\"\"\"\n        index = self.hash_func(key)\n        bucket = self.table[index]  # 获取对应槽位的链表\n        # 遍历链表查找要删除的键\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                del bucket[i]  # 从链表中删除键值对\n                return True\n        return False  # 未找到要删除的元素\n</code></pre></p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#3-rehashing","level":4,"title":"3. 再哈希法（Rehashing）","text":"<p>使用多个不同的哈希函数，当发生冲突时依次调用下一个哈希函数进行计算。这种方法会显著增加计算开销，但在某些场景下能有效分散元素。</p> <p>Python示例： <pre><code>class RehashingHashTable:\n    def __init__(self, size):\n        \"\"\"初始化哈希表\"\"\"\n        self.size = size\n        self.table = [None] * size\n        # 定义多个哈希函数\n        self.hash_functions = [\n            lambda key, size: hash(key) % size,           # 第一个哈希函数\n            lambda key, size: (hash(key) * 31) % size,    # 第二个哈希函数\n            lambda key, size: (hash(key) * 37) % size     # 第三个哈希函数\n        ]\n\n    def insert(self, key, value):\n        \"\"\"插入键值对\"\"\"\n        # 尝试每个哈希函数\n        for hash_func in self.hash_functions:\n            index = hash_func(key, self.size)\n            # 如果当前位置为空，则插入元素\n            if self.table[index] is None:\n                self.table[index] = (key, value)\n                return True\n        # 所有哈希函数都冲突，无法插入\n        raise Exception(\"无法插入，所有哈希函数都冲突\")\n\n    def search(self, key):\n        \"\"\"查找指定键的值\"\"\"\n        # 尝试每个哈希函数\n        for hash_func in self.hash_functions:\n            index = hash_func(key, self.size)\n            # 如果当前位置不为空且键匹配，则返回值\n            if self.table[index] is not None and self.table[index][0] == key:\n                return self.table[index][1]\n        return None  # 所有哈希函数都未找到匹配元素\n</code></pre></p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#4","level":4,"title":"4. 建立公共溢出区","text":"<p>将哈希表分为基本表和溢出表两部分，当发生冲突时将元素存储到溢出区中。查找时需要同时在基本表和溢出表中进行搜索。</p> <p>Python示例： <pre><code>class OverflowAreaHashTable:\n    def __init__(self, main_size):\n        \"\"\"初始化哈希表\"\"\"\n        self.main_size = main_size\n        # 主表：用于存储直接哈希的元素\n        self.main_table = [None] * main_size\n        # 溢出区：用于存储发生冲突的元素（用列表存储）\n        self.overflow_area = []\n\n    def hash_func(self, key):\n        \"\"\"哈希函数：将键映射到主表索引\"\"\"\n        return hash(key) % self.main_size\n\n    def insert(self, key, value):\n        \"\"\"插入键值对\"\"\"\n        index = self.hash_func(key)\n        # 如果主表位置为空，直接插入\n        if self.main_table[index] is None:\n            self.main_table[index] = (key, value)\n        else:\n            # 否则插入到溢出区\n            self.overflow_area.append((key, value))\n\n    def search(self, key):\n        \"\"\"查找指定键的值\"\"\"\n        index = self.hash_func(key)\n        # 先在主表查找\n        if self.main_table[index] is not None and self.main_table[index][0] == key:\n            return self.main_table[index][1]\n\n        # 再在溢出区查找\n        for k, v in self.overflow_area:\n            if k == key:\n                return v\n        return None  # 未找到\n\n    def delete(self, key):\n        \"\"\"删除指定键的元素\"\"\"\n        index = self.hash_func(key)\n        # 在主表删除\n        if self.main_table[index] is not None and self.main_table[index][0] == key:\n            self.main_table[index] = None\n            return True\n\n        # 在溢出区删除\n        for i, (k, v) in enumerate(self.overflow_area):\n            if k == key:\n                del self.overflow_area[i]\n                return True\n        return False  # 未找到要删除的元素\n</code></pre></p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/#python","level":3,"title":"Python字典中的哈希冲突处理","text":"<p>在CPython实现中，Python字典采用了一种优化的开放寻址法——伪随机探测。这种方法相比线性探测能够更好地避免元素聚集，提高查找效率。</p> <p>Python字典的关键特性： 1. 从Python 3.7开始，字典保持插入顺序 2. 负载因子控制在约⅔，超过此值会触发扩容 3. 扩容时容量通常增长为接近原容量2倍的质数 4. 删除操作使用延迟删除策略，标记删除但不立即释放空间</p>","path":["Python","哈希冲突"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/","level":1,"title":"Python容器、可迭代对象、迭代器与生成器详解","text":"<p>理一理可迭代对象,迭代器,生成器之间的联系.</p> <p></p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#_1","level":2,"title":"概念关系图","text":"<pre><code>graph LR\n    A[容器Container] --&gt; B[可迭代对象Iterable]\n    B --&gt; C[迭代器Iterator]\n    C --&gt; D[生成器Generator]\n\n    A -- \"存储在内存中\" --&gt; B\n    B -- \"实现__iter__方法\" --&gt; C\n    C -- \"实现__next__方法\" --&gt; D\n    D -- \"使用yield关键字\" --&gt; D</code></pre>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#container","level":2,"title":"容器Container","text":"<p>1.容器是一个存储多个元素的数据结构.</p> <p>2.容器中的元素可以通过迭代获取.</p> <p>3.所有容器中的元素被存放在内存中.</p> <p>4.常见的容器比如 list,tuple,dict,set,str.也都是可迭代对象(Iterable)</p> <pre><code>from collections import Iterable\na = ['test','test2']  # 创建一个包含两个字符串元素的列表\nfor i in a: # 通过for循环迭代获取列表中的每个元素\n  print(i)  # 打印当前元素\nisinstance(a,Iterable) # 检查列表a是否为可迭代对象，返回True\n</code></pre>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#iterable","level":2,"title":"可迭代对象Iterable","text":"<p>可迭代对象是可以通过被迭代获取的对象.</p> <p>内部定义了可返回迭代器的_iter_()方法.</p> <p>比如:</p> <pre><code>x = [1, 2, 3]  # 创建一个包含三个整数的列表\nfor elem in x:  # 遍历列表中的每个元素\n  print(elem)   # 打印当前元素\n</code></pre> <p>x列表是一个可迭代对象,在for循环中调用iter()方法变成迭代器,遍历x实际上是调用elem=next(x).</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#iterator","level":2,"title":"迭代器Iterator","text":"<p>迭代器是一个带状态的对象,该状态用于记录当前迭代所在位置,以方便下次迭代的时候获取正确的元素.</p> <p>Iterator实现了<code>__iter__</code>和<code>__next__</code>方法.</p> <p>迭代器不会一次性把所有的元素都加载到内存,而是在需要的时候才会生成返回结果.</p> <p>1.可迭代对象!=迭代器.</p> <p>2.迭代器带状态.</p> <p>3.迭代器不会直接加载到内存.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#generator","level":2,"title":"生成器generator","text":"<p>生成器是一种特殊的迭代器.</p> <p>生成器可以传入数据进行计算,并根据变量内容计算结果后返回.</p> <p>使用send方法传入数据.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#generator-func","level":3,"title":"生成器函数generator func","text":"<p>含有yield关键字的函数就是生成器函数.</p> <pre><code>def d():\n    print('第一次调用')\n    sum = 0\n    # 第一次c.send(None)只执行到 yield sum\n    # 再次进入时执行 value = yield sum,将yield 赋值给sum,然后赋值给value\n    value = yield sum\n    sum = value + sum\n    print('sum的值为:%d' %sum)\n    print('value%d' %value) # 输出value1\n    # c.send(1)只执行到yield sum, 再次进入时执行 value = 2\n    value = yield sum\n    print('value%d' %value) # 输出value2\n    yield sum\n\n\nc = d()  # 创建生成器对象，此时函数并未执行\nd = c.send(None)  # 启动生成器，执行到第一个yield，返回sum的值并赋值给d\nprint('生成器传出的值为%d' % d)\nd = c.send(1)  # 传入数值1，通过yield传递给value，继续执行到第二个yield\nprint('第二次调用返回值为%d' % d)\nd = c.send(2)  # 传入数值2，继续执行到第三个yield\nprint('第三次调用返回值为%d' % d)\n</code></pre> <p>可以看到,yield将sum的值传递给了<code>调用方</code>,将send()方法递进来的<code>1</code>传递给了<code>value</code>.</p> <p>保存了迭代器的状态.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#generator-expression","level":3,"title":"生成器表达式generator expression","text":"<p>生成器表达式是列表生成式的生成器版本.返回一个生成器对象.</p> <pre><code>from collections import Iterator\na = (x*x for x in range(10))  # 创建一个生成器表达式，计算0-9的平方\nprint(isinstance(a,Iterator))   # 检查a是否为迭代器对象，返回True\nfor x in a:                    # 遍历生成器中的每个值\n  print(x)                     # 打印当前值\n</code></pre>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#_2","level":3,"title":"生成器的优势","text":"<p>延迟加载:在处理长序列问题时,更加节省存储空间.</p> <p>比如打印一个斐波那契数列,原始方法如下:</p> <pre><code>def fab(max):\n    n, a, b = 0, 0, 1   # 初始化计数器n和斐波那契数列的前两个数a,b\n    L = []               # 创建空列表存储斐波那契数列\n    while n &lt; max:       # 当计数器小于最大值时继续循环\n        L.append(b)      # 将当前斐波那契数添加到列表中\n        a, b = b, a + b  # 计算下一个斐波那契数\n        n += 1           # 计数器加1\n    return L             # 返回完整的斐波那契数列\nprint(fab(20))          # 打印前20个斐波那契数\n</code></pre> <p>所有元素都存放在列表L里,空间开销较大.</p> <p>使用生成器的方法如下:</p> <pre><code>def fab(max):\n    n, a, b = 0, 0, 1     # 初始化计数器n和斐波那契数列的前两个数a,b\n    while n &lt; max:         # 当计数器小于最大值时继续循环\n        yield b            # 每次在这里中断, 把b的值传递给i, 同时保存中断时的状态\n        a, b = b, a + b    # 计算下一个斐波那契数\n        n += 1             # 计数器加1\nfor i in fab(20):          # 使用生成器遍历前20个斐波那契数\n    print(i)               # 打印当前斐波那契数\n</code></pre> <p>这种方法不需要额外的列表空间开销.</p>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#send","level":3,"title":"send()方法是交互的","text":"<pre><code>def my_generator(n):\n    for i in range(n):     # 循环n次\n        yield i            # 依次产出0到n-1的数字\ng = my_generator(5)        # 创建生成器对象，可产出0-4的数字\nprint(next(g))             # 获取下一个值，输出0\nprint(next(g))             # 获取下一个值，输出1\nprint(g.send(100))         # 发送数据100，但仍然返回下一个值2\nprint(next(g))             # 获取下一个值，输出3\nprint(next(g))             # 获取下一个值，输出4\n</code></pre> <p>可以看到第7行的g.send()方法输出了本来next()方法应该输出2.</p> <p>1.send()的主要作用是当需要手动更改生成器里面的某一个值并且使用它，则发送进去一个数据保存到yield语句的返回值，以提供后续使用.</p> <p>2.send()的返回值就是那个本来应该被迭代出来的那个值。这样既可以保证能够传入新的值，原来的值也不会弄丢.</p> <p>总结</p> 对象 特点 功能 iterable 实现了<code>__iter__()</code>方法 返回一个iterator iterator 实现了<code>__iter__()</code>和<code>__next__()</code>方法.数据需要时才会存储到内存中 逐个传出数据 generator yield替换了<code>__next__()</code>方法,可以中断,保存了<code>状态</code>的迭代器 逐个传入/传出数据 container 元素都存储在内存中元素可以通过迭代获取","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E5%AE%B9%E5%99%A8Container/#_3","level":2,"title":"核心要点总结","text":"<ol> <li> <p>容器(Container)：存储多个元素的数据结构，所有元素都被存放在内存中，常见的容器包括list、tuple、dict、set、str等。</p> </li> <li> <p>可迭代对象(Iterable)：可通过迭代获取的对象，内部定义了可返回迭代器的<code>__iter__()</code>方法。</p> </li> <li> <p>迭代器(Iterator)：带状态的对象，实现了<code>__iter__()</code>和<code>__next__()</code>方法，不会一次性加载所有元素到内存，在需要时才会生成返回结果。</p> </li> <li> <p>生成器(Generator)：一种特殊的迭代器，使用yield关键字，可以中断并保存状态，支持传入数据进行计算。</p> </li> <li> <p>生成器函数：包含yield关键字的函数，每次调用会返回一个生成器对象。</p> </li> <li> <p>生成器表达式：列表生成式的生成器版本，返回一个生成器对象，具有延迟加载的特性。</p> </li> <li> <p>send()方法：用于向生成器传入数据并获取下一个值，实现生成器与调用方的数据交互。                   |</p> </li> </ol>","path":["Python","Python容器、可迭代对象、迭代器与生成器详解"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/","level":1,"title":"数据挖掘—将数据转换成知识","text":"<p>数据 未处理的原始事实和数字。</p> <p>知识 经过处理、分析和解释后的信息，具有实际意义和价值。</p> <p>模式 数据中存在的规律性和重复性结构。</p> <p>信息 含义广泛，既包含未经处理的原始数据，也包含经过处理的知识。</p>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_2","level":3,"title":"什么是数据挖掘？","text":"<p>KDD（Knowledge Discovery in Databases，数据库中的知识发现）与数据挖掘基本等同。数据挖掘是KDD过程中的一个核心步骤，指的是从大量数据中自动或半自动地发现有用信息和知识的过程。</p> <p>在各个行业，对数据挖掘的认识有所不同，这是因为他们所受的教育背景、工作环境以及基础知识存在差异，导致在理解和应用上会有细微差别。</p>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_3","level":3,"title":"数据挖掘的特点","text":"<p>数据挖掘具有以下几个显著特点：</p> <ul> <li>数据真实性：处理的是现实世界中真实存在的数据</li> <li>数据海量性：面对的是大规模甚至超大规模的数据集</li> <li>决策支持性：满足决策者的多样化查询需求</li> <li>知识新颖性：挖掘出的知识通常是事先未知的、潜在的、有价值的新知识</li> </ul>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_4","level":3,"title":"数据挖掘的核心功能（六大类）","text":"<p>数据挖掘的主要功能可以分为以下六类：</p> <ol> <li> <p>概念描述（Concept Description）：对数据的特征和特性进行概括性描述，帮助理解数据的整体情况</p> </li> <li> <p>关联关系分析（Association）：发现数据项之间的关联规则，例如购物篮分析中\"购买面包的顾客通常也会购买牛奶\"</p> </li> <li> <p>分类和预测（Classification and Prediction）</p> </li> <li>分类：针对离散的数据，将数据划分到预定义的类别中</li> <li> <p>预测：针对连续的数据，预测数值型结果</p> </li> <li> <p>聚类分析（Cluster Analysis）：将相似的数据对象归为一类，形成不同的簇群，属于无监督学习</p> </li> <li> <p>异常分析（Outlier Analysis）：识别数据中的异常点或离群点，常用于欺诈检测等领域</p> </li> <li> <p>趋势和演化分析（Trend and Evolution Analysis）：分析数据随时间变化的规律和趋势</p> </li> </ol>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#interesting","level":3,"title":"如何判断发现的模式是否有趣（Interesting）","text":"<p>判断数据挖掘发现的模式是否有价值，主要从主观和客观两个维度来评估：</p> <ul> <li>主观方面：基于用户的领域知识、兴趣和需求来判断模式是否有意义</li> <li>客观方面：通过统计学指标和数学方法来量化模式的有趣程度</li> </ul>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_5","level":3,"title":"数据挖掘框架","text":"<p>一个完整的数据挖掘系统通常包含以下三个核心组成部分：</p> <ul> <li>技术（Techniques）：各种数据挖掘算法和技术方法</li> <li>应用（Applications）：数据挖掘在具体领域的实际应用场景</li> <li>原理（Principles）：指导数据挖掘实践的理论基础和原则</li> </ul>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_6","level":3,"title":"数据挖掘的分类","text":"<p>数据挖掘可以从多个角度进行分类：</p> <ol> <li>按学习方式分类：</li> <li>监督学习：使用带有标签的训练数据</li> <li>无监督学习：处理没有标签的数据</li> <li> <p>半监督学习：结合少量有标签和大量无标签数据</p> </li> <li> <p>按功能分类：</p> </li> <li>描述性数据挖掘：描述数据的特征和模式</li> <li>预测性数据挖掘：基于历史数据预测未来趋势</li> </ol>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#imp","level":3,"title":"数据挖掘算法的组件化思想（IMP）","text":"<p>现代数据挖掘算法设计趋向于组件化，这种思想将复杂的算法分解为标准化的组件，提高复用性和灵活性。</p>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_7","level":4,"title":"五个标准组件","text":"<ol> <li>模型和模式结构（Model and Pattern Structure）：定义数据的表示方式和模式的形式</li> <li>数据挖掘任务（Data Mining Task）：明确要解决的具体问题类型</li> <li>评分函数（Scoring Function）：评估模式质量的度量标准</li> <li>搜索和优化方法（Search and Optimization Method）：寻找最优解的策略，影响算法的效果</li> <li>数据管理策略（Data Management Strategy）：高效处理和存储数据的方法，影响算法的效率</li> </ol>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_8","level":4,"title":"组件化思想的核心理念","text":"<p>模型是全局的，模式是局部的。两者相互联系，共同构成完整的数据挖掘解决方案。</p> <p>当面对一个新的应用需求时，数据挖掘人员应该从组件的角度出发，根据具体应用需求，考虑应该选取哪些组件来组合成新的算法，而不是局限于现有的成熟算法。这种思维方式提高了算法设计的灵活性和针对性。</p>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E2%80%94%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%A5%E8%AF%86/#_9","level":3,"title":"总结","text":"<p>数据挖掘作为从海量数据中提取有价值知识的重要技术，在商业智能、科学研究、社会管理等各个领域发挥着越来越重要的作用。理解数据挖掘的基本概念、核心功能和实现方法，有助于我们更好地利用这一技术解决实际问题。</p>","path":["Python","数据挖掘—将数据转换成知识"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/","level":1,"title":"深入理解Python生成器：高效内存管理的利器","text":"<p>生成器可以动态的生成后续的元素,</p> <p>是一种基于某种算法推算出来的, 因为在需要时才生成,故使用生成器可以节省大量的空间.</p> <p>在 Python 中,这种一边循环一边计算的机制,称为生成器: generator.</p>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#python","level":1,"title":"深入理解Python生成器：高效内存管理的利器","text":"","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#generator","level":1,"title":"创建 generator","text":"","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#_1","level":2,"title":"[]改()","text":"<p>只要将一个列表生成式的<code>[]</code>改成<code>()</code>,就创建了一个 generator:</p> <pre><code>&gt;&gt;&gt;L=[x*x for x in range(10)]  # 创建一个列表推导式，生成0到9的平方数列表\n&gt;&gt;&gt;L\n[0,1,4,9,16,25,36,49,64,81]\n&gt;&gt;&gt;g=(x*x for x in range(10))  # 将列表推导式的方括号改为圆括号，创建生成器\n&gt;&gt;&gt;g\n&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;\n</code></pre> <p>L 是 一个 list, g 是 一个 generator.</p> <p>通过 next()函数,可以获得 generator 的下一个返回值.</p> <p>即,按照设定的算法生成了后续序列</p> <p>一般来说,是使用 for 循环来迭代 generator.</p> <pre><code>&gt;&gt;&gt;g=(x*x for x in range(10))  # 创建一个生成器对象\n&gt;&gt;&gt;for n in g:  # 使用for循环迭代生成器\n       print(n)  # 逐个打印生成器产生的值\n</code></pre>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#yield","level":2,"title":"yield","text":"<p>有些函数也可以通过算法实现自增,</p> <p>但是这种函数只是有了'自我生成算法',还缺少一个非常重要的标志'yield'.</p> <p>yield 取代 return, 为函数返回值.</p> <p>如果一个函数定义包含关键字 yield, 那么这个函数就不再是一个普通的函数,而是一个 generator.</p>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#yield-return","level":2,"title":"yield 与 return 的区别","text":"<p>当一个生成器函数调用 yield, 生成器函数的'状态'会被冻结,所有的变量的值会被保留下来,下一行要执行的代码的位置也会被记录,知道再次调用 next().一旦 next() 再次被调用,生成器函数会从它上次离开的地方开始.</p> <p>下面通过一个简单的流程图来展示生成器函数的工作原理：</p> <pre><code>graph TD\n    A[调用生成器函数] --&gt; B[执行到yield语句]\n    B --&gt; C[产出值并冻结状态]\n    C --&gt; D[下次调用next()]\n    D --&gt; E[从上次停止位置继续执行]\n    E --&gt; F{是否还有yield语句?}\n    F --&gt;|是| B\n    F --&gt;|否| G[函数结束抛出StopIteration]</code></pre> <p>为了更好地理解生成器与普通函数的区别，我们可以通过下面的对比图来说明：</p> <pre><code>graph LR\n    A[普通函数] -- 调用 --&gt; B[执行函数体]\n    B --&gt; C[遇到return语句]\n    C --&gt; D[返回值并结束函数]\n    D --&gt; E[函数状态完全丢失]\n\n    F[生成器函数] -- 首次调用 --&gt; G[执行到yield语句]\n    G --&gt; H[产出值并冻结状态]\n    H --&gt; I[暂停执行等待下次调用]\n    I -- next()调用 --&gt; J[从暂停点继续执行]\n    J --&gt; K[遇到下一个yield或结束]\n    K --&gt;|遇到yield| H\n    K --&gt;|函数结束| L[抛出StopIteration异常]\n\n    style A fill:#FFE4C4,stroke:#333\n    style F fill:#87CEEB,stroke:#333\n    style C fill:#FFB6C1,stroke:#333\n    style H fill:#98FB98,stroke:#333</code></pre>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#_2","level":1,"title":"总结","text":"<ul> <li>generator 是用来产生一系列的值的.</li> <li>yield 向 generator 函数返回结果</li> <li>yield 唯一做的另一件事就是保存一个 generator 的状态</li> <li>generator 是特殊类型的迭代器</li> <li>可以通过 next()来获取 generator 的下一个值</li> <li>可以通过隐私调用 next()来忽略某些值.</li> </ul>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#_3","level":1,"title":"例子","text":"<p>杨辉三角问题</p> <ol> <li> <p>每个数等于它上方两数之和。</p> </li> <li> <p>每行数字左右对称，由1开始逐渐变大</p> </li> </ol> <p>下面是我的代码:</p> <pre><code>def triangles():\n    n = 0  # 初始化行号计数器\n    while True:  # 无限循环生成杨辉三角\n        if n==0:  # 处理第一行，只有一个元素1\n            L2=[1]\n            yield L2  # 产出第一行\n        elif n==1:  # 处理第二行，有两个元素1\n            L2=[1,1]\n            yield L2  # 产出第二行\n        else:  # 处理后续行\n            L=L2.copy()  # 复制上一行数据，避免引用问题\n            i = 0\n            while i &lt; n-1:  # 计算中间的数值\n                L2[i+1]=L[i]+L[i+1]  # 当前位置的值等于上一行相邻两数之和\n                i=i+1\n            L2.append(1)  # 每行末尾添加1\n            yield L2  # 产出当前行\n        n += 1  # 行号递增\n\n# 使用示例\nn = 0\nfor t in triangles():  # 迭代生成器函数\n    print(t)  # 打印每一行\n    n = n + 1\n    if n == 10:  # 控制只输出前10行\n        break\n</code></pre> <p>在代码中,还有一个值得注意的地方.</p> <p><code>L=L2</code>是软复制,仅仅是指针指向.</p> <p>如果不希望两个 list 之间的变动相互干扰,就需要使用 <code>L.copy()</code>方法来实现硬复制.</p> <p>另外,我的代码表现出很浓的 C 风格.</p> <p>以下是看到的其他同学的实践方法,值得学习:</p> <pre><code>def triangles():\n    L = [1]  # 初始化第一行\n    while True:  # 无限循环，持续生成下一行\n        yield L  # 产出当前行\n        L.append(0)  # 在列表末尾添加0，便于计算\n        # 通过列表推导式生成下一行：每个元素等于当前位置和前一个位置元素之和\n        L = [L[i - 1] + L[i] for i in range(len(L))]\n</code></pre> <p>还有另一种写法:</p> <pre><code>def triangles():\n    ret = [1]  # 初始化第一行\n    pre = ret[:]  # 复制当前行作为下一次计算的基准\n    while True:  # 无限循环，持续生成下一行\n        yield ret  # 产出当前行\n        for i in range(1, len(ret)):  # 从第二个元素开始计算\n            ret[i] = pre[i] + pre[i - 1]  # 当前位置值等于上一行相邻两数之和\n        ret.append(1)  # 行尾添加1\n        pre = ret[:]  # 复制当前行作为下一次计算的基准\n</code></pre> <p>​</p>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%94%9F%E6%88%90%E5%99%A8-%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/#_4","level":1,"title":"核心要点总结","text":"<ol> <li>生成器(generator)是一种惰性计算机制，按需生成数据，节省内存空间，特别适用于处理大量数据或无限序列的场景</li> <li>yield关键字是生成器函数的核心标识，用于产出值并保存函数状态，与return不同，yield不会终止函数执行，而是暂停并保存状态</li> <li>生成器是特殊的迭代器，支持next()函数逐个获取值，可以通过for循环迭代生成器来遍历所有值</li> <li>有两种创建生成器的方式：通过列表推导式将方括号<code>[]</code>改为圆括号<code>()</code>创建简单生成器对象；通过在函数中使用yield关键字创建生成器函数</li> <li>生成器函数在每次调用next()时从上次暂停的位置继续执行，这种特性使得生成器能够保存执行状态并在需要时恢复</li> <li>使用for循环迭代生成器是最佳实践，避免手动调用next()可能引发的StopIteration异常</li> </ol>","path":["Python","深入理解Python生成器：高效内存管理的利器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/","level":1,"title":"装饰器","text":"<p>对装饰器的理解</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_1","level":2,"title":"什么是装饰器","text":"<p>装饰器（Decorator）是Python中的一个重要特性，它允许我们在不修改原函数代码的情况下，为函数增加额外的功能。</p> <p>装饰器本质上是一个接受函数作为参数并返回函数的高阶函数。它遵循\"对修改是封闭的，对扩展是开放的\"原则，能够将核心业务代码与辅助功能代码分离，提高代码的复用性和可维护性.</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_2","level":2,"title":"装饰器实现的例子","text":"<pre><code>import time\ndef decorator(func):\n    # 定义包装函数，用于增强原函数功能\n    def wrapper():\n        # 在执行原函数前打印当前时间戳\n        print(time.time())\n        # 执行原函数\n        func()\n    # 返回包装函数\n    return wrapper\n\n@decorator\ndef f1():\n    # 原始函数，只打印一条消息\n    print('This is a func')\n</code></pre> <p>使用装饰器的原因 对修改是封闭的,对扩展是开放的.</p> <p>装饰器将核心业务代码和其他\"装饰性\"的代码进行分离,这样不仅提高了代码复用,而且也方便了代码管理.</p> <p>@就像是一个装饰一样,为函数增加了新的功能.</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_3","level":3,"title":"带有一个参数的装饰器","text":"<pre><code>import time\ndef decorator(func):\n    # wrapper函数接收一个参数func_name\n    def wrapper(func_name):\n        # 在执行原函数前打印当前时间戳\n        print(time.time())\n        # 调用原始函数并传递参数\n        func(func_name)\n    return wrapper\n\n@decorator\ndef f1(func_name):\n    # 原始函数，用于打印函数名称\n    print('This is a func '+func_name)\n</code></pre>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_4","level":3,"title":"不同数量参数的装饰器","text":"<p>装饰器应具有通用性,所以不应被参数数量所限制,所以这里可以使用可变参数 *args.</p> <pre><code>import time\ndef decorator(func):\n    # 使用*args接收任意数量的位置参数，提高装饰器通用性\n    def wrapper(*args):\n        # 打印执行时间\n        print(time.time())\n        # 将所有参数传递给原函数，保持原函数功能完整性\n        func(*args)\n    return wrapper\n\n@decorator\ndef f1(func_name):\n    # 接收一个参数的函数\n    print('This is a func '+func_name)\n\n@decorator\ndef f2(func_name1,func_name2):\n    # 接收两个参数的函数\n    print('This is a func '+func_name1)\n    print('This is a func '+func_name2)\n\n# 分别调用装饰后的函数\nf1('func')\nf2('func1','func2')\n</code></pre>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_5","level":3,"title":"加入了关键字参数时","text":"<pre><code>import time\ndef decorator(func):\n    # 同时支持位置参数和关键字参数，使装饰器更加灵活\n    def wrapper(*args, **kwargs):\n        # 打印执行时间\n        print(time.time())\n        # 将位置参数和关键字参数都传递给原函数，保持原函数的所有功能\n        func(*args, **kwargs)\n    return wrapper\n\n@decorator\ndef f1(func_name):\n    # 接收一个位置参数的函数\n    print('This is a func '+func_name)\n\n@decorator\ndef f2(func_name1,func_name2):\n    # 接收两个位置参数的函数\n    print('This is a func '+func_name1)\n    print('This is a func '+func_name2)\n\n@decorator\ndef f3(func_name1,func_name2,**kw):\n    # 接收两个位置参数和任意关键字参数的函数\n    print('This is a func '+func_name1)\n    print('This is a func '+func_name2)\n    # 打印所有关键字参数\n    print(kw)\n\nf1('func')\nf2('func1','func2')\nf3('func1','func2',a = 1, b = 2,c = '123')\n</code></pre>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_6","level":3,"title":"技巧总结","text":"<p>通过*args(可变参数),kw(关键字参数)来提升装饰器的通用性.</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_7","level":2,"title":"带参数的装饰器","text":"<p>除了普通的装饰器外，Python还支持带参数的装饰器。这种装饰器可以接收额外的参数来控制装饰器的行为。</p> <pre><code>import time\n\ndef log_decorator(prefix):\n    \"\"\"\n    带参数的装饰器，接收一个prefix参数用于自定义日志前缀\n    \"\"\"\n    # 返回真正的装饰器函数\n    def decorator(func):\n        # 包装函数，负责增强原函数功能\n        def wrapper(*args, **kwargs):\n            # 在执行函数前打印带有自定义前缀的日志\n            print(f\"[{prefix}] {time.time()}: 函数 {func.__name__} 开始执行\")\n            # 执行原函数并保存返回值\n            result = func(*args, **kwargs)\n            # 在函数执行后打印结束日志\n            print(f\"[{prefix}] {time.time()}: 函数 {func.__name__} 执行完毕\")\n            # 返回原函数的执行结果\n            return result\n        return wrapper\n    return decorator\n\n# 使用带参数的装饰器\n@log_decorator(\"DEBUG\")\ndef greet(name):\n    # 原始函数，接收一个名字参数并返回问候语\n    print(f\"Hello, {name}!\")\n    return f\"Greeting sent to {name}\"\n\n# 调用装饰后的函数\nresult = greet(\"Alice\")\nprint(f\"返回值: {result}\")\n</code></pre> <p>在这个例子中： 1. <code>log_decorator</code> 是一个接收参数 <code>prefix</code> 的函数 2. 它返回一个真正的装饰器 <code>decorator</code> 3. <code>decorator</code> 接收被装饰的函数 <code>func</code> 并返回包装函数 <code>wrapper</code> 4. 通过这种方式，我们可以在装饰器中使用外部传入的参数</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_8","level":2,"title":"类装饰器","text":"<p>Python中的类也可以作为装饰器使用，只要这个类实现了 <code>__call__</code> 方法：</p> <pre><code>import time\n\nclass TimerDecorator:\n    \"\"\"\n    计时装饰器类，用于统计函数执行时间\n    \"\"\"\n    def __init__(self, func):\n        # 初始化时保存被装饰的函数\n        self.func = func\n        # 初始化执行时间为0\n        self.elapsed_time = 0\n\n    def __call__(self, *args, **kwargs):\n        # 记录开始时间\n        start = time.time()\n        # 执行原函数并保存返回值\n        result = self.func(*args, **kwargs)\n        # 记录结束时间\n        end = time.time()\n        # 计算并保存执行时间\n        self.elapsed_time = end - start\n        # 打印函数执行耗时信息\n        print(f\"函数 {self.func.__name__} 执行耗时: {self.elapsed_time:.4f} 秒\")\n        # 返回原函数的执行结果\n        return result\n\n    def get_elapsed_time(self):\n        \"\"\"获取上次执行的时间\"\"\"\n        return self.elapsed_time\n\n# 使用类装饰器\n@TimerDecorator\ndef slow_function():\n    \"\"\"模拟一个耗时操作\"\"\"\n    time.sleep(1)\n    print(\"耗时操作完成\")\n\n# 调用装饰后的函数\nslow_function()\nprint(f\"记录的执行时间: {slow_function.get_elapsed_time():.4f} 秒\")\n</code></pre> <p>类装饰器的优势： 1. 可以保存状态信息（如执行时间） 2. 可以提供额外的方法来访问内部状态 3. 代码结构更加清晰，适合复杂的装饰器逻辑</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_9","level":2,"title":"装饰器设计的最佳实践和注意事项","text":"","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_10","level":3,"title":"最佳实践","text":"<ol> <li>保持装饰器的通用性</li> <li>使用 <code>*args</code> 和 <code>**kwargs</code> 确保装饰器能适用于任何签名的函数</li> <li> <p>正确传递函数的返回值</p> </li> <li> <p>使用 functools.wraps 保持函数元信息 <pre><code>from functools import wraps\n\ndef my_decorator(func):\n    # 使用wraps装饰器保持原函数的元信息（如__name__, __doc__等）\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        # 在原函数执行前的操作\n        print(\"执行前的操作\")\n        # 执行原函数并保存返回值\n        result = func(*args, **kwargs)\n        # 在原函数执行后的操作\n        print(\"执行后的操作\")\n        # 返回原函数的执行结果\n        return result\n    return wrapper\n</code></pre></p> </li> <li> <p>合理处理带参数的装饰器</p> </li> <li>当装饰器需要参数时，使用三层嵌套函数结构</li> <li> <p>确保参数的作用域正确</p> </li> <li> <p>注意装饰器的执行时机</p> </li> <li>装饰器在函数定义时就会执行，而不是在函数调用时</li> <li>避免在装饰器中放置耗时操作</li> </ol>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_11","level":3,"title":"注意事项","text":"<ol> <li>避免修改原函数的签名</li> <li>装饰器应尽量保持原函数的参数签名不变</li> <li> <p>如果必须修改，应清楚地文档化</p> </li> <li> <p>小心装饰器的叠加顺序 <pre><code>@decorator_a\n@decorator_b\n@decorator_c\ndef func():\n    pass\n# 执行顺序：decorator_a(decorator_b(decorator_c(func)))\n# 即从最靠近函数的装饰器开始执行：decorator_c -&gt; decorator_b -&gt; decorator_a\n</code></pre></p> </li> <li> <p>装饰器对性能的影响</p> </li> <li>每一层装饰器都会增加函数调用的开销</li> <li> <p>对于性能敏感的代码，要考虑装饰器的影响</p> </li> <li> <p>调试装饰器时的问题</p> </li> <li>装饰器会使调试变得复杂，因为实际执行的是包装函数</li> <li>使用 <code>functools.wraps</code> 可以缓解这一问题</li> </ol>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_12","level":2,"title":"总结","text":"<p>装饰器是Python中强大而优雅的特性，它提供了一种干净的方式来修改或增强函数的功能，而无需修改函数本身的代码。掌握装饰器的使用对于编写高质量的Python代码至关重要。</p> <p>通过本文的学习，你应该能够： - 理解装饰器的基本原理和工作机制 - 编写适用于不同场景的装饰器 - 使用带参数的装饰器和类装饰器 - 遵循装饰器设计的最佳实践</p>","path":["Python","装饰器"],"tags":[]},{"location":"Python/%E8%A3%85%E9%A5%B0%E5%99%A8/#_13","level":2,"title":"核心要点总结","text":"<ol> <li>装饰器本质：装饰器是一个接受函数作为参数并返回函数的高阶函数</li> <li>通用性设计：使用<code>*args</code>和<code>**kwargs</code>确保装饰器适用于任何函数签名</li> <li>参数化装饰器：通过三层嵌套函数结构实现带参数的装饰器</li> <li>类装饰器：实现<code>__call__</code>方法的类可以用作装饰器，并能保存状态</li> <li>最佳实践：使用<code>functools.wraps</code>保持函数元信息，避免性能问题</li> <li>执行顺序：多个装饰器的执行顺序是从最靠近函数的装饰器开始执行</li> </ol>","path":["Python","装饰器"],"tags":[]},{"location":"%E6%9D%82/GitHub%E4%B9%9F%E6%98%AF%E6%9C%89%E7%A6%BB%E7%BA%BF%E7%89%88%E7%9A%84/","level":1,"title":"GitHub也是有离线版的","text":"<p>因为伟大的 GFW 墙掉了 AWS, 所以GitHub的 Windows 版总是安装失败,所以去找了找是否有离线版安装包.</p> <pre><code>在线版安装:https://github-windows.s3.amazonaws.com/GitHubSetup.exe\n离线版安装:https://github-windows.s3.amazonaws.com/standalone/GitHubDesktop.exe\n</code></pre> <p>因为在安装过程中要保持联网,所以安装离线版安装包也有可能会失败,多试几次即可.</p>","path":["杂","GitHub也是有离线版的"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","level":1,"title":"Markdown 语法和 MWeb 写作使用说明","text":"","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#markdown","level":2,"title":"Markdown 的设计哲学","text":"<p>Markdown 的目標是實現「易讀易寫」。 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。 Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_1","level":2,"title":"本文约定","text":"<p>如果有写 <code>效果如下：</code>， 在 MWeb 编辑状态下只有用 <code>CMD + 4</code> 或 <code>CMD + R</code> 预览才可以看效果。</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_2","level":2,"title":"标题","text":"<p>Markdown 语法：</p> <pre><code># 第一级标题 `&lt;h1&gt;` \n## 第二级标题 `&lt;h2&gt;` \n###### 第六级标题 `&lt;h6&gt;` \n</code></pre> <p>效果如下：</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#h1","level":1,"title":"第一级标题 <code>&lt;h1&gt;</code>","text":"","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#h2","level":2,"title":"第二级标题 <code>&lt;h2&gt;</code>","text":"","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#h6","level":6,"title":"第六级标题 <code>&lt;h6&gt;</code>","text":"","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_3","level":2,"title":"强调","text":"<p>Markdown 语法：</p> <pre><code>*这些文字会生成`&lt;em&gt;`*\n_这些文字会生成`&lt;u&gt;`_\n\n**这些文字会生成`&lt;strong&gt;`**\n__这些文字会生成`&lt;strong&gt;`__\n</code></pre> <p>在 MWeb 中的快捷键为： <code>CMD + U</code>、<code>CMD + I</code>、<code>CMD + B</code> 效果如下：</p> <p>这些文字会生成<code>&lt;em&gt;</code> 这些文字会生成<code>&lt;u&gt;</code></p> <p>这些文字会生成<code>&lt;strong&gt;</code> 这些文字会生成<code>&lt;strong&gt;</code></p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_4","level":2,"title":"换行","text":"<p>四个及以上空格加回车。 如果不想打这么多空格，只要回车就为换行，请勾选：<code>Preferences</code> - <code>Themes</code> - <code>Translate newlines to &lt;br&gt; tags</code></p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_5","level":2,"title":"列表","text":"","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_6","level":3,"title":"无序列表","text":"<p>Markdown 语法：</p> <pre><code>* 项目一 无序列表 `* + 空格键`\n* 项目二\n* 项目二的子项目一 无序列表 `TAB + * + 空格键`\n* 项目二的子项目二\n</code></pre> <p>在 MWeb 中的快捷键为： <code>Option + U</code> 效果如下：</p> <ul> <li>项目一 无序列表 <code>* + 空格键</code></li> <li>项目二</li> <li>项目二的子项目一 无序列表 <code>TAB + * + 空格键</code></li> <li>项目二的子项目二</li> </ul>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_7","level":3,"title":"有序列表","text":"<p>Markdown 语法：</p> <pre><code>1. 项目一 有序列表 `数字 + . + 空格键`\n2. 项目二 \n3. 项目三\n1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`\n2. 项目三的子项目二\n</code></pre> <p>效果如下：</p> <ol> <li>项目一 有序列表 <code>数字 + . + 空格键</code></li> <li>项目二 </li> <li>项目三</li> <li>项目三的子项目一 有序列表 <code>TAB + 数字 + . + 空格键</code></li> <li>项目三的子项目二</li> </ol>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#task-lists","level":3,"title":"任务列表（Task lists）","text":"<p>Markdown 语法：</p> <pre><code>- [ ] 任务一 未做任务 `- + 空格 + [ ]`\n- [x] 任务二 已做任务 `- + 空格 + [x]`\n</code></pre> <p>效果如下：</p> <ul> <li> 任务一 未做任务 <code>- + 空格 + [ ]</code></li> <li> 任务二 已做任务 <code>- + 空格 + [x]</code></li> </ul>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_8","level":2,"title":"图片","text":"<p>Markdown 语法：</p> <pre><code>![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)\n格式: ![Alt Text](url)\n</code></pre> <p><code>Control + Shift + I</code> 可插入Markdown语法。 如果是 MWeb 的文档库中的文档，还可以用拖放图片、<code>CMD + V</code> 粘贴、<code>CMD + Option + I</code> 导入这三种方式来增加图片。 效果如下：</p> <p></p> <p>MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 <code>-w + 图片宽度</code> 即可，比如说要设置上面的图片的宽度为 140，语法如下：</p> <p></p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_9","level":2,"title":"链接","text":"<p>Markdown 语法：</p> <pre><code>email &lt;example@example.com&gt;\n[GitHub](http://github.com)\n自动生成连接  &lt;http://www.github.com/&gt;\n</code></pre> <p><code>Control + Shift + L</code> 可插入Markdown语法。 如果是 MWeb 的文档库中的文档，拖放或<code>CMD + Option + I</code> 导入非图片时，会生成连接。 效果如下：</p> <p>Email 连接： example@example.com 连接标题Github网站 自动生成连接像： http://www.github.com/ 这样</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_10","level":2,"title":"区块引用","text":"<p>Markdown 语法：</p> <pre><code>某某说:\n&gt; 第一行引用\n&gt; 第二行费用文字\n</code></pre> <p><code>CMD + Shift + B</code> 可插入Markdown语法。 效果如下：</p> <p>某某说:</p> <p>第一行引用 第二行费用文字</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_11","level":2,"title":"行内代码","text":"<p>Markdown 语法：</p> <pre><code>像这样即可：`&lt;addr&gt;` `code`\n</code></pre> <p><code>CMD + K</code> 可插入Markdown语法。 效果如下：</p> <p>像这样即可：<code>&lt;addr&gt;</code> <code>code</code></p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_12","level":2,"title":"多行或者一段代码","text":"<p>Markdown 语法：</p> <pre><code>```js\nfunction fancyAlert(arg) {\n    if(arg) {\n    $.facebox({div:'#foo'})\n    }\n\n}\n```\n</code></pre> <p><code>CMD + Shift + K</code> 可插入Markdown语法。 效果如下：</p> <pre><code>function fancyAlert(arg) {\n    if(arg) {\n    $.facebox({div:'#foo'})\n    }\n\n}\n</code></pre>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_13","level":2,"title":"顺序图或流程图","text":"<p>Markdown 语法：</p> <pre><code>```sequence\n张三-&gt;李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四--&gt;张三: 忙得吐血，哪有时间写。\n```\n\n```flow\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n```\n</code></pre> <p>效果如下（ <code>Preferences</code> - <code>Themes</code> - <code>Enable sequence &amp; flow chart</code> 才会看到效果 ）：</p> <pre><code>张三-&gt;李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四--&gt;张三: 忙得吐血，哪有时间写。\n</code></pre> <pre><code>st=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</code></pre> <p>更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_14","level":2,"title":"表格","text":"<p>Markdown 语法：</p> <pre><code>第一格表头 | 第二格表头\n--------- | -------------\n内容单元格 第一列第一格 | 内容单元格第二列第一格\n内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格\n</code></pre> <p>效果如下：</p> 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_15","level":2,"title":"删除线","text":"<p>Markdown 语法：</p> <p>加删除线像这样用： 删除这些</p> <p>效果如下：</p> <p>加删除线像这样用： 删除这些</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_16","level":2,"title":"分隔线","text":"<p>以下三种方式都可以生成分隔线：</p> <pre><code>***\n\n*****\n\n- - -\n</code></pre> <p>效果如下：</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#mathjax","level":2,"title":"MathJax","text":"<p>Markdown 语法：</p> <pre><code>块级公式：\n$$  x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =\n1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}\n{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]\n\n行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n</code></pre> <p>效果如下（<code>Preferences</code> - <code>Themes</code> - <code>Enable MathJax</code> 才会看到效果）：</p> <p>块级公式： $$  x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p> <p>\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\]</p> <p>行内公式： \\(\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N\\)</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#footnote","level":2,"title":"脚注（Footnote）","text":"<p>Markdown 语法：</p> <pre><code>这是一个脚注：[^sample_footnote]\n</code></pre> <p>效果如下：</p> <p>这是一个脚注：<sup>1</sup></p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#_17","level":2,"title":"注释和阅读更多","text":"<p>Actions-&gt;Insert Read More Comment 或者 <code>Command + .</code> 注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。</p>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Markdown%20%E8%AF%AD%E6%B3%95%E5%92%8C%20MWeb%20%E5%86%99%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/#toc","level":2,"title":"TOC","text":"<p>Markdown 语法：</p> <pre><code>[TOC]\n</code></pre> <p>效果如下：</p> <ul> <li>Markdown 语法和 MWeb 写作使用说明<ul> <li>Markdown 的设计哲学</li> <li>本文约定</li> <li>标题</li> </ul> </li> <li>第一级标题 &lt;h1&gt;<ul> <li>第二级标题 &lt;h2&gt;<ul> <li>第六级标题 &lt;h6&gt;</li> </ul> </li> <li>强调</li> <li>换行</li> <li>列表<ul> <li>无序列表</li> <li>有序列表</li> <li>任务列表（Task lists）</li> </ul> </li> <li>图片</li> <li>链接</li> <li>区块引用</li> <li>行内代码</li> <li>多行或者一段代码</li> <li>顺序图或流程图</li> <li>表格</li> <li>删除线</li> <li>分隔线</li> <li>MathJax</li> <li>脚注（Footnote）</li> <li>注释和阅读更多</li> <li>TOC</li> </ul> </li> </ul> <ol> <li> <p>这里是脚注信息 ↩</p> </li> </ol>","path":["杂","Markdown 语法和 MWeb 写作使用说明"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","level":1,"title":"Nginx 高级配置与性能优化完全指南","text":"<p>title: Nginx 高级配置与性能优化完全指南</p> <p>date: 2018/03/13  12:12:59</p> <p>tags: server</p> <p>categories: Nginx</p> <p>简介  </p>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_1","level":2,"title":"静态资源配置","text":"<p>配置语法- sendfile</p> <pre><code># sendfile 配置语法\n# Syntax: sendfile on | off;  # 是否启用 sendfile\n# Default: sendfile off;      # 默认关闭\n# Context: server,location,if in location  # 可配置上下文\nSyntax: sendfile on | off;\nDefault: sendfile off;\nContext: server,location,if in location\n</code></pre> <p>配置语法- tcp-nopush</p> <pre><code># tcp_nopush 配置语法\n# Syntax: tcp_nopush on | off;  # 是否启用 tcp_nopush\n# Default: tcp_push off;        # 默认关闭\n# Context: http,server,location  # 可配置上下文\n# 在 sendfile 开启的情况下, 提高网络包的传递效率\nSyntax: tcp_nopush on | off\nDefault: tcp_push off;\nContext: http,server,location\n</code></pre> <p>不着急推送,而是将多个 tcp 打包进行集中发送,以提升效率.适合大文件</p> <p>配置语法- tcp-nodelay</p> <pre><code># tcp_nodelay 配置语法\n# Syntax: tcp_nodelay on | off;  # 是否启用 tcp_nodelay\n# Default: tcp_nodelay on;       # 默认开启\n# Context: http,server,location   # 可配置上下文\n# 在 keepalive 连接下,提高网络包的传递实时性\nSyntax: tcp_nodelay on | off\nDefault: tcp_nodelay on;\nContext: http,server,location\n</code></pre> <p>配置语法-压缩</p> <pre><code># gzip 压缩等级设置\n# Syntax: gzip_comp_level level;  # 设置压缩级别 (1-9)\n# Default: gzip_comp_level 1;     # 默认压缩级别为1\n# Context: http,server,location    # 可配置上下文\nSyntax: gzip_comp_level level;\nDefault: gzip_comp_level 1;\nContext: http,server,location\n</code></pre> <p>扩展 Nginx 压缩模块</p> <p><code>http_gzip_static_module</code>-预读 gzip 功能. </p> <p><code>http_gunzip_module</code>-应用支持 gunzip 的压缩功能. (很少用到)</p> <p>gzip 对文本的压缩很好,对图片的压缩一般.</p> <pre><code>\n</code></pre>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_2","level":2,"title":"浏览器缓存","text":"<p>HTTP 协议定义的缓存机制(如 Expires,Cache-control等)</p> <p>校验过期机制</p> 校验是否过期 Expires(http1.0),Cache-Control(http1.1) (max-age定义一个周期) 如果 max-age 显示已经过期,则会检查后面两个校验 协议中 Etag头信息校验 Etag(保存一个字符串,来识别缓存,类似\"别名\") Last-Modified 头信息校验 Last-Modified(保存一个时间,精确到秒,如果两个时间不一致,则服务器会传递一份新的) <p>Max-age&lt;=0时,就要求每次请求都会要求服务器检查是否过期.即使服务器端设置了 max-age, 但是浏览器为了实时更新,会将 request里 max-age 设置为0.</p> <p></p> <p>静态资源配置场景设置</p> <p>配置语法-expires</p> <pre><code># expires 缓存配置示例\nlocation / {\n    # 设置资源缓存时间为24小时\n    expires  24h;\n}\n</code></pre>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_3","level":2,"title":"跨域访问","text":"<p>为什么浏览器禁止跨域访问?</p> <p>不安全,容易出现 CSRF 攻击.</p> <p>nginx 怎么做?</p> <pre><code># add_header 配置语法\n# Syntax: add_header name value [always];  # 添加响应头\n# Default: -                               # 默认无\n# Context: http,server,location,if in location  # 可配置上下文\nSyntax: add_header name value [always];\nDefault: - \nContext: http,server,location,if in location\n</code></pre> <p>如果服务器允许跨域访问,则浏览器不会禁止. 通过检查Access-Control-Allow-Origin 头来确定是否允许.</p> <pre><code># 跨域访问配置示例\nlocation ~ .*\\.(htm|html)$ {\n    # 允许来自 http://www.qq.com 的跨域请求\n    add_header Access-Control-Allow-Origin http://www.qq.com;\n    # 允许的请求方法\n    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n}\n</code></pre> <p>如果将 域名替换成*,则会对 CSRF 攻击完全开放.</p>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_4","level":2,"title":"防盗链","text":"<p>简单防盗链实现.</p> <p>防盗链设置思路.</p> <p>首要方式:区别哪些请求是非正常的用户请求</p> <p>基于 http_refer 防盗链配置模块</p> <pre><code># 防盗链配置示例\n# valid_referers表示允许哪些referer信息访问 \n# none表示允许没有带referer的信息过来    \n# blocked表示允许被防火墙屏蔽的referer\n# ip 只允许这个ip的referer过来访问.\nvalid_referers none blocked ip ;\n# 如果referer无效，则返回403错误\nif($invalid_referer){\n    return 403;\n}\n</code></pre> <p>__'referer'__是告诉服务器这个请求是从哪个页面链接过来的.</p> <p>如果直接访问页面,则在 access.log 里面为 \"-\".</p> <p>进阶解决方案:</p> <p>后期补充</p>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_5","level":2,"title":"代理服务","text":"<p>正向代理</p> <p>客户端—代理—|— 服务端</p> <p>反向代理</p> <p>客户端—|—代理—服务端</p> <p>区别在于代理的对象不一样.</p> <p>正向代理代理的对象是客户端.</p> <p>反向代理代理的对象是服务端.</p>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_6","level":4,"title":"配置语法","text":"<pre><code># proxy_pass 配置语法\n# Syntax: proxy_pass URL;  # 设置代理目标地址\n# Default: -             # 默认无\n# Context: location,if in location,limit_except  # 可配置上下文\n# 示例: http://ip:80/url/\nSyntax: proxy_pass URL;\nDefault: -\nContext: location,if in location,limit_except\n</code></pre> <p>服务器 A (10.211.55.15)  服务器 B(10.211.55.16)</p> <p>服务器A,</p> <pre><code># 限制访问IP示例\nlocation / {\n    # 如果请求来源IP不是指定的服务器B IP，则拒绝访问\n    if($http_x_forwarded_for !~*\"^10\\.211\\.55\\.16\"){\n        return 403;\n    }\n}\n</code></pre> <p>这样设置后,所有不是来自服务器 B 的访问,都会被返回403.</p> <p>服务器 B,</p> <pre><code># 反向代理配置示例\nlocation /{\n    # 将请求转发到目标服务器\n    proxy_pass $http_host$request_uri;\n}\n</code></pre> <p>注意 uri 和 url 是不同的.</p> <p>uri 统一资源标志符, url 统一资源定位符.</p> <p>一个用于解析,一个用于直接传递路径.</p> <p>其他语法配置</p> <p>proxy_buffering 缓冲区</p> <p>proxy_redirect 跳转重定向</p> <p>proxy_set_header 头信息 ,扩展 proxy_hide_header,proxy_set_body</p> <p>proxy_connect_timeout  超时 ,扩展 proxy_read_timeout,proxy_send_timeout</p>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#proxy","level":3,"title":"proxy 常用配置","text":"<pre><code># 代理服务完整配置示例\nlocation / {\n    # 设置代理目标地址\n    proxy_pass http://127.0.0.1:8080;\n    # 设置重定向行为\n    proxy_redirect default;\n\n    # 设置请求头信息\n    proxy_set_header Host $http_host;\n    proxy_set_header X-Real-IP $remote_addr;\n\n    # 设置连接超时时间(秒)\n    proxy_connect_timeout 30;\n    # 设置发送超时时间(秒)\n    proxy_send_timeout 60;\n    # 设置接收超时时间(秒)\n    proxy_read_timeout 60;\n\n    # 设置代理缓冲区大小\n    proxy_buffer_size 32k;\n    # 启用代理缓冲\n    proxy_buffering on;\n    # 设置缓冲区数量和大小\n    proxy_buffers 4 128k;\n    # 设置繁忙缓冲区大小\n    proxy_busy_buffers_size 256k;\n    # 设置临时文件最大大小\n    proxy_max_temp_file_size 256k;\n}\n</code></pre> <p>如果有多个 proxy 方案,则可以使用</p> <pre><code># 引用外部配置文件示例\nlocation / {\n    # 包含外部代理参数配置文件\n    include proxy_params;\n}\n</code></pre> <p>然后把配置放在文件里.</p>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#_7","level":2,"title":"核心要点总结","text":"<ul> <li> <p>静态资源配置优化：通过sendfile、tcp_nopush和tcp_nodelay等配置提升文件传输效率，其中sendfile用于零拷贝传输，tcp_nopush用于打包发送，tcp_nodelay用于提高实时性</p> </li> <li> <p>HTTP缓存机制：利用Expires和Cache-Control控制缓存周期，结合ETag和Last-Modified进行缓存校验，实现高效的浏览器缓存策略</p> </li> <li> <p>跨域访问控制：通过add_header指令设置Access-Control-Allow-Origin等响应头，实现安全的跨域资源共享(CORS)机制</p> </li> <li> <p>防盗链机制：基于http_refer配置valid_referers指令，有效防止其他网站盗用本站资源，保护服务器带宽</p> </li> <li> <p>代理服务配置：区分正向代理和反向代理的应用场景，通过proxy_pass等指令实现请求转发和负载均衡</p> </li> <li> <p>代理参数调优：合理配置proxy_buffering、proxy_connect_timeout等参数，优化代理服务的性能和稳定性</p> </li> </ul>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#nginx","level":2,"title":"Nginx代理请求处理流程","text":"<p>下面的图表展示了Nginx作为反向代理时的请求处理流程：</p> <pre><code>graph LR\n    A[客户端发起请求] --&gt; B{Nginx接收请求}\n    B --&gt; C[Nginx根据配置路由请求]\n    C --&gt; D[添加代理请求头]\n    D --&gt; E[转发请求到后端服务器]\n    E --&gt; F[接收后端响应]\n    F --&gt; G[处理响应头]\n    G --&gt; H[返回响应给客户端]</code></pre>","path":["杂","Nginx 高级配置与性能优化完全指南"],"tags":[]},{"location":"%E6%9D%82/markdown/","level":1,"title":"Markdown in 5min","text":"","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#headers","level":2,"title":"Headers","text":"<pre><code># H1 Header\n## H2 Header\n### H3 Header\n#### H4 Header\n##### H5 Header\n###### H6 Header\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#text-formatting","level":2,"title":"Text formatting","text":"<pre><code>**bold text**\n*italic text*\n***bold and italic***\n~~strikethrough~~\n`inline code`\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#links-and-images","level":2,"title":"Links and images","text":"<pre><code>[Link text](https://example.com)\n[Link with title](https://example.com \"Hover title\")\n![Alt text](image.jpg)\n![Image with title](image.jpg \"Image title\")\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#lists","level":2,"title":"Lists","text":"<pre><code>Unordered:\n- Item 1\n- Item 2\n  - Nested item\n\nOrdered:\n1. First item\n2. Second item\n3. Third item\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#blockquotes","level":2,"title":"Blockquotes","text":"<pre><code>&gt; This is a blockquote\n&gt; Multiple lines\n&gt;&gt; Nested quote\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#code-blocks","level":2,"title":"Code blocks","text":"<pre><code>```javascript\nfunction hello() {\n  console.log(\"Hello, world!\");\n}\n```\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#tables","level":2,"title":"Tables","text":"<pre><code>| Header 1 | Header 2 | Header 3 |\n|----------|----------|----------|\n| Row 1    | Data     | Data     |\n| Row 2    | Data     | Data     |\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#horizontal-rule","level":2,"title":"Horizontal rule","text":"<pre><code>---\nor\n***\nor\n___\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#task-lists","level":2,"title":"Task lists","text":"<pre><code>- [x] Completed task\n- [ ] Incomplete task\n- [ ] Another task\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#escaping-characters","level":2,"title":"Escaping characters","text":"<pre><code>Use backslash to escape: \\* \\_ \\# \\`\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E6%9D%82/markdown/#line-breaks","level":2,"title":"Line breaks","text":"<pre><code>End a line with two spaces  \nto create a line break.\n\nOr use a blank line for a new paragraph.\n</code></pre>","path":["杂","Markdown in 5min"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/","level":1,"title":"琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南","text":"<p>小琥珀长大了，之前给他买的应急粮已经吃得差不多了，是时候重新评估和选择适合他的猫粮了。本文基于2023年最新的猫粮市场情况和营养学研究，为大家提供一份全面的猫粮选购指南。</p>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_1","level":2,"title":"猫咪的营养需求基础知识","text":"","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_2","level":3,"title":"猫咪的特殊营养需求","text":"<p>猫是纯肉食动物，其营养需求与犬类和人类有显著不同。选择猫粮时，必须考虑以下关键营养素：</p> <pre><code>1. 必需氨基酸：猫自身不能合成的氨基酸包括牛磺酸和精氨酸，缺乏会导致严重健康问题\n\n2. 必需维生素：猫自身不能合成维生素A、维生素B3(烟酸)、维生素B6和维生素D，必须从食物中获取\n\n3. 必需脂肪酸：花生四烯酸(AA)是猫必需的脂肪酸，只存在于动物性食物中\n\n4. 蛋白质需求：成年猫日粮中蛋白质含量不应低于21%，生长发育期的幼猫不应低于33%\n</code></pre>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_3","level":3,"title":"如何判断猫粮质量","text":"<p>选择猫粮时，应重点关注以下几点：</p> <ol> <li>配料表分析：配料按添加量递减排列，前三种原料最为重要</li> <li>优质猫粮：前三位应为明确标示的肉类蛋白质来源</li> <li>中等猫粮：前五位中有2-3种肉类蛋白质来源</li> <li> <p>低质猫粮：前三位主要是谷物、淀粉或植物蛋白</p> </li> <li> <p>蛋白质来源质量：</p> </li> <li>鲜肉/完整肉 &gt; 肉粉 &gt; 表述含糊的肉类来源</li> <li> <p>动物蛋白 &gt; 植物蛋白（猫无法有效利用植物蛋白）</p> </li> <li> <p>添加剂考量：</p> </li> <li>避免含人工色素、香料和防腐剂的产品</li> <li>优先选择使用天然防腐方法的产品</li> </ol>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#2023","level":2,"title":"2023年高品质猫粮品牌评测","text":"<p>注意：以下营养数据基于2023年最新配方，各品牌可能会不定期调整配方。</p>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_4","level":3,"title":"顶级猫粮品牌","text":"<p>渴望(Orijen)：高端猫粮的代表，2023年在多个权威榜单中位列前三</p> <p>特点：85%高品质动物蛋白，明确标注各种肉类占比，无谷配方，无人工添加剂 适合人群：预算充足，追求最高品质的铲屎官 最新营养成分：粗蛋白(最小值) 40%，粗脂肪(最小值) 20%，粗纤维(最大) 3%，碳水化合物(估算) 19% 优点：肉含量高，原料可追溯，品控严格 缺点：价格较高，部分猫咪可能因豆类成分导致软便</p> <p>GO!(GO! SOLUTIONS)：高蛋白低碳水的代表，性价比极高</p> <p>特点：超高蛋白质(47%以上)，极低碳水(约12%)，多种肉类配方 适合人群：希望为猫提供高蛋白饮食，但预算有限的铲屎官 最新营养成分：粗蛋白(最小值) 47%，粗脂肪(最小值) 18%，粗纤维(最大) 1.5% 优点：蛋白质含量极高，性价比好，16磅大包约500元 缺点：主要使用肉粉而非鲜肉，但高品质肉粉的营养价值仍然很高</p> <p>爱肯拿(ACANA)：\"低配版渴望\"，性价比更高</p> <p>特点：与渴望同厂生产，75%优质动物蛋白，无肉粉，原料可追溯 适合人群：希望兼顾品质与预算的铲屎官 最新营养成分：粗蛋白(最小值) 37%，粗脂肪(最小值) 20%，粗纤维(最大) 3% 优点：高品质保证，比渴望更经济实惠 缺点：蛋白质含量略低于渴望</p>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_5","level":3,"title":"中高端猫粮品牌","text":"<p>NOW(NOW FRESH)：对肠胃敏感猫咪友好的选择</p> <p>特点：使用新鲜肉类和优质蛋白，添加益生菌，无谷配方 适合人群：肠胃敏感、容易软便的猫咪 最新营养成分：粗蛋白(最小值) 31%，粗脂肪(最小值) 18%，粗纤维(最大) 3.5% 优点：对肠胃友好，改善软便效果显著 缺点：蛋白质含量相对较低，淀粉含量偏高</p> <p>素力高(Solid Gold)：2023年猫粮十大品牌之一，草本配方特色</p> <p>特点：创立于1974年，专注草本与天然配方研究，整体性营养理念 适合人群：希望为猫提供均衡营养的铲屎官 最新营养成分：粗蛋白(最小值) 40%，粗脂肪(最小值) 18%，粗纤维(最大) 3% 优点：配方均衡，添加多种草本植物，促进消化健康 缺点：部分猫咪可能不适应草本风味</p> <p>天然百利(Instinct)：高肉含量，原料简单</p> <p>特点：成立于2001年，专注于高肉含量配方，原料简单纯净 适合人群：希望为猫提供接近自然饮食的铲屎官 最新营养成分：粗蛋白(最小值) 43%，粗脂肪(最小值) 19%，粗纤维(最大) 3% 优点：高肉含量，原料简单纯净，适口性好 缺点：价格较高</p>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_6","level":3,"title":"性价比猫粮品牌","text":"<p>美士(Science Diet)：性价比较高的中端选择</p> <p>特点：配方稳定，营养均衡，价格适中 适合人群：预算有限但不想牺牲品质的铲屎官 最新营养成分：粗蛋白(最小值) 36%，粗脂肪(最小值) 19%，粗纤维(最大) 4% 优点：价格亲民，配方稳定，适口性尚可 缺点：原料中谷物含量较高</p> <p>皇家(Royal Canin)：处方粮的代表，针对特定健康问题</p> <p>特点：针对不同健康问题和年龄段的专业配方 适合人群：有特殊健康需求的猫咪 优点：针对性强，医院和猫舍口碑不错 缺点：油脂含量较高，部分产品添加了人工成分</p>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_7","level":2,"title":"琥珀的猫粮最终选择","text":"<p>考虑到琥珀的年龄、体型和活动量，以及预算因素，我们最终选择了GO!九种肉配方作为他的主食。原因如下：</p> <ol> <li>超高蛋白质含量(47%)满足猫咪作为肉食动物的需求</li> <li>极低碳水化合物含量(12%)，符合猫咪的自然饮食结构</li> <li>多种肉类来源提供全面的氨基酸谱</li> <li>性价比极高，长期喂养经济实惠</li> <li>适口性好，琥珀非常喜欢吃</li> </ol>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]},{"location":"%E7%94%9F%E6%B4%BB/%E7%90%A5%E7%8F%80%E7%9A%84%E7%8C%AB%E7%B2%AE%E9%80%89%E5%AE%9A/#_8","level":2,"title":"猫粮喂养建议","text":"<ol> <li>逐渐过渡：更换猫粮时，应在7-10天内逐渐过渡，避免肠胃不适</li> <li>定量喂养：根据猫咪体重和活动量确定每日喂食量，避免过量</li> <li>干湿搭配：适当添加湿粮，增加水分摄入，预防泌尿系统问题</li> <li>定期评估：观察猫咪的体重、毛发、精神状态和排便情况，及时调整喂食方案</li> </ol> <p>初步确定幼猫期吃专业幼猫粮,比如 雪山还有 Go!</p> <p>长大了,可以考虑雪山,金装素力高和 Go!</p>","path":["生活","琥珀的猫粮选定 - 2023年最新猫粮评测与选择指南"],"tags":[]}]}